(self.webpackChunkwebpack_babel_template=self.webpackChunkwebpack_babel_template||[]).push([[835],{702:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnBhY2stYmFiZWwtdGVtcGxhdGUvLi9zcmMvcGFnZXMveXQtbXVzaWMtbHlyaWNzL3N0eWxlcy9pbmRleC5zY3NzPzFmYzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///702\n")},92:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.MusicPlayer = void 0;\nclass MusicPlayer {\n    constructor(file, lyricArr = null) {\n        this.file = file;\n        this.lyricArr = lyricArr;\n        this.lyricSpans = null;\n        // For efficient updates of classes\n        this.currentLyricIndex = 0;\n        this.handleSeekFn = this.handleSeek.bind(this);\n        this.updateProgressFn = this.updateProgress.bind(this);\n        this.updateLyricClassesFn = this.softUpdateLyricClasses.bind(this);\n        this.audioEl = document.getElementById("music-player-audio");\n        this.progressEl = document.querySelector(".music-player__progress");\n        this.audioEl.src = URL.createObjectURL(file);\n        this.pausePlayBtnEl = document.getElementById("play-pause-btn");\n        this.pausePlayBtnEl.addEventListener("click", () => {\n            if (this.audioEl.paused) {\n                this.pausePlayBtnEl.classList.add("playing");\n                this.pausePlayBtnEl.classList.remove("paused");\n                this.play();\n            }\n            else {\n                this.pausePlayBtnEl.classList.remove("playing");\n                this.pausePlayBtnEl.classList.add("paused");\n                this.pause();\n            }\n        });\n        this.audioEl.addEventListener("timeupdate", this.updateProgressFn);\n        this.audioEl.addEventListener("timeupdate", this.updateLyricClassesFn);\n        this.initProgressEvents();\n        this.initLyricEvents();\n    }\n    play() {\n        this.hardUpdateLyricClasses();\n        this.audioEl.play();\n    }\n    pause() {\n        this.audioEl.pause();\n    }\n    hardUpdateLyricClasses() {\n        var _a;\n        const time = this.audioEl.currentTime;\n        const lArr = this.lyricArr;\n        if (!lArr) {\n            return;\n        }\n        // Mark all the lyrics till the active one as played\n        (_a = this.lyricSpans) === null || _a === void 0 ? void 0 : _a.forEach((span, i) => {\n            span.classList.remove("active");\n            span.classList.remove("unvisited");\n            span.classList.remove("visited");\n            if (lArr[i][0] > time) {\n                span.classList.add("unvisited");\n            }\n            else if (lArr[i][0] <= time) {\n                span.classList.add("visited");\n            }\n            if (lArr[i][0] <= time && lArr[i + 1] && lArr[i + 1][0] >= time) {\n                this.currentLyricIndex = i;\n                span.scrollIntoView({ block: "center", behavior: "smooth" });\n                span.classList.add("active");\n            }\n        });\n    }\n    softUpdateLyricClasses() {\n        // Soft update - basically more efficient than hard update\n        if (!this.lyricArr) {\n            return;\n        }\n        if (this.lyricArr[this.currentLyricIndex + 1][0] <= this.audioEl.currentTime) {\n            this.moveToNextLyric();\n        }\n    }\n    moveToNextLyric() {\n        var _a, _b, _c;\n        // Change the old active lyric to visited\n        (_a = this.lyricSpans) === null || _a === void 0 ? void 0 : _a[this.currentLyricIndex].classList.remove("active");\n        (_b = this.lyricSpans) === null || _b === void 0 ? void 0 : _b[this.currentLyricIndex].classList.add("visited");\n        this.currentLyricIndex++;\n        const nextLyric = (_c = this.lyricSpans) === null || _c === void 0 ? void 0 : _c[this.currentLyricIndex];\n        if (nextLyric) {\n            nextLyric.scrollIntoView({ block: "center", behavior: "smooth" });\n            nextLyric.classList.remove("unvisited");\n            nextLyric.classList.add("active");\n        }\n    }\n    updateProgress() {\n        this.progressEl.style.setProperty("--progress", `${(this.audioEl.currentTime / this.audioEl.duration) * 100}%`);\n        if (this.audioEl.currentTime >= this.audioEl.duration) {\n            this.pausePlayBtnEl.classList.remove("playing");\n            this.pausePlayBtnEl.classList.add("paused");\n        }\n    }\n    initProgressEvents() {\n        // Add drag event listeners\n        this.progressEl.addEventListener("mousedown", (e) => {\n            this.handleSeek(e);\n            window.addEventListener("mousemove", this.handleSeekFn);\n        });\n        window.addEventListener("mouseup", () => {\n            window.removeEventListener("mousemove", this.handleSeekFn);\n        });\n        this.progressEl.addEventListener("click", this.handleSeekFn);\n    }\n    initLyricEvents() {\n        if (!this.lyricArr) {\n            return;\n        }\n        const lyricsContentEl = document.querySelector(".lyrics-card__content");\n        for (const [timeStamp, lyric] of this.lyricArr) {\n            const span = document.createElement("span");\n            span.classList.add("lyrics-card__content__lyric");\n            span.textContent = `${lyric}`;\n            span.addEventListener("click", () => {\n                this.audioEl.currentTime = timeStamp;\n                this.hardUpdateLyricClasses();\n            });\n            lyricsContentEl.appendChild(span);\n        }\n        this.lyricSpans = document.querySelectorAll(".lyrics-card__content__lyric");\n    }\n    handleSeek(e) {\n        const { clientX } = e;\n        const { left, width } = this.progressEl.getBoundingClientRect();\n        const percentage = (clientX - left) / width;\n        this.audioEl.currentTime = this.audioEl.duration * percentage;\n        this.hardUpdateLyricClasses();\n    }\n    destroy() {\n        this.audioEl.removeEventListener("timeupdate", this.updateProgressFn);\n        this.audioEl.removeEventListener("timeupdate", this.updateLyricClassesFn);\n        this.audioEl.src = "";\n    }\n}\nexports.MusicPlayer = MusicPlayer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUNBQXFDO0FBQzNFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFDQUFxQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHlEQUF5RDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnBhY2stYmFiZWwtdGVtcGxhdGUvLi9zcmMvcGFnZXMveXQtbXVzaWMtbHlyaWNzL3NjcmlwdHMvTXVzaWNQbGF5ZXIudHM/NWM2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXVzaWNQbGF5ZXIgPSB2b2lkIDA7XG5jbGFzcyBNdXNpY1BsYXllciB7XG4gICAgY29uc3RydWN0b3IoZmlsZSwgbHlyaWNBcnIgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMubHlyaWNBcnIgPSBseXJpY0FycjtcbiAgICAgICAgdGhpcy5seXJpY1NwYW5zID0gbnVsbDtcbiAgICAgICAgLy8gRm9yIGVmZmljaWVudCB1cGRhdGVzIG9mIGNsYXNzZXNcbiAgICAgICAgdGhpcy5jdXJyZW50THlyaWNJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Vla0ZuID0gdGhpcy5oYW5kbGVTZWVrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3NGbiA9IHRoaXMudXBkYXRlUHJvZ3Jlc3MuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVMeXJpY0NsYXNzZXNGbiA9IHRoaXMuc29mdFVwZGF0ZUx5cmljQ2xhc3Nlcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmF1ZGlvRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm11c2ljLXBsYXllci1hdWRpb1wiKTtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5tdXNpYy1wbGF5ZXJfX3Byb2dyZXNzXCIpO1xuICAgICAgICB0aGlzLmF1ZGlvRWwuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICAgICAgdGhpcy5wYXVzZVBsYXlCdG5FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxheS1wYXVzZS1idG5cIik7XG4gICAgICAgIHRoaXMucGF1c2VQbGF5QnRuRWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvRWwucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZVBsYXlCdG5FbC5jbGFzc0xpc3QuYWRkKFwicGxheWluZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlUGxheUJ0bkVsLmNsYXNzTGlzdC5yZW1vdmUoXCJwYXVzZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlUGxheUJ0bkVsLmNsYXNzTGlzdC5yZW1vdmUoXCJwbGF5aW5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGF1c2VQbGF5QnRuRWwuY2xhc3NMaXN0LmFkZChcInBhdXNlZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF1ZGlvRWwuYWRkRXZlbnRMaXN0ZW5lcihcInRpbWV1cGRhdGVcIiwgdGhpcy51cGRhdGVQcm9ncmVzc0ZuKTtcbiAgICAgICAgdGhpcy5hdWRpb0VsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aW1ldXBkYXRlXCIsIHRoaXMudXBkYXRlTHlyaWNDbGFzc2VzRm4pO1xuICAgICAgICB0aGlzLmluaXRQcm9ncmVzc0V2ZW50cygpO1xuICAgICAgICB0aGlzLmluaXRMeXJpY0V2ZW50cygpO1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLmhhcmRVcGRhdGVMeXJpY0NsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5hdWRpb0VsLnBsYXkoKTtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMuYXVkaW9FbC5wYXVzZSgpO1xuICAgIH1cbiAgICBoYXJkVXBkYXRlTHlyaWNDbGFzc2VzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLmF1ZGlvRWwuY3VycmVudFRpbWU7XG4gICAgICAgIGNvbnN0IGxBcnIgPSB0aGlzLmx5cmljQXJyO1xuICAgICAgICBpZiAoIWxBcnIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXJrIGFsbCB0aGUgbHlyaWNzIHRpbGwgdGhlIGFjdGl2ZSBvbmUgYXMgcGxheWVkXG4gICAgICAgIChfYSA9IHRoaXMubHlyaWNTcGFucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKHNwYW4sIGkpID0+IHtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LnJlbW92ZShcInVudmlzaXRlZFwiKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LnJlbW92ZShcInZpc2l0ZWRcIik7XG4gICAgICAgICAgICBpZiAobEFycltpXVswXSA+IHRpbWUpIHtcbiAgICAgICAgICAgICAgICBzcGFuLmNsYXNzTGlzdC5hZGQoXCJ1bnZpc2l0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsQXJyW2ldWzBdIDw9IHRpbWUpIHtcbiAgICAgICAgICAgICAgICBzcGFuLmNsYXNzTGlzdC5hZGQoXCJ2aXNpdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxBcnJbaV1bMF0gPD0gdGltZSAmJiBsQXJyW2kgKyAxXSAmJiBsQXJyW2kgKyAxXVswXSA+PSB0aW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50THlyaWNJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgc3Bhbi5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiBcImNlbnRlclwiLCBiZWhhdmlvcjogXCJzbW9vdGhcIiB9KTtcbiAgICAgICAgICAgICAgICBzcGFuLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzb2Z0VXBkYXRlTHlyaWNDbGFzc2VzKCkge1xuICAgICAgICAvLyBTb2Z0IHVwZGF0ZSAtIGJhc2ljYWxseSBtb3JlIGVmZmljaWVudCB0aGFuIGhhcmQgdXBkYXRlXG4gICAgICAgIGlmICghdGhpcy5seXJpY0Fycikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmx5cmljQXJyW3RoaXMuY3VycmVudEx5cmljSW5kZXggKyAxXVswXSA8PSB0aGlzLmF1ZGlvRWwuY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZVRvTmV4dEx5cmljKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZVRvTmV4dEx5cmljKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgLy8gQ2hhbmdlIHRoZSBvbGQgYWN0aXZlIGx5cmljIHRvIHZpc2l0ZWRcbiAgICAgICAgKF9hID0gdGhpcy5seXJpY1NwYW5zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbdGhpcy5jdXJyZW50THlyaWNJbmRleF0uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgKF9iID0gdGhpcy5seXJpY1NwYW5zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbdGhpcy5jdXJyZW50THlyaWNJbmRleF0uY2xhc3NMaXN0LmFkZChcInZpc2l0ZWRcIik7XG4gICAgICAgIHRoaXMuY3VycmVudEx5cmljSW5kZXgrKztcbiAgICAgICAgY29uc3QgbmV4dEx5cmljID0gKF9jID0gdGhpcy5seXJpY1NwYW5zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbdGhpcy5jdXJyZW50THlyaWNJbmRleF07XG4gICAgICAgIGlmIChuZXh0THlyaWMpIHtcbiAgICAgICAgICAgIG5leHRMeXJpYy5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiBcImNlbnRlclwiLCBiZWhhdmlvcjogXCJzbW9vdGhcIiB9KTtcbiAgICAgICAgICAgIG5leHRMeXJpYy5jbGFzc0xpc3QucmVtb3ZlKFwidW52aXNpdGVkXCIpO1xuICAgICAgICAgICAgbmV4dEx5cmljLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUHJvZ3Jlc3MoKSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NFbC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcHJvZ3Jlc3NcIiwgYCR7KHRoaXMuYXVkaW9FbC5jdXJyZW50VGltZSAvIHRoaXMuYXVkaW9FbC5kdXJhdGlvbikgKiAxMDB9JWApO1xuICAgICAgICBpZiAodGhpcy5hdWRpb0VsLmN1cnJlbnRUaW1lID49IHRoaXMuYXVkaW9FbC5kdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wYXVzZVBsYXlCdG5FbC5jbGFzc0xpc3QucmVtb3ZlKFwicGxheWluZ1wiKTtcbiAgICAgICAgICAgIHRoaXMucGF1c2VQbGF5QnRuRWwuY2xhc3NMaXN0LmFkZChcInBhdXNlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0UHJvZ3Jlc3NFdmVudHMoKSB7XG4gICAgICAgIC8vIEFkZCBkcmFnIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnByb2dyZXNzRWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWVrKGUpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVTZWVrRm4pO1xuICAgICAgICB9KTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuaGFuZGxlU2Vla0ZuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NFbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVTZWVrRm4pO1xuICAgIH1cbiAgICBpbml0THlyaWNFdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5seXJpY0Fycikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGx5cmljc0NvbnRlbnRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubHlyaWNzLWNhcmRfX2NvbnRlbnRcIik7XG4gICAgICAgIGZvciAoY29uc3QgW3RpbWVTdGFtcCwgbHlyaWNdIG9mIHRoaXMubHlyaWNBcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LmFkZChcImx5cmljcy1jYXJkX19jb250ZW50X19seXJpY1wiKTtcbiAgICAgICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBgJHtseXJpY31gO1xuICAgICAgICAgICAgc3Bhbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbC5jdXJyZW50VGltZSA9IHRpbWVTdGFtcDtcbiAgICAgICAgICAgICAgICB0aGlzLmhhcmRVcGRhdGVMeXJpY0NsYXNzZXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbHlyaWNzQ29udGVudEVsLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubHlyaWNTcGFucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIubHlyaWNzLWNhcmRfX2NvbnRlbnRfX2x5cmljXCIpO1xuICAgIH1cbiAgICBoYW5kbGVTZWVrKGUpIHtcbiAgICAgICAgY29uc3QgeyBjbGllbnRYIH0gPSBlO1xuICAgICAgICBjb25zdCB7IGxlZnQsIHdpZHRoIH0gPSB0aGlzLnByb2dyZXNzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSAoY2xpZW50WCAtIGxlZnQpIC8gd2lkdGg7XG4gICAgICAgIHRoaXMuYXVkaW9FbC5jdXJyZW50VGltZSA9IHRoaXMuYXVkaW9FbC5kdXJhdGlvbiAqIHBlcmNlbnRhZ2U7XG4gICAgICAgIHRoaXMuaGFyZFVwZGF0ZUx5cmljQ2xhc3NlcygpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmF1ZGlvRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRpbWV1cGRhdGVcIiwgdGhpcy51cGRhdGVQcm9ncmVzc0ZuKTtcbiAgICAgICAgdGhpcy5hdWRpb0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0aW1ldXBkYXRlXCIsIHRoaXMudXBkYXRlTHlyaWNDbGFzc2VzRm4pO1xuICAgICAgICB0aGlzLmF1ZGlvRWwuc3JjID0gXCJcIjtcbiAgICB9XG59XG5leHBvcnRzLk11c2ljUGxheWVyID0gTXVzaWNQbGF5ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///92\n')},819:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nvar _a;\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst base64_1 = __webpack_require__(741);\n__webpack_require__(702);\nconst jsmediatags_js_1 = __importDefault(__webpack_require__(907));\nconst MusicPlayer_1 = __webpack_require__(92);\nfunction jsMediaTags(file) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield new Promise((resolve, reject) => {\n            // @ts-ignore\n            jsmediatags_js_1.default.read(file, {\n                onSuccess: function (tag) {\n                    resolve(tag);\n                },\n                onError: function (error) {\n                    reject(error);\n                },\n            });\n        });\n    });\n}\nfunction showElement(el) {\n    el.classList.remove("hidden");\n}\nfunction hideElement(el) {\n    el.classList.add("hidden");\n}\nfunction compareLyrics(a, b) {\n    return a.replace(/\\[|\\]|\\./g, "").localeCompare(b.replace(/\\[|\\]|\\./g, ""));\n}\nfunction updateLyricClasses(timestamp) { }\nfunction processLyrics(lyrics) {\n    const lines = lyrics.split("\\n");\n    return lines.reduce((acc, line) => {\n        var _a;\n        const timeStamp = (_a = line.match(/\\[(\\d|\\.|:)+\\]/g)) === null || _a === void 0 ? void 0 : _a[0]; // Of the form [00:00.00]\n        // Convert the timestamp to seconds\n        if (!timeStamp) {\n            return acc;\n        }\n        const timeStampSeconds = timeStamp\n            .replace(/\\[|\\]/g, "")\n            .split(":")\n            .reduce((acc, time, i) => {\n            return acc + parseFloat(time) * Math.pow(60, 1 - i);\n        }, 0);\n        const lyric = line.replace(timeStamp, "").trim();\n        return Object.assign(Object.assign({}, acc), { [timeStampSeconds]: lyric });\n    }, { 0: "♪" });\n}\nconst inpCard = document.getElementById("inp-card");\n(_a = inpCard.querySelector("button")) === null || _a === void 0 ? void 0 : _a.addEventListener("click", handleMusicSubmit);\nconst lyricsCard = document.getElementById("lyrics-card");\nconst mainEl = document.querySelector("main");\nfunction mainLoop() {\n    // Show the input card first and then the lyrics card\n    showElement(inpCard);\n}\nfunction handleMusicSubmit() {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n        const inpEl = mainEl.querySelector("input");\n        // Get the file from the input element\n        const file = (_a = inpEl.files) === null || _a === void 0 ? void 0 : _a[0];\n        if (!file) {\n            alert("Please select a file first!");\n            return;\n        }\n        // Read the file\n        const { tags } = (yield jsMediaTags(file));\n        const lyrics = (_b = tags.lyrics) === null || _b === void 0 ? void 0 : _b.lyrics;\n        const albumArt = (_c = tags.picture) === null || _c === void 0 ? void 0 : _c.data;\n        const bgEl = lyricsCard;\n        if (albumArt) {\n            const base64String = (0, base64_1.base64ArrayBuffer)(new Uint8Array(albumArt).buffer);\n            console.log({ base64String });\n            bgEl.style.backgroundImage = `url(\'data:image/png;base64,${base64String}\')`;\n        }\n        else {\n            bgEl.style.backgroundImage = "none";\n        }\n        const lyricsContentEl = lyricsCard.querySelector(".lyrics-card__content");\n        if (!lyricsContentEl) {\n            throw new Error("Lyrics content element not found!");\n        }\n        lyricsContentEl.innerHTML = "";\n        if (lyrics) {\n            const processedLyrics = processLyrics(lyrics);\n            const sortedLyrics = Object.entries(processedLyrics).map(([timeStamp, lyric]) => [parseInt(timeStamp), lyric]);\n            sortedLyrics.sort(([a], [b]) => {\n                return a - b;\n            });\n            const musicPlayer = new MusicPlayer_1.MusicPlayer(file, sortedLyrics);\n            musicPlayer.play();\n        }\n        else {\n            const musicPlayer = new MusicPlayer_1.MusicPlayer(file);\n            musicPlayer.play();\n            lyricsContentEl.innerHTML = "No lyrics found!";\n        }\n        hideElement(inpCard);\n        showElement(lyricsCard);\n    });\n}\nmainLoop();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsR0FBZ0I7QUFDekMsbUJBQU8sQ0FBQyxHQUFzQjtBQUM5Qix5Q0FBeUMsbUJBQU8sQ0FBQyxHQUE4QjtBQUMvRSxzQkFBc0IsbUJBQU8sQ0FBQyxFQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZDQUE2QyxVQUFVLDJCQUEyQjtBQUNsRixLQUFLLElBQUksUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDLDhEQUE4RCxTQUFTLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFjay1iYWJlbC10ZW1wbGF0ZS8uL3NyYy9wYWdlcy95dC1tdXNpYy1seXJpY3Mvc2NyaXB0cy9pbmRleC50cz9iYjMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBiYXNlNjRfMSA9IHJlcXVpcmUoXCJAL3V0aWxzL2Jhc2U2NFwiKTtcbnJlcXVpcmUoXCIuLi9zdHlsZXMvaW5kZXguc2Nzc1wiKTtcbmNvbnN0IGpzbWVkaWF0YWdzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vanNtZWRpYXRhZ3MvanNtZWRpYXRhZ3MuanNcIikpO1xuY29uc3QgTXVzaWNQbGF5ZXJfMSA9IHJlcXVpcmUoXCIuL011c2ljUGxheWVyXCIpO1xuZnVuY3Rpb24ganNNZWRpYVRhZ3MoZmlsZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBqc21lZGlhdGFnc19qc18xLmRlZmF1bHQucmVhZChmaWxlLCB7XG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGFnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzaG93RWxlbWVudChlbCkge1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG59XG5mdW5jdGlvbiBoaWRlRWxlbWVudChlbCkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG59XG5mdW5jdGlvbiBjb21wYXJlTHlyaWNzKGEsIGIpIHtcbiAgICByZXR1cm4gYS5yZXBsYWNlKC9cXFt8XFxdfFxcLi9nLCBcIlwiKS5sb2NhbGVDb21wYXJlKGIucmVwbGFjZSgvXFxbfFxcXXxcXC4vZywgXCJcIikpO1xufVxuZnVuY3Rpb24gdXBkYXRlTHlyaWNDbGFzc2VzKHRpbWVzdGFtcCkgeyB9XG5mdW5jdGlvbiBwcm9jZXNzTHlyaWNzKGx5cmljcykge1xuICAgIGNvbnN0IGxpbmVzID0gbHlyaWNzLnNwbGl0KFwiXFxuXCIpO1xuICAgIHJldHVybiBsaW5lcy5yZWR1Y2UoKGFjYywgbGluZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcCA9IChfYSA9IGxpbmUubWF0Y2goL1xcWyhcXGR8XFwufDopK1xcXS9nKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdOyAvLyBPZiB0aGUgZm9ybSBbMDA6MDAuMDBdXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHRpbWVzdGFtcCB0byBzZWNvbmRzXG4gICAgICAgIGlmICghdGltZVN0YW1wKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcFNlY29uZHMgPSB0aW1lU3RhbXBcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFt8XFxdL2csIFwiXCIpXG4gICAgICAgICAgICAuc3BsaXQoXCI6XCIpXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIHRpbWUsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhY2MgKyBwYXJzZUZsb2F0KHRpbWUpICogTWF0aC5wb3coNjAsIDEgLSBpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGNvbnN0IGx5cmljID0gbGluZS5yZXBsYWNlKHRpbWVTdGFtcCwgXCJcIikudHJpbSgpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFt0aW1lU3RhbXBTZWNvbmRzXTogbHlyaWMgfSk7XG4gICAgfSwgeyAwOiBcIuKZqlwiIH0pO1xufVxuY29uc3QgaW5wQ2FyZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wLWNhcmRcIik7XG4oX2EgPSBpbnBDYXJkLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b25cIikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlTXVzaWNTdWJtaXQpO1xuY29uc3QgbHlyaWNzQ2FyZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibHlyaWNzLWNhcmRcIik7XG5jb25zdCBtYWluRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWFpblwiKTtcbmZ1bmN0aW9uIG1haW5Mb29wKCkge1xuICAgIC8vIFNob3cgdGhlIGlucHV0IGNhcmQgZmlyc3QgYW5kIHRoZW4gdGhlIGx5cmljcyBjYXJkXG4gICAgc2hvd0VsZW1lbnQoaW5wQ2FyZCk7XG59XG5mdW5jdGlvbiBoYW5kbGVNdXNpY1N1Ym1pdCgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBpbnBFbCA9IG1haW5FbC5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIik7XG4gICAgICAgIC8vIEdldCB0aGUgZmlsZSBmcm9tIHRoZSBpbnB1dCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGZpbGUgPSAoX2EgPSBpbnBFbC5maWxlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiUGxlYXNlIHNlbGVjdCBhIGZpbGUgZmlyc3QhXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlYWQgdGhlIGZpbGVcbiAgICAgICAgY29uc3QgeyB0YWdzIH0gPSAoeWllbGQganNNZWRpYVRhZ3MoZmlsZSkpO1xuICAgICAgICBjb25zdCBseXJpY3MgPSAoX2IgPSB0YWdzLmx5cmljcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmx5cmljcztcbiAgICAgICAgY29uc3QgYWxidW1BcnQgPSAoX2MgPSB0YWdzLnBpY3R1cmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kYXRhO1xuICAgICAgICBjb25zdCBiZ0VsID0gbHlyaWNzQ2FyZDtcbiAgICAgICAgaWYgKGFsYnVtQXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSAoMCwgYmFzZTY0XzEuYmFzZTY0QXJyYXlCdWZmZXIpKG5ldyBVaW50OEFycmF5KGFsYnVtQXJ0KS5idWZmZXIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coeyBiYXNlNjRTdHJpbmcgfSk7XG4gICAgICAgICAgICBiZ0VsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwke2Jhc2U2NFN0cmluZ30nKWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiZ0VsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGx5cmljc0NvbnRlbnRFbCA9IGx5cmljc0NhcmQucXVlcnlTZWxlY3RvcihcIi5seXJpY3MtY2FyZF9fY29udGVudFwiKTtcbiAgICAgICAgaWYgKCFseXJpY3NDb250ZW50RWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkx5cmljcyBjb250ZW50IGVsZW1lbnQgbm90IGZvdW5kIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBseXJpY3NDb250ZW50RWwuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgaWYgKGx5cmljcykge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkTHlyaWNzID0gcHJvY2Vzc0x5cmljcyhseXJpY3MpO1xuICAgICAgICAgICAgY29uc3Qgc29ydGVkTHlyaWNzID0gT2JqZWN0LmVudHJpZXMocHJvY2Vzc2VkTHlyaWNzKS5tYXAoKFt0aW1lU3RhbXAsIGx5cmljXSkgPT4gW3BhcnNlSW50KHRpbWVTdGFtcCksIGx5cmljXSk7XG4gICAgICAgICAgICBzb3J0ZWRMeXJpY3Muc29ydCgoW2FdLCBbYl0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG11c2ljUGxheWVyID0gbmV3IE11c2ljUGxheWVyXzEuTXVzaWNQbGF5ZXIoZmlsZSwgc29ydGVkTHlyaWNzKTtcbiAgICAgICAgICAgIG11c2ljUGxheWVyLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG11c2ljUGxheWVyID0gbmV3IE11c2ljUGxheWVyXzEuTXVzaWNQbGF5ZXIoZmlsZSk7XG4gICAgICAgICAgICBtdXNpY1BsYXllci5wbGF5KCk7XG4gICAgICAgICAgICBseXJpY3NDb250ZW50RWwuaW5uZXJIVE1MID0gXCJObyBseXJpY3MgZm91bmQhXCI7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZUVsZW1lbnQoaW5wQ2FyZCk7XG4gICAgICAgIHNob3dFbGVtZW50KGx5cmljc0NhcmQpO1xuICAgIH0pO1xufVxubWFpbkxvb3AoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///819\n')},741:(__unused_webpack_module,exports)=>{"use strict";eval('\n// Converts an ArrayBuffer directly to base64, without any intermediate \'convert to string then\n// use window.btoa\' step. According to my tests, this appears to be a faster approach:\n// http://jsperf.com/encoding-xhr-image-data/5\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.base64ArrayBuffer = void 0;\n/*\nMIT LICENSE\n\nCopyright 2011 Jon Leighton\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nfunction base64ArrayBuffer(arrayBuffer) {\n    var base64 = "";\n    var encodings = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\n    var bytes = new Uint8Array(arrayBuffer);\n    var byteLength = bytes.byteLength;\n    var byteRemainder = byteLength % 3;\n    var mainLength = byteLength - byteRemainder;\n    var a, b, c, d;\n    var chunk;\n    // Main loop deals with bytes in chunks of 3\n    for (var i = 0; i < mainLength; i = i + 3) {\n        // Combine the three bytes into a single integer\n        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        // Use bitmasks to extract 6-bit segments from the triplet\n        a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n        b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n        c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n        d = chunk & 63; // 63       = 2^6 - 1\n        // Convert the raw binary segments to the appropriate ASCII encoding\n        base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n    }\n    // Deal with the remaining bytes and padding\n    if (byteRemainder == 1) {\n        chunk = bytes[mainLength];\n        a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n        // Set the 4 least significant bits to zero\n        b = (chunk & 3) << 4; // 3   = 2^2 - 1\n        base64 += encodings[a] + encodings[b] + "==";\n    }\n    else if (byteRemainder == 2) {\n        chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\n        a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n        b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n        // Set the 2 least significant bits to zero\n        c = (chunk & 15) << 2; // 15    = 2^4 - 1\n        base64 += encodings[a] + encodings[b] + encodings[c] + "=";\n    }\n    return base64;\n}\nexports.base64ArrayBuffer = base64ArrayBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQxLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQyxpQ0FBaUM7QUFDakMsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQ0FBaUM7QUFDakM7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrLWJhYmVsLXRlbXBsYXRlLy4vc3JjL3V0aWxzL2Jhc2U2NC50cz8xNzRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29udmVydHMgYW4gQXJyYXlCdWZmZXIgZGlyZWN0bHkgdG8gYmFzZTY0LCB3aXRob3V0IGFueSBpbnRlcm1lZGlhdGUgJ2NvbnZlcnQgdG8gc3RyaW5nIHRoZW5cbi8vIHVzZSB3aW5kb3cuYnRvYScgc3RlcC4gQWNjb3JkaW5nIHRvIG15IHRlc3RzLCB0aGlzIGFwcGVhcnMgdG8gYmUgYSBmYXN0ZXIgYXBwcm9hY2g6XG4vLyBodHRwOi8vanNwZXJmLmNvbS9lbmNvZGluZy14aHItaW1hZ2UtZGF0YS81XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJhc2U2NEFycmF5QnVmZmVyID0gdm9pZCAwO1xuLypcbk1JVCBMSUNFTlNFXG5cbkNvcHlyaWdodCAyMDExIEpvbiBMZWlnaHRvblxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuZnVuY3Rpb24gYmFzZTY0QXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgYmFzZTY0ID0gXCJcIjtcbiAgICB2YXIgZW5jb2RpbmdzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgIHZhciBieXRlTGVuZ3RoID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICB2YXIgYnl0ZVJlbWFpbmRlciA9IGJ5dGVMZW5ndGggJSAzO1xuICAgIHZhciBtYWluTGVuZ3RoID0gYnl0ZUxlbmd0aCAtIGJ5dGVSZW1haW5kZXI7XG4gICAgdmFyIGEsIGIsIGMsIGQ7XG4gICAgdmFyIGNodW5rO1xuICAgIC8vIE1haW4gbG9vcCBkZWFscyB3aXRoIGJ5dGVzIGluIGNodW5rcyBvZiAzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYWluTGVuZ3RoOyBpID0gaSArIDMpIHtcbiAgICAgICAgLy8gQ29tYmluZSB0aGUgdGhyZWUgYnl0ZXMgaW50byBhIHNpbmdsZSBpbnRlZ2VyXG4gICAgICAgIGNodW5rID0gKGJ5dGVzW2ldIDw8IDE2KSB8IChieXRlc1tpICsgMV0gPDwgOCkgfCBieXRlc1tpICsgMl07XG4gICAgICAgIC8vIFVzZSBiaXRtYXNrcyB0byBleHRyYWN0IDYtYml0IHNlZ21lbnRzIGZyb20gdGhlIHRyaXBsZXRcbiAgICAgICAgYSA9IChjaHVuayAmIDE2NTE1MDcyKSA+PiAxODsgLy8gMTY1MTUwNzIgPSAoMl42IC0gMSkgPDwgMThcbiAgICAgICAgYiA9IChjaHVuayAmIDI1ODA0OCkgPj4gMTI7IC8vIDI1ODA0OCAgID0gKDJeNiAtIDEpIDw8IDEyXG4gICAgICAgIGMgPSAoY2h1bmsgJiA0MDMyKSA+PiA2OyAvLyA0MDMyICAgICA9ICgyXjYgLSAxKSA8PCA2XG4gICAgICAgIGQgPSBjaHVuayAmIDYzOyAvLyA2MyAgICAgICA9IDJeNiAtIDFcbiAgICAgICAgLy8gQ29udmVydCB0aGUgcmF3IGJpbmFyeSBzZWdtZW50cyB0byB0aGUgYXBwcm9wcmlhdGUgQVNDSUkgZW5jb2RpbmdcbiAgICAgICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIGVuY29kaW5nc1tjXSArIGVuY29kaW5nc1tkXTtcbiAgICB9XG4gICAgLy8gRGVhbCB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMgYW5kIHBhZGRpbmdcbiAgICBpZiAoYnl0ZVJlbWFpbmRlciA9PSAxKSB7XG4gICAgICAgIGNodW5rID0gYnl0ZXNbbWFpbkxlbmd0aF07XG4gICAgICAgIGEgPSAoY2h1bmsgJiAyNTIpID4+IDI7IC8vIDI1MiA9ICgyXjYgLSAxKSA8PCAyXG4gICAgICAgIC8vIFNldCB0aGUgNCBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHRvIHplcm9cbiAgICAgICAgYiA9IChjaHVuayAmIDMpIDw8IDQ7IC8vIDMgICA9IDJeMiAtIDFcbiAgICAgICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIFwiPT1cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnl0ZVJlbWFpbmRlciA9PSAyKSB7XG4gICAgICAgIGNodW5rID0gKGJ5dGVzW21haW5MZW5ndGhdIDw8IDgpIHwgYnl0ZXNbbWFpbkxlbmd0aCArIDFdO1xuICAgICAgICBhID0gKGNodW5rICYgNjQ1MTIpID4+IDEwOyAvLyA2NDUxMiA9ICgyXjYgLSAxKSA8PCAxMFxuICAgICAgICBiID0gKGNodW5rICYgMTAwOCkgPj4gNDsgLy8gMTAwOCAgPSAoMl42IC0gMSkgPDwgNFxuICAgICAgICAvLyBTZXQgdGhlIDIgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyB0byB6ZXJvXG4gICAgICAgIGMgPSAoY2h1bmsgJiAxNSkgPDwgMjsgLy8gMTUgICAgPSAyXjQgLSAxXG4gICAgICAgIGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyBlbmNvZGluZ3NbY10gKyBcIj1cIjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbn1cbmV4cG9ydHMuYmFzZTY0QXJyYXlCdWZmZXIgPSBiYXNlNjRBcnJheUJ1ZmZlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///741\n')},907:module=>{eval('// @ts-nocheck\r\n(function (f) {\r\n  if (true) {\r\n    module.exports = f();\r\n  } else { var g; }\r\n})(function () {\r\n  var define, module, exports;\r\n  return (function () {\r\n    function r(e, n, t) {\r\n      function o(i, f) {\r\n        if (!n[i]) {\r\n          if (!e[i]) {\r\n            var c = undefined;\r\n            if (!f && c) return require(i, !0);\r\n            if (u) return u(i, !0);\r\n            var a = new Error("Cannot find module \'" + i + "\'");\r\n            throw ((a.code = "MODULE_NOT_FOUND"), a);\r\n          }\r\n          var p = (n[i] = { exports: {} });\r\n          e[i][0].call(\r\n            p.exports,\r\n            function (r) {\r\n              var n = e[i][1][r];\r\n              return o(n || r);\r\n            },\r\n            p,\r\n            p.exports,\r\n            r,\r\n            e,\r\n            n,\r\n            t\r\n          );\r\n        }\r\n        return n[i].exports;\r\n      }\r\n      for (\r\n        var u = undefined, i = 0;\r\n        i < t.length;\r\n        i++\r\n      )\r\n        o(t[i]);\r\n      return o;\r\n    }\r\n    return r;\r\n  })()(\r\n    {\r\n      1: [function (require, module, exports) {}, {}],\r\n      2: [\r\n        function (require, module, exports) {\r\n          module.exports = XMLHttpRequest;\r\n        },\r\n        {},\r\n      ],\r\n      3: [\r\n        function (require, module, exports) {\r\n          "use strict";\r\n\r\n          function _typeof(obj) {\r\n            "@babel/helpers - typeof";\r\n            if (\r\n              typeof Symbol === "function" &&\r\n              typeof Symbol.iterator === "symbol"\r\n            ) {\r\n              _typeof = function _typeof(obj) {\r\n                return typeof obj;\r\n              };\r\n            } else {\r\n              _typeof = function _typeof(obj) {\r\n                return obj &&\r\n                  typeof Symbol === "function" &&\r\n                  obj.constructor === Symbol &&\r\n                  obj !== Symbol.prototype\r\n                  ? "symbol"\r\n                  : typeof obj;\r\n              };\r\n            }\r\n            return _typeof(obj);\r\n          }\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _inherits(subClass, superClass) {\r\n            if (typeof superClass !== "function" && superClass !== null) {\r\n              throw new TypeError(\r\n                "Super expression must either be null or a function"\r\n              );\r\n            }\r\n            subClass.prototype = Object.create(\r\n              superClass && superClass.prototype,\r\n              {\r\n                constructor: {\r\n                  value: subClass,\r\n                  writable: true,\r\n                  configurable: true,\r\n                },\r\n              }\r\n            );\r\n            if (superClass) _setPrototypeOf(subClass, superClass);\r\n          }\r\n\r\n          function _setPrototypeOf(o, p) {\r\n            _setPrototypeOf =\r\n              Object.setPrototypeOf ||\r\n              function _setPrototypeOf(o, p) {\r\n                o.__proto__ = p;\r\n                return o;\r\n              };\r\n            return _setPrototypeOf(o, p);\r\n          }\r\n\r\n          function _createSuper(Derived) {\r\n            var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n            return function _createSuperInternal() {\r\n              var Super = _getPrototypeOf(Derived),\r\n                result;\r\n              if (hasNativeReflectConstruct) {\r\n                var NewTarget = _getPrototypeOf(this).constructor;\r\n                result = Reflect.construct(Super, arguments, NewTarget);\r\n              } else {\r\n                result = Super.apply(this, arguments);\r\n              }\r\n              return _possibleConstructorReturn(this, result);\r\n            };\r\n          }\r\n\r\n          function _possibleConstructorReturn(self, call) {\r\n            if (\r\n              call &&\r\n              (_typeof(call) === "object" || typeof call === "function")\r\n            ) {\r\n              return call;\r\n            }\r\n            return _assertThisInitialized(self);\r\n          }\r\n\r\n          function _assertThisInitialized(self) {\r\n            if (self === void 0) {\r\n              throw new ReferenceError(\r\n                "this hasn\'t been initialised - super() hasn\'t been called"\r\n              );\r\n            }\r\n            return self;\r\n          }\r\n\r\n          function _isNativeReflectConstruct() {\r\n            if (typeof Reflect === "undefined" || !Reflect.construct)\r\n              return false;\r\n            if (Reflect.construct.sham) return false;\r\n            if (typeof Proxy === "function") return true;\r\n            try {\r\n              Boolean.prototype.valueOf.call(\r\n                Reflect.construct(Boolean, [], function () {})\r\n              );\r\n              return true;\r\n            } catch (e) {\r\n              return false;\r\n            }\r\n          }\r\n\r\n          function _getPrototypeOf(o) {\r\n            _getPrototypeOf = Object.setPrototypeOf\r\n              ? Object.getPrototypeOf\r\n              : function _getPrototypeOf(o) {\r\n                  return o.__proto__ || Object.getPrototypeOf(o);\r\n                };\r\n            return _getPrototypeOf(o);\r\n          }\r\n\r\n          function _defineProperty(obj, key, value) {\r\n            if (key in obj) {\r\n              Object.defineProperty(obj, key, {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true,\r\n              });\r\n            } else {\r\n              obj[key] = value;\r\n            }\r\n            return obj;\r\n          }\r\n\r\n          var MediaFileReader = require("./MediaFileReader");\r\n\r\n          var ArrayFileReader = /*#__PURE__*/ (function (_MediaFileReader) {\r\n            _inherits(ArrayFileReader, _MediaFileReader);\r\n\r\n            var _super = _createSuper(ArrayFileReader);\r\n\r\n            function ArrayFileReader(array) {\r\n              var _this;\r\n\r\n              _classCallCheck(this, ArrayFileReader);\r\n\r\n              _this = _super.call(this);\r\n\r\n              _defineProperty(_assertThisInitialized(_this), "_array", void 0);\r\n\r\n              _defineProperty(_assertThisInitialized(_this), "_size", void 0);\r\n\r\n              _this._array = array;\r\n              _this._size = array.length;\r\n              _this._isInitialized = true;\r\n              return _this;\r\n            }\r\n\r\n            _createClass(\r\n              ArrayFileReader,\r\n              [\r\n                {\r\n                  key: "init",\r\n                  value: function init(callbacks) {\r\n                    setTimeout(callbacks.onSuccess, 0);\r\n                  },\r\n                },\r\n                {\r\n                  key: "loadRange",\r\n                  value: function loadRange(range, callbacks) {\r\n                    setTimeout(callbacks.onSuccess, 0);\r\n                  },\r\n                },\r\n                {\r\n                  key: "getByteAt",\r\n                  value: function getByteAt(offset) {\r\n                    if (offset >= this._array.length) {\r\n                      throw new Error(\r\n                        "Offset " + offset + " hasn\'t been loaded yet."\r\n                      );\r\n                    }\r\n\r\n                    return this._array[offset];\r\n                  },\r\n                },\r\n              ],\r\n              [\r\n                {\r\n                  key: "canReadFile",\r\n                  value: function canReadFile(file) {\r\n                    return (\r\n                      Array.isArray(file) ||\r\n                      (typeof Buffer === "function" && Buffer.isBuffer(file))\r\n                    );\r\n                  },\r\n                },\r\n              ]\r\n            );\r\n\r\n            return ArrayFileReader;\r\n          })(MediaFileReader);\r\n\r\n          module.exports = ArrayFileReader;\r\n        },\r\n        { "./MediaFileReader": 11 },\r\n      ],\r\n      4: [\r\n        function (require, module, exports) {\r\n          "use strict";\r\n\r\n          function _typeof(obj) {\r\n            "@babel/helpers - typeof";\r\n            if (\r\n              typeof Symbol === "function" &&\r\n              typeof Symbol.iterator === "symbol"\r\n            ) {\r\n              _typeof = function _typeof(obj) {\r\n                return typeof obj;\r\n              };\r\n            } else {\r\n              _typeof = function _typeof(obj) {\r\n                return obj &&\r\n                  typeof Symbol === "function" &&\r\n                  obj.constructor === Symbol &&\r\n                  obj !== Symbol.prototype\r\n                  ? "symbol"\r\n                  : typeof obj;\r\n              };\r\n            }\r\n            return _typeof(obj);\r\n          }\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _inherits(subClass, superClass) {\r\n            if (typeof superClass !== "function" && superClass !== null) {\r\n              throw new TypeError(\r\n                "Super expression must either be null or a function"\r\n              );\r\n            }\r\n            subClass.prototype = Object.create(\r\n              superClass && superClass.prototype,\r\n              {\r\n                constructor: {\r\n                  value: subClass,\r\n                  writable: true,\r\n                  configurable: true,\r\n                },\r\n              }\r\n            );\r\n            if (superClass) _setPrototypeOf(subClass, superClass);\r\n          }\r\n\r\n          function _setPrototypeOf(o, p) {\r\n            _setPrototypeOf =\r\n              Object.setPrototypeOf ||\r\n              function _setPrototypeOf(o, p) {\r\n                o.__proto__ = p;\r\n                return o;\r\n              };\r\n            return _setPrototypeOf(o, p);\r\n          }\r\n\r\n          function _createSuper(Derived) {\r\n            var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n            return function _createSuperInternal() {\r\n              var Super = _getPrototypeOf(Derived),\r\n                result;\r\n              if (hasNativeReflectConstruct) {\r\n                var NewTarget = _getPrototypeOf(this).constructor;\r\n                result = Reflect.construct(Super, arguments, NewTarget);\r\n              } else {\r\n                result = Super.apply(this, arguments);\r\n              }\r\n              return _possibleConstructorReturn(this, result);\r\n            };\r\n          }\r\n\r\n          function _possibleConstructorReturn(self, call) {\r\n            if (\r\n              call &&\r\n              (_typeof(call) === "object" || typeof call === "function")\r\n            ) {\r\n              return call;\r\n            }\r\n            return _assertThisInitialized(self);\r\n          }\r\n\r\n          function _assertThisInitialized(self) {\r\n            if (self === void 0) {\r\n              throw new ReferenceError(\r\n                "this hasn\'t been initialised - super() hasn\'t been called"\r\n              );\r\n            }\r\n            return self;\r\n          }\r\n\r\n          function _isNativeReflectConstruct() {\r\n            if (typeof Reflect === "undefined" || !Reflect.construct)\r\n              return false;\r\n            if (Reflect.construct.sham) return false;\r\n            if (typeof Proxy === "function") return true;\r\n            try {\r\n              Boolean.prototype.valueOf.call(\r\n                Reflect.construct(Boolean, [], function () {})\r\n              );\r\n              return true;\r\n            } catch (e) {\r\n              return false;\r\n            }\r\n          }\r\n\r\n          function _getPrototypeOf(o) {\r\n            _getPrototypeOf = Object.setPrototypeOf\r\n              ? Object.getPrototypeOf\r\n              : function _getPrototypeOf(o) {\r\n                  return o.__proto__ || Object.getPrototypeOf(o);\r\n                };\r\n            return _getPrototypeOf(o);\r\n          }\r\n\r\n          function _defineProperty(obj, key, value) {\r\n            if (key in obj) {\r\n              Object.defineProperty(obj, key, {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true,\r\n              });\r\n            } else {\r\n              obj[key] = value;\r\n            }\r\n            return obj;\r\n          }\r\n\r\n          var ChunkedFileData = require("./ChunkedFileData");\r\n\r\n          var MediaFileReader = require("./MediaFileReader");\r\n\r\n          var BlobFileReader = /*#__PURE__*/ (function (_MediaFileReader) {\r\n            _inherits(BlobFileReader, _MediaFileReader);\r\n\r\n            var _super = _createSuper(BlobFileReader);\r\n\r\n            function BlobFileReader(blob) {\r\n              var _this;\r\n\r\n              _classCallCheck(this, BlobFileReader);\r\n\r\n              _this = _super.call(this);\r\n\r\n              _defineProperty(_assertThisInitialized(_this), "_blob", void 0);\r\n\r\n              _defineProperty(\r\n                _assertThisInitialized(_this),\r\n                "_fileData",\r\n                void 0\r\n              );\r\n\r\n              _this._blob = blob;\r\n              _this._fileData = new ChunkedFileData();\r\n              return _this;\r\n            }\r\n\r\n            _createClass(\r\n              BlobFileReader,\r\n              [\r\n                {\r\n                  key: "_init",\r\n                  value: function _init(callbacks) {\r\n                    this._size = this._blob.size;\r\n                    setTimeout(callbacks.onSuccess, 1);\r\n                  },\r\n                },\r\n                {\r\n                  key: "loadRange",\r\n                  value: function loadRange(range, callbacks) {\r\n                    var self = this; // $FlowIssue - flow isn\'t aware of mozSlice or webkitSlice\r\n\r\n                    var blobSlice =\r\n                      this._blob.slice ||\r\n                      this._blob.mozSlice ||\r\n                      this._blob.webkitSlice;\r\n                    var blob = blobSlice.call(\r\n                      this._blob,\r\n                      range[0],\r\n                      range[1] + 1\r\n                    );\r\n                    var browserFileReader = new FileReader();\r\n\r\n                    browserFileReader.onloadend = function (event) {\r\n                      var intArray = new Uint8Array(browserFileReader.result);\r\n\r\n                      self._fileData.addData(range[0], intArray);\r\n\r\n                      callbacks.onSuccess();\r\n                    };\r\n\r\n                    browserFileReader.onerror = browserFileReader.onabort =\r\n                      function (event) {\r\n                        if (callbacks.onError) {\r\n                          callbacks.onError({\r\n                            type: "blob",\r\n                            info: browserFileReader.error,\r\n                          });\r\n                        }\r\n                      };\r\n\r\n                    browserFileReader.readAsArrayBuffer(blob);\r\n                  },\r\n                },\r\n                {\r\n                  key: "getByteAt",\r\n                  value: function getByteAt(offset) {\r\n                    return this._fileData.getByteAt(offset);\r\n                  },\r\n                },\r\n              ],\r\n              [\r\n                {\r\n                  key: "canReadFile",\r\n                  value: function canReadFile(file) {\r\n                    return (\r\n                      (typeof Blob !== "undefined" && file instanceof Blob) || // File extends Blob but it seems that File instanceof Blob doesn\'t\r\n                      // quite work as expected in Cordova/PhoneGap.\r\n                      (typeof File !== "undefined" && file instanceof File)\r\n                    );\r\n                  },\r\n                },\r\n              ]\r\n            );\r\n\r\n            return BlobFileReader;\r\n          })(MediaFileReader);\r\n\r\n          module.exports = BlobFileReader;\r\n        },\r\n        { "./ChunkedFileData": 5, "./MediaFileReader": 11 },\r\n      ],\r\n      5: [\r\n        function (require, module, exports) {\r\n          /**\r\n           * This class represents a file that might not have all its data loaded yet.\r\n           * It is used when loading the entire file is not an option because it\'s too\r\n           * expensive. Instead, parts of the file are loaded and added only when needed.\r\n           * From a reading point of view is as if the entire file is loaded. The\r\n           * exception is when the data is not available yet, an error will be thrown.\r\n           * This class does not load the data, it just manages it. It provides operations\r\n           * to add and read data from the file.\r\n           *\r\n           *\r\n           */\r\n          "use strict";\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _defineProperty(obj, key, value) {\r\n            if (key in obj) {\r\n              Object.defineProperty(obj, key, {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true,\r\n              });\r\n            } else {\r\n              obj[key] = value;\r\n            }\r\n            return obj;\r\n          }\r\n\r\n          var NOT_FOUND = -1;\r\n\r\n          var ChunkedFileData = /*#__PURE__*/ (function () {\r\n            function ChunkedFileData() {\r\n              _classCallCheck(this, ChunkedFileData);\r\n\r\n              _defineProperty(this, "_fileData", void 0);\r\n\r\n              this._fileData = [];\r\n            }\r\n            /**\r\n             * Adds data to the file storage at a specific offset.\r\n             */\r\n\r\n            _createClass(\r\n              ChunkedFileData,\r\n              [\r\n                {\r\n                  key: "addData",\r\n                  value: function addData(offset, data) {\r\n                    var offsetEnd = offset + data.length - 1;\r\n\r\n                    var chunkRange = this._getChunkRange(offset, offsetEnd);\r\n\r\n                    if (chunkRange.startIx === NOT_FOUND) {\r\n                      this._fileData.splice(chunkRange.insertIx || 0, 0, {\r\n                        offset: offset,\r\n                        data: data,\r\n                      });\r\n                    } else {\r\n                      // If the data to add collides with existing chunks we prepend and\r\n                      // append data from the half colliding chunks to make the collision at\r\n                      // 100%. The new data can then replace all the colliding chunkes.\r\n                      var firstChunk = this._fileData[chunkRange.startIx];\r\n                      var lastChunk = this._fileData[chunkRange.endIx];\r\n                      var needsPrepend = offset > firstChunk.offset;\r\n                      var needsAppend =\r\n                        offsetEnd <\r\n                        lastChunk.offset + lastChunk.data.length - 1;\r\n                      var chunk = {\r\n                        offset: Math.min(offset, firstChunk.offset),\r\n                        data: data,\r\n                      };\r\n\r\n                      if (needsPrepend) {\r\n                        var slicedData = this._sliceData(\r\n                          firstChunk.data,\r\n                          0,\r\n                          offset - firstChunk.offset\r\n                        );\r\n\r\n                        chunk.data = this._concatData(slicedData, data);\r\n                      }\r\n\r\n                      if (needsAppend) {\r\n                        // Use the lastChunk because the slice logic is easier to handle.\r\n                        var slicedData = this._sliceData(\r\n                          chunk.data,\r\n                          0,\r\n                          lastChunk.offset - chunk.offset\r\n                        );\r\n\r\n                        chunk.data = this._concatData(\r\n                          slicedData,\r\n                          lastChunk.data\r\n                        );\r\n                      }\r\n\r\n                      this._fileData.splice(\r\n                        chunkRange.startIx,\r\n                        chunkRange.endIx - chunkRange.startIx + 1,\r\n                        chunk\r\n                      );\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "_concatData",\r\n                  value: function _concatData(dataA, dataB) {\r\n                    // TypedArrays don\'t support concat.\r\n                    if (\r\n                      typeof ArrayBuffer !== "undefined" &&\r\n                      ArrayBuffer.isView &&\r\n                      ArrayBuffer.isView(dataA)\r\n                    ) {\r\n                      // $FlowIssue - flow thinks dataAandB is a string but it\'s not\r\n                      var dataAandB = new dataA.constructor(\r\n                        dataA.length + dataB.length\r\n                      ); // $FlowIssue - flow thinks dataAandB is a string but it\'s not\r\n\r\n                      dataAandB.set(dataA, 0); // $FlowIssue - flow thinks dataAandB is a string but it\'s not\r\n\r\n                      dataAandB.set(dataB, dataA.length);\r\n                      return dataAandB;\r\n                    } else {\r\n                      // $FlowIssue - flow thinks dataAandB is a TypedArray but it\'s not\r\n                      return dataA.concat(dataB);\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "_sliceData",\r\n                  value: function _sliceData(data, begin, end) {\r\n                    // Some TypeArray implementations do not support slice yet.\r\n                    if (data.slice) {\r\n                      return data.slice(begin, end);\r\n                    } else {\r\n                      // $FlowIssue - flow thinks data is a string but it\'s not\r\n                      return data.subarray(begin, end);\r\n                    }\r\n                  },\r\n                  /**\r\n                   * Finds the chunk range that overlaps the [offsetStart-1,offsetEnd+1] range.\r\n                   * When a chunk is adjacent to the offset we still consider it part of the\r\n                   * range (this is the situation of offsetStart-1 or offsetEnd+1).\r\n                   * When no chunks are found `insertIx` denotes the index where the data\r\n                   * should be inserted in the data list (startIx == NOT_FOUND and endIX ==\r\n                   * NOT_FOUND).\r\n                   */\r\n                },\r\n                {\r\n                  key: "_getChunkRange",\r\n                  value: function _getChunkRange(offsetStart, offsetEnd) {\r\n                    var startChunkIx = NOT_FOUND;\r\n                    var endChunkIx = NOT_FOUND;\r\n                    var insertIx = 0; // Could use binary search but not expecting that many blocks to exist.\r\n\r\n                    for (\r\n                      var i = 0;\r\n                      i < this._fileData.length;\r\n                      i++, insertIx = i\r\n                    ) {\r\n                      var chunkOffsetStart = this._fileData[i].offset;\r\n                      var chunkOffsetEnd =\r\n                        chunkOffsetStart + this._fileData[i].data.length;\r\n\r\n                      if (offsetEnd < chunkOffsetStart - 1) {\r\n                        // This offset range doesn\'t overlap with any chunks.\r\n                        break;\r\n                      } // If it is adjacent we still consider it part of the range because\r\n                      // we\'re going end up with a single block with all contiguous data.\r\n\r\n                      if (\r\n                        offsetStart <= chunkOffsetEnd + 1 &&\r\n                        offsetEnd >= chunkOffsetStart - 1\r\n                      ) {\r\n                        startChunkIx = i;\r\n                        break;\r\n                      }\r\n                    } // No starting chunk was found, meaning that the offset is either before\r\n                    // or after the current stored chunks.\r\n\r\n                    if (startChunkIx === NOT_FOUND) {\r\n                      return {\r\n                        startIx: NOT_FOUND,\r\n                        endIx: NOT_FOUND,\r\n                        insertIx: insertIx,\r\n                      };\r\n                    } // Find the ending chunk.\r\n\r\n                    for (var i = startChunkIx; i < this._fileData.length; i++) {\r\n                      var chunkOffsetStart = this._fileData[i].offset;\r\n                      var chunkOffsetEnd =\r\n                        chunkOffsetStart + this._fileData[i].data.length;\r\n\r\n                      if (offsetEnd >= chunkOffsetStart - 1) {\r\n                        // Candidate for the end chunk, it doesn\'t mean it is yet.\r\n                        endChunkIx = i;\r\n                      }\r\n\r\n                      if (offsetEnd <= chunkOffsetEnd + 1) {\r\n                        break;\r\n                      }\r\n                    }\r\n\r\n                    if (endChunkIx === NOT_FOUND) {\r\n                      endChunkIx = startChunkIx;\r\n                    }\r\n\r\n                    return {\r\n                      startIx: startChunkIx,\r\n                      endIx: endChunkIx,\r\n                    };\r\n                  },\r\n                },\r\n                {\r\n                  key: "hasDataRange",\r\n                  value: function hasDataRange(offsetStart, offsetEnd) {\r\n                    for (var i = 0; i < this._fileData.length; i++) {\r\n                      var chunk = this._fileData[i];\r\n\r\n                      if (offsetEnd < chunk.offset) {\r\n                        return false;\r\n                      }\r\n\r\n                      if (\r\n                        offsetStart >= chunk.offset &&\r\n                        offsetEnd < chunk.offset + chunk.data.length\r\n                      ) {\r\n                        return true;\r\n                      }\r\n                    }\r\n\r\n                    return false;\r\n                  },\r\n                },\r\n                {\r\n                  key: "getByteAt",\r\n                  value: function getByteAt(offset) {\r\n                    var dataChunk;\r\n\r\n                    for (var i = 0; i < this._fileData.length; i++) {\r\n                      var dataChunkStart = this._fileData[i].offset;\r\n                      var dataChunkEnd =\r\n                        dataChunkStart + this._fileData[i].data.length - 1;\r\n\r\n                      if (offset >= dataChunkStart && offset <= dataChunkEnd) {\r\n                        dataChunk = this._fileData[i];\r\n                        break;\r\n                      }\r\n                    }\r\n\r\n                    if (dataChunk) {\r\n                      return dataChunk.data[offset - dataChunk.offset];\r\n                    }\r\n\r\n                    throw new Error(\r\n                      "Offset " + offset + " hasn\'t been loaded yet."\r\n                    );\r\n                  },\r\n                },\r\n              ],\r\n              [\r\n                {\r\n                  key: "NOT_FOUND",\r\n                  // $FlowIssue - get/set properties not yet supported\r\n                  get: function get() {\r\n                    return NOT_FOUND;\r\n                  },\r\n                },\r\n              ]\r\n            );\r\n\r\n            return ChunkedFileData;\r\n          })();\r\n\r\n          module.exports = ChunkedFileData;\r\n        },\r\n        {},\r\n      ],\r\n      6: [\r\n        function (require, module, exports) {\r\n          "use strict";\r\n\r\n          function _typeof(obj) {\r\n            "@babel/helpers - typeof";\r\n            if (\r\n              typeof Symbol === "function" &&\r\n              typeof Symbol.iterator === "symbol"\r\n            ) {\r\n              _typeof = function _typeof(obj) {\r\n                return typeof obj;\r\n              };\r\n            } else {\r\n              _typeof = function _typeof(obj) {\r\n                return obj &&\r\n                  typeof Symbol === "function" &&\r\n                  obj.constructor === Symbol &&\r\n                  obj !== Symbol.prototype\r\n                  ? "symbol"\r\n                  : typeof obj;\r\n              };\r\n            }\r\n            return _typeof(obj);\r\n          }\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _inherits(subClass, superClass) {\r\n            if (typeof superClass !== "function" && superClass !== null) {\r\n              throw new TypeError(\r\n                "Super expression must either be null or a function"\r\n              );\r\n            }\r\n            subClass.prototype = Object.create(\r\n              superClass && superClass.prototype,\r\n              {\r\n                constructor: {\r\n                  value: subClass,\r\n                  writable: true,\r\n                  configurable: true,\r\n                },\r\n              }\r\n            );\r\n            if (superClass) _setPrototypeOf(subClass, superClass);\r\n          }\r\n\r\n          function _setPrototypeOf(o, p) {\r\n            _setPrototypeOf =\r\n              Object.setPrototypeOf ||\r\n              function _setPrototypeOf(o, p) {\r\n                o.__proto__ = p;\r\n                return o;\r\n              };\r\n            return _setPrototypeOf(o, p);\r\n          }\r\n\r\n          function _createSuper(Derived) {\r\n            var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n            return function _createSuperInternal() {\r\n              var Super = _getPrototypeOf(Derived),\r\n                result;\r\n              if (hasNativeReflectConstruct) {\r\n                var NewTarget = _getPrototypeOf(this).constructor;\r\n                result = Reflect.construct(Super, arguments, NewTarget);\r\n              } else {\r\n                result = Super.apply(this, arguments);\r\n              }\r\n              return _possibleConstructorReturn(this, result);\r\n            };\r\n          }\r\n\r\n          function _possibleConstructorReturn(self, call) {\r\n            if (\r\n              call &&\r\n              (_typeof(call) === "object" || typeof call === "function")\r\n            ) {\r\n              return call;\r\n            }\r\n            return _assertThisInitialized(self);\r\n          }\r\n\r\n          function _assertThisInitialized(self) {\r\n            if (self === void 0) {\r\n              throw new ReferenceError(\r\n                "this hasn\'t been initialised - super() hasn\'t been called"\r\n              );\r\n            }\r\n            return self;\r\n          }\r\n\r\n          function _isNativeReflectConstruct() {\r\n            if (typeof Reflect === "undefined" || !Reflect.construct)\r\n              return false;\r\n            if (Reflect.construct.sham) return false;\r\n            if (typeof Proxy === "function") return true;\r\n            try {\r\n              Boolean.prototype.valueOf.call(\r\n                Reflect.construct(Boolean, [], function () {})\r\n              );\r\n              return true;\r\n            } catch (e) {\r\n              return false;\r\n            }\r\n          }\r\n\r\n          function _getPrototypeOf(o) {\r\n            _getPrototypeOf = Object.setPrototypeOf\r\n              ? Object.getPrototypeOf\r\n              : function _getPrototypeOf(o) {\r\n                  return o.__proto__ || Object.getPrototypeOf(o);\r\n                };\r\n            return _getPrototypeOf(o);\r\n          }\r\n\r\n          function _defineProperty(obj, key, value) {\r\n            if (key in obj) {\r\n              Object.defineProperty(obj, key, {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true,\r\n              });\r\n            } else {\r\n              obj[key] = value;\r\n            }\r\n            return obj;\r\n          }\r\n\r\n          var MediaTagReader = require("./MediaTagReader");\r\n          /* The first 4 bytes of a FLAC file describes the header for the file. If these\r\n           * bytes respectively read "fLaC", we can determine it is a FLAC file.\r\n           */\r\n\r\n          var FLAC_HEADER_SIZE = 4;\r\n          /* FLAC metadata is stored in blocks containing data ranging from STREAMINFO to\r\n           * VORBIS_COMMENT, which is what we want to work with.\r\n           *\r\n           * Each metadata header is 4 bytes long, with the first byte determining whether\r\n           * it is the last metadata block before the audio data and what the block type is.\r\n           * This first byte can further be split into 8 bits, with the first bit being the\r\n           * last-metadata-block flag, and the last three bits being the block type.\r\n           *\r\n           * Since the specification states that the decimal value for a VORBIS_COMMENT block\r\n           * type is 4, the two possibilities for the comment block header values are:\r\n           * - 00000100 (Not a last metadata comment block, value of 4)\r\n           * - 10000100 (A last metadata comment block, value of 132)\r\n           *\r\n           * Similarly, the picture block header values are 6 and 128.\r\n           *\r\n           * All values for METADATA_BLOCK_HEADER can be found here.\r\n           * https://xiph.org/flac/format.html#metadata_block_header\r\n           */\r\n\r\n          var COMMENT_HEADERS = [4, 132];\r\n          var PICTURE_HEADERS = [6, 134]; // These are the possible image types as defined by the FLAC specification.\r\n\r\n          var IMAGE_TYPES = [\r\n            "Other",\r\n            "32x32 pixels \'file icon\' (PNG only)",\r\n            "Other file icon",\r\n            "Cover (front)",\r\n            "Cover (back)",\r\n            "Leaflet page",\r\n            "Media (e.g. label side of CD)",\r\n            "Lead artist/lead performer/soloist",\r\n            "Artist/performer",\r\n            "Conductor",\r\n            "Band/Orchestra",\r\n            "Composer",\r\n            "Lyricist/text writer",\r\n            "Recording Location",\r\n            "During recording",\r\n            "During performance",\r\n            "Movie/video screen capture",\r\n            "A bright coloured fish",\r\n            "Illustration",\r\n            "Band/artist logotype",\r\n            "Publisher/Studio logotype",\r\n          ];\r\n\r\n          /**\r\n           * Class representing a MediaTagReader that parses FLAC tags.\r\n           */\r\n          var FLACTagReader = /*#__PURE__*/ (function (_MediaTagReader) {\r\n            _inherits(FLACTagReader, _MediaTagReader);\r\n\r\n            var _super = _createSuper(FLACTagReader);\r\n\r\n            function FLACTagReader() {\r\n              var _this;\r\n\r\n              _classCallCheck(this, FLACTagReader);\r\n\r\n              for (\r\n                var _len = arguments.length, args = new Array(_len), _key = 0;\r\n                _key < _len;\r\n                _key++\r\n              ) {\r\n                args[_key] = arguments[_key];\r\n              }\r\n\r\n              _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n              _defineProperty(\r\n                _assertThisInitialized(_this),\r\n                "_commentOffset",\r\n                void 0\r\n              );\r\n\r\n              _defineProperty(\r\n                _assertThisInitialized(_this),\r\n                "_pictureOffset",\r\n                void 0\r\n              );\r\n\r\n              return _this;\r\n            }\r\n\r\n            _createClass(\r\n              FLACTagReader,\r\n              [\r\n                {\r\n                  key: "_loadData",\r\n                  value:\r\n                    /**\r\n                     * Function called to load the data from the file.\r\n                     *\r\n                     * To begin processing the blocks, the next 4 bytes after the initial 4 bytes\r\n                     * (bytes 4 through 7) are loaded. From there, the rest of the loading process\r\n                     * is passed on to the _loadBlock function, which will handle the rest of the\r\n                     * parsing for the metadata blocks.\r\n                     *\r\n                     * @param {MediaFileReader} mediaFileReader - The MediaFileReader used to parse the file.\r\n                     * @param {LoadCallbackType} callbacks - The callback to call once _loadData is completed.\r\n                     */\r\n                    function _loadData(mediaFileReader, callbacks) {\r\n                      var self = this;\r\n                      mediaFileReader.loadRange([4, 7], {\r\n                        onSuccess: function onSuccess() {\r\n                          self._loadBlock(mediaFileReader, 4, callbacks);\r\n                        },\r\n                      });\r\n                    },\r\n                  /**\r\n                   * Special internal function used to parse the different FLAC blocks.\r\n                   *\r\n                   * The FLAC specification doesn\'t specify a specific location for metadata to resign, but\r\n                   * dictates that it may be in one of various blocks located throughout the file. To load the\r\n                   * metadata, we must locate the header first. This can be done by reading the first byte of\r\n                   * each block to determine the block type. After the block type comes a 24 bit integer that stores\r\n                   * the length of the block as big endian. Using this, we locate the block and store the offset for\r\n                   * parsing later.\r\n                   *\r\n                   * After each block has been parsed, the _nextBlock function is called in order\r\n                   * to parse the information of the next block. All blocks need to be parsed in order to find\r\n                   * all of the picture and comment blocks.\r\n                   *\r\n                   * More info on the FLAC specification may be found here:\r\n                   * https://xiph.org/flac/format.html\r\n                   * @param {MediaFileReader} mediaFileReader - The MediaFileReader used to parse the file.\r\n                   * @param {number} offset - The offset to start checking the header from.\r\n                   * @param {LoadCallbackType} callbacks - The callback to call once the header has been found.\r\n                   */\r\n                },\r\n                {\r\n                  key: "_loadBlock",\r\n                  value: function _loadBlock(\r\n                    mediaFileReader,\r\n                    offset,\r\n                    callbacks\r\n                  ) {\r\n                    var self = this;\r\n                    /* As mentioned above, this first byte is loaded to see what metadata type\r\n                     * this block represents.\r\n                     */\r\n\r\n                    var blockHeader = mediaFileReader.getByteAt(offset);\r\n                    /* The last three bytes (integer 24) contain a value representing the length\r\n                     * of the following metadata block. The 1 is added in order to shift the offset\r\n                     * by one to get the last three bytes in the block header.\r\n                     */\r\n\r\n                    var blockSize = mediaFileReader.getInteger24At(\r\n                      offset + 1,\r\n                      true\r\n                    );\r\n                    /* This conditional checks if blockHeader (the byte retrieved representing the\r\n                     * type of the header) is one the headers we are looking for.\r\n                     *\r\n                     * If that is not true, the block is skipped over and the next range is loaded:\r\n                     * - offset + 4 + blockSize adds 4 to skip over the initial metadata header and\r\n                     * blockSize to skip over the block overall, placing it at the head of the next\r\n                     * metadata header.\r\n                     * - offset + 4 + 4 + blockSize does the same thing as the previous block with\r\n                     * the exception of adding another 4 bytes to move it to the end of the new metadata\r\n                     * header.\r\n                     */\r\n\r\n                    if (COMMENT_HEADERS.indexOf(blockHeader) !== -1) {\r\n                      /* 4 is added to offset to move it to the head of the actual metadata.\r\n                       * The range starting from offsetMatadata (the beginning of the block)\r\n                       * and offsetMetadata + blockSize (the end of the block) is loaded.\r\n                       */\r\n                      var offsetMetadata = offset + 4;\r\n                      mediaFileReader.loadRange(\r\n                        [offsetMetadata, offsetMetadata + blockSize],\r\n                        {\r\n                          onSuccess: function onSuccess() {\r\n                            self._commentOffset = offsetMetadata;\r\n\r\n                            self._nextBlock(\r\n                              mediaFileReader,\r\n                              offset,\r\n                              blockHeader,\r\n                              blockSize,\r\n                              callbacks\r\n                            );\r\n                          },\r\n                        }\r\n                      );\r\n                    } else if (PICTURE_HEADERS.indexOf(blockHeader) !== -1) {\r\n                      var offsetMetadata = offset + 4;\r\n                      mediaFileReader.loadRange(\r\n                        [offsetMetadata, offsetMetadata + blockSize],\r\n                        {\r\n                          onSuccess: function onSuccess() {\r\n                            self._pictureOffset = offsetMetadata;\r\n\r\n                            self._nextBlock(\r\n                              mediaFileReader,\r\n                              offset,\r\n                              blockHeader,\r\n                              blockSize,\r\n                              callbacks\r\n                            );\r\n                          },\r\n                        }\r\n                      );\r\n                    } else {\r\n                      self._nextBlock(\r\n                        mediaFileReader,\r\n                        offset,\r\n                        blockHeader,\r\n                        blockSize,\r\n                        callbacks\r\n                      );\r\n                    }\r\n                  },\r\n                  /**\r\n                   * Internal function used to load the next range and respective block.\r\n                   *\r\n                   * If the metadata block that was identified is not the last block before the\r\n                   * audio blocks, the function will continue loading the next blocks. If it is\r\n                   * the last block (identified by any values greater than 127, see FLAC spec.),\r\n                   * the function will determine whether a comment block had been identified.\r\n                   *\r\n                   * If the block does not exist, the error callback is called. Otherwise, the function\r\n                   * will call the success callback, allowing data parsing to begin.\r\n                   * @param {MediaFileReader} mediaFileReader - The MediaFileReader used to parse the file.\r\n                   * @param {number} offset - The offset that the existing header was located at.\r\n                   * @param {number} blockHeader - An integer reflecting the header type of the block.\r\n                   * @param {number} blockSize - The size of the previously processed header.\r\n                   * @param {LoadCallbackType} callbacks - The callback functions to be called.\r\n                   */\r\n                },\r\n                {\r\n                  key: "_nextBlock",\r\n                  value: function _nextBlock(\r\n                    mediaFileReader,\r\n                    offset,\r\n                    blockHeader,\r\n                    blockSize,\r\n                    callbacks\r\n                  ) {\r\n                    var self = this;\r\n\r\n                    if (blockHeader > 127) {\r\n                      if (!self._commentOffset) {\r\n                        callbacks.onError({\r\n                          type: "loadData",\r\n                          info: "Comment block could not be found.",\r\n                        });\r\n                      } else {\r\n                        callbacks.onSuccess();\r\n                      }\r\n                    } else {\r\n                      mediaFileReader.loadRange(\r\n                        [offset + 4 + blockSize, offset + 4 + 4 + blockSize],\r\n                        {\r\n                          onSuccess: function onSuccess() {\r\n                            self._loadBlock(\r\n                              mediaFileReader,\r\n                              offset + 4 + blockSize,\r\n                              callbacks\r\n                            );\r\n                          },\r\n                        }\r\n                      );\r\n                    }\r\n                  },\r\n                  /**\r\n                   * Parses the data and returns the tags.\r\n                   *\r\n                   * This is an overview of the VorbisComment format and what this function attempts to\r\n                   * retrieve:\r\n                   * - First 4 bytes: a long that contains the length of the vendor string.\r\n                   * - Next n bytes: the vendor string encoded in UTF-8.\r\n                   * - Next 4 bytes: a long representing how many comments are in this block\r\n                   * For each comment that exists:\r\n                   * - First 4 bytes: a long representing the length of the comment\r\n                   * - Next n bytes: the comment encoded in UTF-8.\r\n                   * The comment string will usually appear in a format similar to:\r\n                   * ARTIST=me\r\n                   *\r\n                   * Note that the longs and integers in this block are encoded in little endian\r\n                   * as opposed to big endian for the rest of the FLAC spec.\r\n                   * @param {MediaFileReader} data - The MediaFileReader to parse the file with.\r\n                   * @param {Array<string>} [tags] - Optional tags to also be retrieved from the file.\r\n                   * @return {TagType} - An object containing the tag information for the file.\r\n                   */\r\n                },\r\n                {\r\n                  key: "_parseData",\r\n                  value: function _parseData(data, tags) {\r\n                    var vendorLength = data.getLongAt(\r\n                      this._commentOffset,\r\n                      false\r\n                    );\r\n                    var offsetVendor = this._commentOffset + 4;\r\n                    /* This line is able to retrieve the vendor string that the VorbisComment block\r\n                     * contains. However, it is not part of the tags that JSMediaTags normally retrieves,\r\n                     * and is therefore commented out.\r\n                     */\r\n                    // var vendor = data.getStringWithCharsetAt(offsetVendor, vendorLength, "utf-8").toString();\r\n\r\n                    var offsetList = vendorLength + offsetVendor;\r\n                    /* To get the metadata from the block, we first get the long that contains the\r\n                     * number of actual comment values that are existent within the block.\r\n                     *\r\n                     * As we loop through all of the comment blocks, we get the data length in order to\r\n                     * get the right size string, and then determine which category that string falls under.\r\n                     * The dataOffset variable is constantly updated so that it is at the beginning of the\r\n                     * comment that is currently being parsed.\r\n                     *\r\n                     * Additions of 4 here are used to move the offset past the first 4 bytes which only contain\r\n                     * the length of the comment.\r\n                     */\r\n\r\n                    var numComments = data.getLongAt(offsetList, false);\r\n                    var dataOffset = offsetList + 4;\r\n                    var title, artist, album, track, genre, picture;\r\n\r\n                    for (var i = 0; i < numComments; i++) {\r\n                      var _dataLength = data.getLongAt(dataOffset, false);\r\n\r\n                      var s = data\r\n                        .getStringWithCharsetAt(\r\n                          dataOffset + 4,\r\n                          _dataLength,\r\n                          "utf-8"\r\n                        )\r\n                        .toString();\r\n                      var d = s.indexOf("=");\r\n                      var split = [s.slice(0, d), s.slice(d + 1)];\r\n\r\n                      switch (split[0].toUpperCase()) {\r\n                        case "TITLE":\r\n                          title = split[1];\r\n                          break;\r\n\r\n                        case "ARTIST":\r\n                          artist = split[1];\r\n                          break;\r\n\r\n                        case "ALBUM":\r\n                          album = split[1];\r\n                          break;\r\n\r\n                        case "TRACKNUMBER":\r\n                          track = split[1];\r\n                          break;\r\n\r\n                        case "GENRE":\r\n                          genre = split[1];\r\n                          break;\r\n                      }\r\n\r\n                      dataOffset += 4 + _dataLength;\r\n                    }\r\n                    /* If a picture offset was found and assigned, then the reader will start processing\r\n                     * the picture block from that point.\r\n                     *\r\n                     * All the lengths for the picture data can be found online here:\r\n                     * https://xiph.org/flac/format.html#metadata_block_picture\r\n                     */\r\n\r\n                    if (this._pictureOffset) {\r\n                      var imageType = data.getLongAt(this._pictureOffset, true);\r\n                      var offsetMimeLength = this._pictureOffset + 4;\r\n                      var mimeLength = data.getLongAt(offsetMimeLength, true);\r\n                      var offsetMime = offsetMimeLength + 4;\r\n                      var mime = data.getStringAt(offsetMime, mimeLength);\r\n                      var offsetDescriptionLength = offsetMime + mimeLength;\r\n                      var descriptionLength = data.getLongAt(\r\n                        offsetDescriptionLength,\r\n                        true\r\n                      );\r\n                      var offsetDescription = offsetDescriptionLength + 4;\r\n                      var description = data\r\n                        .getStringWithCharsetAt(\r\n                          offsetDescription,\r\n                          descriptionLength,\r\n                          "utf-8"\r\n                        )\r\n                        .toString();\r\n                      var offsetDataLength =\r\n                        offsetDescription + descriptionLength + 16;\r\n                      var dataLength = data.getLongAt(offsetDataLength, true);\r\n                      var offsetData = offsetDataLength + 4;\r\n                      var imageData = data.getBytesAt(\r\n                        offsetData,\r\n                        dataLength,\r\n                        true\r\n                      );\r\n                      picture = {\r\n                        format: mime,\r\n                        type: IMAGE_TYPES[imageType],\r\n                        description: description,\r\n                        data: imageData,\r\n                      };\r\n                    }\r\n\r\n                    var tag = {\r\n                      type: "FLAC",\r\n                      version: "1",\r\n                      tags: {\r\n                        title: title,\r\n                        artist: artist,\r\n                        album: album,\r\n                        track: track,\r\n                        genre: genre,\r\n                        picture: picture,\r\n                      },\r\n                    };\r\n                    return tag;\r\n                  },\r\n                },\r\n              ],\r\n              [\r\n                {\r\n                  key: "getTagIdentifierByteRange",\r\n                  value:\r\n                    /**\r\n                     * Gets the byte range for the tag identifier.\r\n                     *\r\n                     * Because the Vorbis comment block is not guaranteed to be in a specified\r\n                     * location, we can only load the first 4 bytes of the file to confirm it\r\n                     * is a FLAC first.\r\n                     *\r\n                     * @return {ByteRange} The byte range that identifies the tag for a FLAC.\r\n                     */\r\n                    function getTagIdentifierByteRange() {\r\n                      return {\r\n                        offset: 0,\r\n                        length: FLAC_HEADER_SIZE,\r\n                      };\r\n                    },\r\n                  /**\r\n                   * Determines whether or not this reader can read a certain tag format.\r\n                   *\r\n                   * This checks that the first 4 characters in the file are fLaC, which\r\n                   * according to the FLAC file specification should be the characters that\r\n                   * indicate a FLAC file.\r\n                   *\r\n                   * @return {boolean} True if the header is fLaC, false otherwise.\r\n                   */\r\n                },\r\n                {\r\n                  key: "canReadTagFormat",\r\n                  value: function canReadTagFormat(tagIdentifier) {\r\n                    var id = String.fromCharCode.apply(\r\n                      String,\r\n                      tagIdentifier.slice(0, 4)\r\n                    );\r\n                    return id === "fLaC";\r\n                  },\r\n                },\r\n              ]\r\n            );\r\n\r\n            return FLACTagReader;\r\n          })(MediaTagReader);\r\n\r\n          module.exports = FLACTagReader;\r\n        },\r\n        { "./MediaTagReader": 12 },\r\n      ],\r\n      7: [\r\n        function (require, module, exports) {\r\n          "use strict";\r\n\r\n          function _typeof(obj) {\r\n            "@babel/helpers - typeof";\r\n            if (\r\n              typeof Symbol === "function" &&\r\n              typeof Symbol.iterator === "symbol"\r\n            ) {\r\n              _typeof = function _typeof(obj) {\r\n                return typeof obj;\r\n              };\r\n            } else {\r\n              _typeof = function _typeof(obj) {\r\n                return obj &&\r\n                  typeof Symbol === "function" &&\r\n                  obj.constructor === Symbol &&\r\n                  obj !== Symbol.prototype\r\n                  ? "symbol"\r\n                  : typeof obj;\r\n              };\r\n            }\r\n            return _typeof(obj);\r\n          }\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _inherits(subClass, superClass) {\r\n            if (typeof superClass !== "function" && superClass !== null) {\r\n              throw new TypeError(\r\n                "Super expression must either be null or a function"\r\n              );\r\n            }\r\n            subClass.prototype = Object.create(\r\n              superClass && superClass.prototype,\r\n              {\r\n                constructor: {\r\n                  value: subClass,\r\n                  writable: true,\r\n                  configurable: true,\r\n                },\r\n              }\r\n            );\r\n            if (superClass) _setPrototypeOf(subClass, superClass);\r\n          }\r\n\r\n          function _setPrototypeOf(o, p) {\r\n            _setPrototypeOf =\r\n              Object.setPrototypeOf ||\r\n              function _setPrototypeOf(o, p) {\r\n                o.__proto__ = p;\r\n                return o;\r\n              };\r\n            return _setPrototypeOf(o, p);\r\n          }\r\n\r\n          function _createSuper(Derived) {\r\n            var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n            return function _createSuperInternal() {\r\n              var Super = _getPrototypeOf(Derived),\r\n                result;\r\n              if (hasNativeReflectConstruct) {\r\n                var NewTarget = _getPrototypeOf(this).constructor;\r\n                result = Reflect.construct(Super, arguments, NewTarget);\r\n              } else {\r\n                result = Super.apply(this, arguments);\r\n              }\r\n              return _possibleConstructorReturn(this, result);\r\n            };\r\n          }\r\n\r\n          function _possibleConstructorReturn(self, call) {\r\n            if (\r\n              call &&\r\n              (_typeof(call) === "object" || typeof call === "function")\r\n            ) {\r\n              return call;\r\n            }\r\n            return _assertThisInitialized(self);\r\n          }\r\n\r\n          function _assertThisInitialized(self) {\r\n            if (self === void 0) {\r\n              throw new ReferenceError(\r\n                "this hasn\'t been initialised - super() hasn\'t been called"\r\n              );\r\n            }\r\n            return self;\r\n          }\r\n\r\n          function _isNativeReflectConstruct() {\r\n            if (typeof Reflect === "undefined" || !Reflect.construct)\r\n              return false;\r\n            if (Reflect.construct.sham) return false;\r\n            if (typeof Proxy === "function") return true;\r\n            try {\r\n              Boolean.prototype.valueOf.call(\r\n                Reflect.construct(Boolean, [], function () {})\r\n              );\r\n              return true;\r\n            } catch (e) {\r\n              return false;\r\n            }\r\n          }\r\n\r\n          function _getPrototypeOf(o) {\r\n            _getPrototypeOf = Object.setPrototypeOf\r\n              ? Object.getPrototypeOf\r\n              : function _getPrototypeOf(o) {\r\n                  return o.__proto__ || Object.getPrototypeOf(o);\r\n                };\r\n            return _getPrototypeOf(o);\r\n          }\r\n\r\n          var MediaTagReader = require("./MediaTagReader");\r\n\r\n          var MediaFileReader = require("./MediaFileReader");\r\n\r\n          var ID3v1TagReader = /*#__PURE__*/ (function (_MediaTagReader) {\r\n            _inherits(ID3v1TagReader, _MediaTagReader);\r\n\r\n            var _super = _createSuper(ID3v1TagReader);\r\n\r\n            function ID3v1TagReader() {\r\n              _classCallCheck(this, ID3v1TagReader);\r\n\r\n              return _super.apply(this, arguments);\r\n            }\r\n\r\n            _createClass(\r\n              ID3v1TagReader,\r\n              [\r\n                {\r\n                  key: "_loadData",\r\n                  value: function _loadData(mediaFileReader, callbacks) {\r\n                    var fileSize = mediaFileReader.getSize();\r\n                    mediaFileReader.loadRange(\r\n                      [fileSize - 128, fileSize - 1],\r\n                      callbacks\r\n                    );\r\n                  },\r\n                },\r\n                {\r\n                  key: "_parseData",\r\n                  value: function _parseData(data, tags) {\r\n                    var offset = data.getSize() - 128;\r\n                    var title = data\r\n                      .getStringWithCharsetAt(offset + 3, 30)\r\n                      .toString();\r\n                    var artist = data\r\n                      .getStringWithCharsetAt(offset + 33, 30)\r\n                      .toString();\r\n                    var album = data\r\n                      .getStringWithCharsetAt(offset + 63, 30)\r\n                      .toString();\r\n                    var year = data\r\n                      .getStringWithCharsetAt(offset + 93, 4)\r\n                      .toString();\r\n                    var trackFlag = data.getByteAt(offset + 97 + 28);\r\n                    var track = data.getByteAt(offset + 97 + 29);\r\n\r\n                    if (trackFlag == 0 && track != 0) {\r\n                      var version = "1.1";\r\n                      var comment = data\r\n                        .getStringWithCharsetAt(offset + 97, 28)\r\n                        .toString();\r\n                    } else {\r\n                      var version = "1.0";\r\n                      var comment = data\r\n                        .getStringWithCharsetAt(offset + 97, 30)\r\n                        .toString();\r\n                      track = 0;\r\n                    }\r\n\r\n                    var genreIdx = data.getByteAt(offset + 97 + 30);\r\n\r\n                    if (genreIdx < 255) {\r\n                      var genre = GENRES[genreIdx];\r\n                    } else {\r\n                      var genre = "";\r\n                    }\r\n\r\n                    var tag = {\r\n                      type: "ID3",\r\n                      version: version,\r\n                      tags: {\r\n                        title: title,\r\n                        artist: artist,\r\n                        album: album,\r\n                        year: year,\r\n                        comment: comment,\r\n                        genre: genre,\r\n                      },\r\n                    };\r\n\r\n                    if (track) {\r\n                      // $FlowIssue - flow is not happy with adding properties\r\n                      tag.tags.track = track;\r\n                    }\r\n\r\n                    return tag;\r\n                  },\r\n                },\r\n              ],\r\n              [\r\n                {\r\n                  key: "getTagIdentifierByteRange",\r\n                  value: function getTagIdentifierByteRange() {\r\n                    // The identifier is TAG and is at offset: -128. However, to avoid a\r\n                    // fetch for the tag identifier and another for the data, we load the\r\n                    // entire data since it\'s so small.\r\n                    return {\r\n                      offset: -128,\r\n                      length: 128,\r\n                    };\r\n                  },\r\n                },\r\n                {\r\n                  key: "canReadTagFormat",\r\n                  value: function canReadTagFormat(tagIdentifier) {\r\n                    var id = String.fromCharCode.apply(\r\n                      String,\r\n                      tagIdentifier.slice(0, 3)\r\n                    );\r\n                    return id === "TAG";\r\n                  },\r\n                },\r\n              ]\r\n            );\r\n\r\n            return ID3v1TagReader;\r\n          })(MediaTagReader);\r\n\r\n          var GENRES = [\r\n            "Blues",\r\n            "Classic Rock",\r\n            "Country",\r\n            "Dance",\r\n            "Disco",\r\n            "Funk",\r\n            "Grunge",\r\n            "Hip-Hop",\r\n            "Jazz",\r\n            "Metal",\r\n            "New Age",\r\n            "Oldies",\r\n            "Other",\r\n            "Pop",\r\n            "R&B",\r\n            "Rap",\r\n            "Reggae",\r\n            "Rock",\r\n            "Techno",\r\n            "Industrial",\r\n            "Alternative",\r\n            "Ska",\r\n            "Death Metal",\r\n            "Pranks",\r\n            "Soundtrack",\r\n            "Euro-Techno",\r\n            "Ambient",\r\n            "Trip-Hop",\r\n            "Vocal",\r\n            "Jazz+Funk",\r\n            "Fusion",\r\n            "Trance",\r\n            "Classical",\r\n            "Instrumental",\r\n            "Acid",\r\n            "House",\r\n            "Game",\r\n            "Sound Clip",\r\n            "Gospel",\r\n            "Noise",\r\n            "AlternRock",\r\n            "Bass",\r\n            "Soul",\r\n            "Punk",\r\n            "Space",\r\n            "Meditative",\r\n            "Instrumental Pop",\r\n            "Instrumental Rock",\r\n            "Ethnic",\r\n            "Gothic",\r\n            "Darkwave",\r\n            "Techno-Industrial",\r\n            "Electronic",\r\n            "Pop-Folk",\r\n            "Eurodance",\r\n            "Dream",\r\n            "Southern Rock",\r\n            "Comedy",\r\n            "Cult",\r\n            "Gangsta",\r\n            "Top 40",\r\n            "Christian Rap",\r\n            "Pop/Funk",\r\n            "Jungle",\r\n            "Native American",\r\n            "Cabaret",\r\n            "New Wave",\r\n            "Psychadelic",\r\n            "Rave",\r\n            "Showtunes",\r\n            "Trailer",\r\n            "Lo-Fi",\r\n            "Tribal",\r\n            "Acid Punk",\r\n            "Acid Jazz",\r\n            "Polka",\r\n            "Retro",\r\n            "Musical",\r\n            "Rock & Roll",\r\n            "Hard Rock",\r\n            "Folk",\r\n            "Folk-Rock",\r\n            "National Folk",\r\n            "Swing",\r\n            "Fast Fusion",\r\n            "Bebob",\r\n            "Latin",\r\n            "Revival",\r\n            "Celtic",\r\n            "Bluegrass",\r\n            "Avantgarde",\r\n            "Gothic Rock",\r\n            "Progressive Rock",\r\n            "Psychedelic Rock",\r\n            "Symphonic Rock",\r\n            "Slow Rock",\r\n            "Big Band",\r\n            "Chorus",\r\n            "Easy Listening",\r\n            "Acoustic",\r\n            "Humour",\r\n            "Speech",\r\n            "Chanson",\r\n            "Opera",\r\n            "Chamber Music",\r\n            "Sonata",\r\n            "Symphony",\r\n            "Booty Bass",\r\n            "Primus",\r\n            "Porn Groove",\r\n            "Satire",\r\n            "Slow Jam",\r\n            "Club",\r\n            "Tango",\r\n            "Samba",\r\n            "Folklore",\r\n            "Ballad",\r\n            "Power Ballad",\r\n            "Rhythmic Soul",\r\n            "Freestyle",\r\n            "Duet",\r\n            "Punk Rock",\r\n            "Drum Solo",\r\n            "Acapella",\r\n            "Euro-House",\r\n            "Dance Hall",\r\n          ];\r\n          module.exports = ID3v1TagReader;\r\n        },\r\n        { "./MediaFileReader": 11, "./MediaTagReader": 12 },\r\n      ],\r\n      8: [\r\n        function (require, module, exports) {\r\n          "use strict";\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          var MediaFileReader = require("./MediaFileReader");\r\n\r\n          var StringUtils = require("./StringUtils");\r\n\r\n          var ArrayFileReader = require("./ArrayFileReader");\r\n\r\n          var FRAME_DESCRIPTIONS = {\r\n            // v2.2\r\n            BUF: "Recommended buffer size",\r\n            CNT: "Play counter",\r\n            COM: "Comments",\r\n            CRA: "Audio encryption",\r\n            CRM: "Encrypted meta frame",\r\n            ETC: "Event timing codes",\r\n            EQU: "Equalization",\r\n            GEO: "General encapsulated object",\r\n            IPL: "Involved people list",\r\n            LNK: "Linked information",\r\n            MCI: "Music CD Identifier",\r\n            MLL: "MPEG location lookup table",\r\n            PIC: "Attached picture",\r\n            POP: "Popularimeter",\r\n            REV: "Reverb",\r\n            RVA: "Relative volume adjustment",\r\n            SLT: "Synchronized lyric/text",\r\n            STC: "Synced tempo codes",\r\n            TAL: "Album/Movie/Show title",\r\n            TBP: "BPM (Beats Per Minute)",\r\n            TCM: "Composer",\r\n            TCO: "Content type",\r\n            TCR: "Copyright message",\r\n            TDA: "Date",\r\n            TDY: "Playlist delay",\r\n            TEN: "Encoded by",\r\n            TFT: "File type",\r\n            TIM: "Time",\r\n            TKE: "Initial key",\r\n            TLA: "Language(s)",\r\n            TLE: "Length",\r\n            TMT: "Media type",\r\n            TOA: "Original artist(s)/performer(s)",\r\n            TOF: "Original filename",\r\n            TOL: "Original Lyricist(s)/text writer(s)",\r\n            TOR: "Original release year",\r\n            TOT: "Original album/Movie/Show title",\r\n            TP1: "Lead artist(s)/Lead performer(s)/Soloist(s)/Performing group",\r\n            TP2: "Band/Orchestra/Accompaniment",\r\n            TP3: "Conductor/Performer refinement",\r\n            TP4: "Interpreted, remixed, or otherwise modified by",\r\n            TPA: "Part of a set",\r\n            TPB: "Publisher",\r\n            TRC: "ISRC (International Standard Recording Code)",\r\n            TRD: "Recording dates",\r\n            TRK: "Track number/Position in set",\r\n            TSI: "Size",\r\n            TSS: "Software/hardware and settings used for encoding",\r\n            TT1: "Content group description",\r\n            TT2: "Title/Songname/Content description",\r\n            TT3: "Subtitle/Description refinement",\r\n            TXT: "Lyricist/text writer",\r\n            TXX: "User defined text information frame",\r\n            TYE: "Year",\r\n            UFI: "Unique file identifier",\r\n            ULT: "Unsychronized lyric/text transcription",\r\n            WAF: "Official audio file webpage",\r\n            WAR: "Official artist/performer webpage",\r\n            WAS: "Official audio source webpage",\r\n            WCM: "Commercial information",\r\n            WCP: "Copyright/Legal information",\r\n            WPB: "Publishers official webpage",\r\n            WXX: "User defined URL link frame",\r\n            // v2.3\r\n            AENC: "Audio encryption",\r\n            APIC: "Attached picture",\r\n            ASPI: "Audio seek point index",\r\n            CHAP: "Chapter",\r\n            CTOC: "Table of contents",\r\n            COMM: "Comments",\r\n            COMR: "Commercial frame",\r\n            ENCR: "Encryption method registration",\r\n            EQU2: "Equalisation (2)",\r\n            EQUA: "Equalization",\r\n            ETCO: "Event timing codes",\r\n            GEOB: "General encapsulated object",\r\n            GRID: "Group identification registration",\r\n            IPLS: "Involved people list",\r\n            LINK: "Linked information",\r\n            MCDI: "Music CD identifier",\r\n            MLLT: "MPEG location lookup table",\r\n            OWNE: "Ownership frame",\r\n            PRIV: "Private frame",\r\n            PCNT: "Play counter",\r\n            POPM: "Popularimeter",\r\n            POSS: "Position synchronisation frame",\r\n            RBUF: "Recommended buffer size",\r\n            RVA2: "Relative volume adjustment (2)",\r\n            RVAD: "Relative volume adjustment",\r\n            RVRB: "Reverb",\r\n            SEEK: "Seek frame",\r\n            SYLT: "Synchronized lyric/text",\r\n            SYTC: "Synchronized tempo codes",\r\n            TALB: "Album/Movie/Show title",\r\n            TBPM: "BPM (beats per minute)",\r\n            TCOM: "Composer",\r\n            TCON: "Content type",\r\n            TCOP: "Copyright message",\r\n            TDAT: "Date",\r\n            TDLY: "Playlist delay",\r\n            TDRC: "Recording time",\r\n            TDRL: "Release time",\r\n            TDTG: "Tagging time",\r\n            TENC: "Encoded by",\r\n            TEXT: "Lyricist/Text writer",\r\n            TFLT: "File type",\r\n            TIME: "Time",\r\n            TIPL: "Involved people list",\r\n            TIT1: "Content group description",\r\n            TIT2: "Title/songname/content description",\r\n            TIT3: "Subtitle/Description refinement",\r\n            TKEY: "Initial key",\r\n            TLAN: "Language(s)",\r\n            TLEN: "Length",\r\n            TMCL: "Musician credits list",\r\n            TMED: "Media type",\r\n            TMOO: "Mood",\r\n            TOAL: "Original album/movie/show title",\r\n            TOFN: "Original filename",\r\n            TOLY: "Original lyricist(s)/text writer(s)",\r\n            TOPE: "Original artist(s)/performer(s)",\r\n            TORY: "Original release year",\r\n            TOWN: "File owner/licensee",\r\n            TPE1: "Lead performer(s)/Soloist(s)",\r\n            TPE2: "Band/orchestra/accompaniment",\r\n            TPE3: "Conductor/performer refinement",\r\n            TPE4: "Interpreted, remixed, or otherwise modified by",\r\n            TPOS: "Part of a set",\r\n            TPRO: "Produced notice",\r\n            TPUB: "Publisher",\r\n            TRCK: "Track number/Position in set",\r\n            TRDA: "Recording dates",\r\n            TRSN: "Internet radio station name",\r\n            TRSO: "Internet radio station owner",\r\n            TSOA: "Album sort order",\r\n            TSOP: "Performer sort order",\r\n            TSOT: "Title sort order",\r\n            TSIZ: "Size",\r\n            TSRC: "ISRC (international standard recording code)",\r\n            TSSE: "Software/Hardware and settings used for encoding",\r\n            TSST: "Set subtitle",\r\n            TYER: "Year",\r\n            TXXX: "User defined text information frame",\r\n            UFID: "Unique file identifier",\r\n            USER: "Terms of use",\r\n            USLT: "Unsychronized lyric/text transcription",\r\n            WCOM: "Commercial information",\r\n            WCOP: "Copyright/Legal information",\r\n            WOAF: "Official audio file webpage",\r\n            WOAR: "Official artist/performer webpage",\r\n            WOAS: "Official audio source webpage",\r\n            WORS: "Official internet radio station homepage",\r\n            WPAY: "Payment",\r\n            WPUB: "Publishers official webpage",\r\n            WXXX: "User defined URL link frame",\r\n          };\r\n\r\n          var ID3v2FrameReader = /*#__PURE__*/ (function () {\r\n            function ID3v2FrameReader() {\r\n              _classCallCheck(this, ID3v2FrameReader);\r\n            }\r\n\r\n            _createClass(ID3v2FrameReader, null, [\r\n              {\r\n                key: "getFrameReaderFunction",\r\n                value: function getFrameReaderFunction(frameId) {\r\n                  if (frameId in frameReaderFunctions) {\r\n                    return frameReaderFunctions[frameId];\r\n                  } else if (frameId[0] === "T") {\r\n                    // All frame ids starting with T are text tags.\r\n                    return frameReaderFunctions["T*"];\r\n                  } else if (frameId[0] === "W") {\r\n                    // All frame ids starting with W are url tags.\r\n                    return frameReaderFunctions["W*"];\r\n                  } else {\r\n                    return null;\r\n                  }\r\n                },\r\n                /**\r\n                 * All the frames consists of a frame header followed by one or more fields\r\n                 * containing the actual information.\r\n                 * The frame ID made out of the characters capital A-Z and 0-9. Identifiers\r\n                 * beginning with "X", "Y" and "Z" are for experimental use and free for\r\n                 * everyone to use, without the need to set the experimental bit in the tag\r\n                 * header. Have in mind that someone else might have used the same identifier\r\n                 * as you. All other identifiers are either used or reserved for future use.\r\n                 * The frame ID is followed by a size descriptor, making a total header size\r\n                 * of ten bytes in every frame. The size is calculated as frame size excluding\r\n                 * frame header (frame size - 10).\r\n                 */\r\n              },\r\n              {\r\n                key: "readFrames",\r\n                value: function readFrames(offset, end, data, id3header, tags) {\r\n                  var frames = {};\r\n\r\n                  var frameHeaderSize = this._getFrameHeaderSize(id3header); // console.log(\'header\', id3header);\r\n\r\n                  while (\r\n                    // we should be able to read at least the frame header\r\n                    offset <\r\n                    end - frameHeaderSize\r\n                  ) {\r\n                    var header = this._readFrameHeader(data, offset, id3header);\r\n\r\n                    var frameId = header.id; // No frame ID sometimes means it\'s the last frame (GTFO).\r\n\r\n                    if (!frameId) {\r\n                      break;\r\n                    }\r\n\r\n                    var flags = header.flags;\r\n                    var frameSize = header.size;\r\n                    var frameDataOffset = offset + header.headerSize;\r\n                    var frameData = data; // console.log(offset, frameId, header.size + header.headerSize, flags && flags.format.unsynchronisation);\r\n                    // advance data offset to the next frame data\r\n\r\n                    offset += header.headerSize + header.size; // skip unwanted tags\r\n\r\n                    if (tags && tags.indexOf(frameId) === -1) {\r\n                      continue;\r\n                    } // Workaround: MP3ext V3.3.17 places a non-compliant padding string at\r\n                    // the end of the ID3v2 header. A string like "MP3ext V3.3.19(ansi)"\r\n                    // is added multiple times at the end of the ID3 tag. More information\r\n                    // about this issue can be found at\r\n                    // https://github.com/aadsm/jsmediatags/issues/58#issuecomment-313865336\r\n\r\n                    if (\r\n                      frameId === "MP3e" ||\r\n                      frameId === "\\x00MP3" ||\r\n                      frameId === "\\x00\\x00MP" ||\r\n                      frameId === " MP3"\r\n                    ) {\r\n                      break;\r\n                    }\r\n\r\n                    var unsyncData;\r\n\r\n                    if (\r\n                      flags &&\r\n                      flags.format.unsynchronisation &&\r\n                      !id3header.flags.unsynchronisation\r\n                    ) {\r\n                      frameData = this.getUnsyncFileReader(\r\n                        frameData,\r\n                        frameDataOffset,\r\n                        frameSize\r\n                      );\r\n                      frameDataOffset = 0;\r\n                      frameSize = frameData.getSize();\r\n                    } // the first 4 bytes are the real data size\r\n                    // (after unsynchronisation && encryption)\r\n\r\n                    if (flags && flags.format.data_length_indicator) {\r\n                      // var frameDataSize = frameData.getSynchsafeInteger32At(frameDataOffset);\r\n                      frameDataOffset += 4;\r\n                      frameSize -= 4;\r\n                    }\r\n\r\n                    var readFrameFunc =\r\n                      ID3v2FrameReader.getFrameReaderFunction(frameId);\r\n                    var parsedData = readFrameFunc\r\n                      ? readFrameFunc.apply(this, [\r\n                          frameDataOffset,\r\n                          frameSize,\r\n                          frameData,\r\n                          flags,\r\n                          id3header,\r\n                        ])\r\n                      : null;\r\n\r\n                    var desc = this._getFrameDescription(frameId);\r\n\r\n                    var frame = {\r\n                      id: frameId,\r\n                      size: frameSize,\r\n                      description: desc,\r\n                      data: parsedData,\r\n                    };\r\n\r\n                    if (frameId in frames) {\r\n                      if (frames[frameId].id) {\r\n                        frames[frameId] = [frames[frameId]];\r\n                      }\r\n\r\n                      frames[frameId].push(frame);\r\n                    } else {\r\n                      frames[frameId] = frame;\r\n                    }\r\n                  }\r\n\r\n                  return frames;\r\n                },\r\n              },\r\n              {\r\n                key: "_getFrameHeaderSize",\r\n                value: function _getFrameHeaderSize(id3header) {\r\n                  var major = id3header.major;\r\n\r\n                  if (major == 2) {\r\n                    return 6;\r\n                  } else if (major == 3 || major == 4) {\r\n                    return 10;\r\n                  } else {\r\n                    return 0;\r\n                  }\r\n                },\r\n              },\r\n              {\r\n                key: "_readFrameHeader",\r\n                value: function _readFrameHeader(data, offset, id3header) {\r\n                  var major = id3header.major;\r\n                  var flags = null;\r\n\r\n                  var frameHeaderSize = this._getFrameHeaderSize(id3header);\r\n\r\n                  switch (major) {\r\n                    case 2:\r\n                      var frameId = data.getStringAt(offset, 3);\r\n                      var frameSize = data.getInteger24At(offset + 3, true);\r\n                      break;\r\n\r\n                    case 3:\r\n                      var frameId = data.getStringAt(offset, 4);\r\n                      var frameSize = data.getLongAt(offset + 4, true);\r\n                      break;\r\n\r\n                    case 4:\r\n                      var frameId = data.getStringAt(offset, 4);\r\n                      var frameSize = data.getSynchsafeInteger32At(offset + 4);\r\n                      break;\r\n                  }\r\n\r\n                  if (\r\n                    frameId == String.fromCharCode(0, 0, 0) ||\r\n                    frameId == String.fromCharCode(0, 0, 0, 0)\r\n                  ) {\r\n                    frameId = "";\r\n                  } // if frameId is empty then it\'s the last frame\r\n\r\n                  if (frameId) {\r\n                    // read frame message and format flags\r\n                    if (major > 2) {\r\n                      flags = this._readFrameFlags(data, offset + 8);\r\n                    }\r\n                  }\r\n\r\n                  return {\r\n                    id: frameId || "",\r\n                    size: frameSize || 0,\r\n                    headerSize: frameHeaderSize || 0,\r\n                    flags: flags,\r\n                  };\r\n                },\r\n              },\r\n              {\r\n                key: "_readFrameFlags",\r\n                value: function _readFrameFlags(data, offset) {\r\n                  return {\r\n                    message: {\r\n                      tag_alter_preservation: data.isBitSetAt(offset, 6),\r\n                      file_alter_preservation: data.isBitSetAt(offset, 5),\r\n                      read_only: data.isBitSetAt(offset, 4),\r\n                    },\r\n                    format: {\r\n                      grouping_identity: data.isBitSetAt(offset + 1, 7),\r\n                      compression: data.isBitSetAt(offset + 1, 3),\r\n                      encryption: data.isBitSetAt(offset + 1, 2),\r\n                      unsynchronisation: data.isBitSetAt(offset + 1, 1),\r\n                      data_length_indicator: data.isBitSetAt(offset + 1, 0),\r\n                    },\r\n                  };\r\n                },\r\n              },\r\n              {\r\n                key: "_getFrameDescription",\r\n                value: function _getFrameDescription(frameId) {\r\n                  if (frameId in FRAME_DESCRIPTIONS) {\r\n                    return FRAME_DESCRIPTIONS[frameId];\r\n                  } else {\r\n                    return "Unknown";\r\n                  }\r\n                },\r\n              },\r\n              {\r\n                key: "getUnsyncFileReader",\r\n                value: function getUnsyncFileReader(data, offset, size) {\r\n                  var frameData = data.getBytesAt(offset, size);\r\n\r\n                  for (var i = 0; i < frameData.length - 1; i++) {\r\n                    if (frameData[i] === 0xff && frameData[i + 1] === 0x00) {\r\n                      frameData.splice(i + 1, 1);\r\n                    }\r\n                  }\r\n\r\n                  return new ArrayFileReader(frameData);\r\n                },\r\n              },\r\n            ]);\r\n\r\n            return ID3v2FrameReader;\r\n          })();\r\n\r\n          var frameReaderFunctions = {};\r\n\r\n          frameReaderFunctions["APIC"] = function readPictureFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            var start = offset;\r\n            var charset = getTextEncoding(data.getByteAt(offset));\r\n\r\n            switch (id3header && id3header.major) {\r\n              case 2:\r\n                var format = data.getStringAt(offset + 1, 3);\r\n                offset += 4;\r\n                break;\r\n\r\n              case 3:\r\n              case 4:\r\n                var format = data.getStringWithCharsetAt(\r\n                  offset + 1,\r\n                  length - 1\r\n                );\r\n                offset += 1 + format.bytesReadCount;\r\n                break;\r\n\r\n              default:\r\n                throw new Error("Couldn\'t read ID3v2 major version.");\r\n            }\r\n\r\n            var bite = data.getByteAt(offset);\r\n            var type = PICTURE_TYPE[bite];\r\n            var desc = data.getStringWithCharsetAt(\r\n              offset + 1,\r\n              length - (offset - start) - 1,\r\n              charset\r\n            );\r\n            offset += 1 + desc.bytesReadCount;\r\n            return {\r\n              format: format.toString(),\r\n              type: type,\r\n              description: desc.toString(),\r\n              data: data.getBytesAt(offset, start + length - offset),\r\n            };\r\n          }; // ID3v2 chapters according to http://id3.org/id3v2-chapters-1.0\r\n\r\n          frameReaderFunctions["CHAP"] = function readChapterFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            var originalOffset = offset;\r\n            var result = {};\r\n            var id = StringUtils.readNullTerminatedString(\r\n              data.getBytesAt(offset, length)\r\n            );\r\n            result.id = id.toString();\r\n            offset += id.bytesReadCount;\r\n            result.startTime = data.getLongAt(offset, true);\r\n            offset += 4;\r\n            result.endTime = data.getLongAt(offset, true);\r\n            offset += 4;\r\n            result.startOffset = data.getLongAt(offset, true);\r\n            offset += 4;\r\n            result.endOffset = data.getLongAt(offset, true);\r\n            offset += 4;\r\n            var remainingLength = length - (offset - originalOffset);\r\n            result.subFrames = this.readFrames(\r\n              offset,\r\n              offset + remainingLength,\r\n              data,\r\n              id3header\r\n            );\r\n            return result;\r\n          }; // ID3v2 table of contents according to http://id3.org/id3v2-chapters-1.0\r\n\r\n          frameReaderFunctions["CTOC"] = function readTableOfContentsFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            var originalOffset = offset;\r\n            var result = {\r\n              childElementIds: [],\r\n              id: undefined,\r\n              topLevel: undefined,\r\n              ordered: undefined,\r\n              entryCount: undefined,\r\n              subFrames: undefined,\r\n            };\r\n            var id = StringUtils.readNullTerminatedString(\r\n              data.getBytesAt(offset, length)\r\n            );\r\n            result.id = id.toString();\r\n            offset += id.bytesReadCount;\r\n            result.topLevel = data.isBitSetAt(offset, 1);\r\n            result.ordered = data.isBitSetAt(offset, 0);\r\n            offset++;\r\n            result.entryCount = data.getByteAt(offset);\r\n            offset++;\r\n\r\n            for (var i = 0; i < result.entryCount; i++) {\r\n              var childId = StringUtils.readNullTerminatedString(\r\n                data.getBytesAt(offset, length - (offset - originalOffset))\r\n              );\r\n              result.childElementIds.push(childId.toString());\r\n              offset += childId.bytesReadCount;\r\n            }\r\n\r\n            var remainingLength = length - (offset - originalOffset);\r\n            result.subFrames = this.readFrames(\r\n              offset,\r\n              offset + remainingLength,\r\n              data,\r\n              id3header\r\n            );\r\n            return result;\r\n          };\r\n\r\n          frameReaderFunctions["COMM"] = function readCommentsFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            var start = offset;\r\n            var charset = getTextEncoding(data.getByteAt(offset));\r\n            var language = data.getStringAt(offset + 1, 3);\r\n            var shortdesc = data.getStringWithCharsetAt(\r\n              offset + 4,\r\n              length - 4,\r\n              charset\r\n            );\r\n            offset += 4 + shortdesc.bytesReadCount;\r\n            var text = data.getStringWithCharsetAt(\r\n              offset,\r\n              start + length - offset,\r\n              charset\r\n            );\r\n            return {\r\n              language: language,\r\n              short_description: shortdesc.toString(),\r\n              text: text.toString(),\r\n            };\r\n          };\r\n\r\n          frameReaderFunctions["COM"] = frameReaderFunctions["COMM"];\r\n\r\n          frameReaderFunctions["PIC"] = function (\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            return frameReaderFunctions["APIC"](\r\n              offset,\r\n              length,\r\n              data,\r\n              flags,\r\n              id3header\r\n            );\r\n          };\r\n\r\n          frameReaderFunctions["PCNT"] = function readCounterFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            // FIXME: implement the rest of the spec\r\n            return data.getLongAt(offset, false);\r\n          };\r\n\r\n          frameReaderFunctions["CNT"] = frameReaderFunctions["PCNT"];\r\n\r\n          frameReaderFunctions["T*"] = function readTextFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            var charset = getTextEncoding(data.getByteAt(offset));\r\n            return data\r\n              .getStringWithCharsetAt(offset + 1, length - 1, charset)\r\n              .toString();\r\n          };\r\n\r\n          frameReaderFunctions["TXXX"] = function readTextFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            var charset = getTextEncoding(data.getByteAt(offset));\r\n            return getUserDefinedFields(offset, length, data, charset);\r\n          };\r\n\r\n          frameReaderFunctions["WXXX"] = function readUrlFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            if (length === 0) {\r\n              return null;\r\n            }\r\n\r\n            var charset = getTextEncoding(data.getByteAt(offset));\r\n            return getUserDefinedFields(offset, length, data, charset);\r\n          };\r\n\r\n          frameReaderFunctions["W*"] = function readUrlFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            if (length === 0) {\r\n              return null;\r\n            }\r\n\r\n            return data\r\n              .getStringWithCharsetAt(offset, length, "iso-8859-1")\r\n              .toString();\r\n          };\r\n\r\n          frameReaderFunctions["TCON"] = function readGenreFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags\r\n          ) {\r\n            var text = frameReaderFunctions["T*"].apply(this, arguments);\r\n            return text.replace(/^\\(\\d+\\)/, "");\r\n          };\r\n\r\n          frameReaderFunctions["TCO"] = frameReaderFunctions["TCON"];\r\n\r\n          frameReaderFunctions["USLT"] = function readLyricsFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            var start = offset;\r\n            var charset = getTextEncoding(data.getByteAt(offset));\r\n            var language = data.getStringAt(offset + 1, 3);\r\n            var descriptor = data.getStringWithCharsetAt(\r\n              offset + 4,\r\n              length - 4,\r\n              charset\r\n            );\r\n            offset += 4 + descriptor.bytesReadCount;\r\n            var lyrics = data.getStringWithCharsetAt(\r\n              offset,\r\n              start + length - offset,\r\n              charset\r\n            );\r\n            return {\r\n              language: language,\r\n              descriptor: descriptor.toString(),\r\n              lyrics: lyrics.toString(),\r\n            };\r\n          };\r\n\r\n          frameReaderFunctions["ULT"] = frameReaderFunctions["USLT"];\r\n\r\n          frameReaderFunctions["UFID"] = function readLyricsFrame(\r\n            offset,\r\n            length,\r\n            data,\r\n            flags,\r\n            id3header\r\n          ) {\r\n            var ownerIdentifier = StringUtils.readNullTerminatedString(\r\n              data.getBytesAt(offset, length)\r\n            );\r\n            offset += ownerIdentifier.bytesReadCount;\r\n            var identifier = data.getBytesAt(\r\n              offset,\r\n              length - ownerIdentifier.bytesReadCount\r\n            );\r\n            return {\r\n              ownerIdentifier: ownerIdentifier.toString(),\r\n              identifier: identifier,\r\n            };\r\n          };\r\n\r\n          function getTextEncoding(bite) {\r\n            var charset;\r\n\r\n            switch (bite) {\r\n              case 0x00:\r\n                charset = "iso-8859-1";\r\n                break;\r\n\r\n              case 0x01:\r\n                charset = "utf-16";\r\n                break;\r\n\r\n              case 0x02:\r\n                charset = "utf-16be";\r\n                break;\r\n\r\n              case 0x03:\r\n                charset = "utf-8";\r\n                break;\r\n\r\n              default:\r\n                charset = "iso-8859-1";\r\n            }\r\n\r\n            return charset;\r\n          } // Handles reading description/data from either http://id3.org/id3v2.3.0#User_defined_text_information_frame\r\n          // and http://id3.org/id3v2.3.0#User_defined_URL_link_frame\r\n\r\n          function getUserDefinedFields(offset, length, data, charset) {\r\n            var userDesc = data.getStringWithCharsetAt(\r\n              offset + 1,\r\n              length - 1,\r\n              charset\r\n            );\r\n            var userDefinedData = data.getStringWithCharsetAt(\r\n              offset + 1 + userDesc.bytesReadCount,\r\n              length - 1 - userDesc.bytesReadCount,\r\n              charset\r\n            );\r\n            return {\r\n              user_description: userDesc.toString(),\r\n              data: userDefinedData.toString(),\r\n            };\r\n          }\r\n\r\n          var PICTURE_TYPE = [\r\n            "Other",\r\n            "32x32 pixels \'file icon\' (PNG only)",\r\n            "Other file icon",\r\n            "Cover (front)",\r\n            "Cover (back)",\r\n            "Leaflet page",\r\n            "Media (e.g. label side of CD)",\r\n            "Lead artist/lead performer/soloist",\r\n            "Artist/performer",\r\n            "Conductor",\r\n            "Band/Orchestra",\r\n            "Composer",\r\n            "Lyricist/text writer",\r\n            "Recording Location",\r\n            "During recording",\r\n            "During performance",\r\n            "Movie/video screen capture",\r\n            "A bright coloured fish",\r\n            "Illustration",\r\n            "Band/artist logotype",\r\n            "Publisher/Studio logotype",\r\n          ];\r\n          module.exports = ID3v2FrameReader;\r\n        },\r\n        {\r\n          "./ArrayFileReader": 3,\r\n          "./MediaFileReader": 11,\r\n          "./StringUtils": 13,\r\n        },\r\n      ],\r\n      9: [\r\n        function (require, module, exports) {\r\n          "use strict";\r\n\r\n          function _typeof(obj) {\r\n            "@babel/helpers - typeof";\r\n            if (\r\n              typeof Symbol === "function" &&\r\n              typeof Symbol.iterator === "symbol"\r\n            ) {\r\n              _typeof = function _typeof(obj) {\r\n                return typeof obj;\r\n              };\r\n            } else {\r\n              _typeof = function _typeof(obj) {\r\n                return obj &&\r\n                  typeof Symbol === "function" &&\r\n                  obj.constructor === Symbol &&\r\n                  obj !== Symbol.prototype\r\n                  ? "symbol"\r\n                  : typeof obj;\r\n              };\r\n            }\r\n            return _typeof(obj);\r\n          }\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _inherits(subClass, superClass) {\r\n            if (typeof superClass !== "function" && superClass !== null) {\r\n              throw new TypeError(\r\n                "Super expression must either be null or a function"\r\n              );\r\n            }\r\n            subClass.prototype = Object.create(\r\n              superClass && superClass.prototype,\r\n              {\r\n                constructor: {\r\n                  value: subClass,\r\n                  writable: true,\r\n                  configurable: true,\r\n                },\r\n              }\r\n            );\r\n            if (superClass) _setPrototypeOf(subClass, superClass);\r\n          }\r\n\r\n          function _setPrototypeOf(o, p) {\r\n            _setPrototypeOf =\r\n              Object.setPrototypeOf ||\r\n              function _setPrototypeOf(o, p) {\r\n                o.__proto__ = p;\r\n                return o;\r\n              };\r\n            return _setPrototypeOf(o, p);\r\n          }\r\n\r\n          function _createSuper(Derived) {\r\n            var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n            return function _createSuperInternal() {\r\n              var Super = _getPrototypeOf(Derived),\r\n                result;\r\n              if (hasNativeReflectConstruct) {\r\n                var NewTarget = _getPrototypeOf(this).constructor;\r\n                result = Reflect.construct(Super, arguments, NewTarget);\r\n              } else {\r\n                result = Super.apply(this, arguments);\r\n              }\r\n              return _possibleConstructorReturn(this, result);\r\n            };\r\n          }\r\n\r\n          function _possibleConstructorReturn(self, call) {\r\n            if (\r\n              call &&\r\n              (_typeof(call) === "object" || typeof call === "function")\r\n            ) {\r\n              return call;\r\n            }\r\n            return _assertThisInitialized(self);\r\n          }\r\n\r\n          function _assertThisInitialized(self) {\r\n            if (self === void 0) {\r\n              throw new ReferenceError(\r\n                "this hasn\'t been initialised - super() hasn\'t been called"\r\n              );\r\n            }\r\n            return self;\r\n          }\r\n\r\n          function _isNativeReflectConstruct() {\r\n            if (typeof Reflect === "undefined" || !Reflect.construct)\r\n              return false;\r\n            if (Reflect.construct.sham) return false;\r\n            if (typeof Proxy === "function") return true;\r\n            try {\r\n              Boolean.prototype.valueOf.call(\r\n                Reflect.construct(Boolean, [], function () {})\r\n              );\r\n              return true;\r\n            } catch (e) {\r\n              return false;\r\n            }\r\n          }\r\n\r\n          function _getPrototypeOf(o) {\r\n            _getPrototypeOf = Object.setPrototypeOf\r\n              ? Object.getPrototypeOf\r\n              : function _getPrototypeOf(o) {\r\n                  return o.__proto__ || Object.getPrototypeOf(o);\r\n                };\r\n            return _getPrototypeOf(o);\r\n          }\r\n\r\n          var MediaTagReader = require("./MediaTagReader");\r\n\r\n          var MediaFileReader = require("./MediaFileReader");\r\n\r\n          var ID3v2FrameReader = require("./ID3v2FrameReader");\r\n\r\n          var ID3_HEADER_SIZE = 10;\r\n\r\n          var ID3v2TagReader = /*#__PURE__*/ (function (_MediaTagReader) {\r\n            _inherits(ID3v2TagReader, _MediaTagReader);\r\n\r\n            var _super = _createSuper(ID3v2TagReader);\r\n\r\n            function ID3v2TagReader() {\r\n              _classCallCheck(this, ID3v2TagReader);\r\n\r\n              return _super.apply(this, arguments);\r\n            }\r\n\r\n            _createClass(\r\n              ID3v2TagReader,\r\n              [\r\n                {\r\n                  key: "_loadData",\r\n                  value: function _loadData(mediaFileReader, callbacks) {\r\n                    mediaFileReader.loadRange([6, 9], {\r\n                      onSuccess: function onSuccess() {\r\n                        mediaFileReader.loadRange(\r\n                          // The tag size does not include the header size.\r\n                          [\r\n                            0,\r\n                            ID3_HEADER_SIZE +\r\n                              mediaFileReader.getSynchsafeInteger32At(6) -\r\n                              1,\r\n                          ],\r\n                          callbacks\r\n                        );\r\n                      },\r\n                      onError: callbacks.onError,\r\n                    });\r\n                  },\r\n                },\r\n                {\r\n                  key: "_parseData",\r\n                  value: function _parseData(data, tags) {\r\n                    var offset = 0;\r\n                    var major = data.getByteAt(offset + 3);\r\n\r\n                    if (major > 4) {\r\n                      return {\r\n                        type: "ID3",\r\n                        version: ">2.4",\r\n                        tags: {},\r\n                      };\r\n                    }\r\n\r\n                    var revision = data.getByteAt(offset + 4);\r\n                    var unsynch = data.isBitSetAt(offset + 5, 7);\r\n                    var xheader = data.isBitSetAt(offset + 5, 6);\r\n                    var xindicator = data.isBitSetAt(offset + 5, 5);\r\n                    var size = data.getSynchsafeInteger32At(offset + 6);\r\n                    offset += 10;\r\n\r\n                    if (xheader) {\r\n                      // We skip the extended header and don\'t offer support for it right now.\r\n                      if (major === 4) {\r\n                        var xheadersize = data.getSynchsafeInteger32At(offset);\r\n                        offset += xheadersize;\r\n                      } else {\r\n                        var xheadersize = data.getLongAt(offset, true); // The \'Extended header size\', currently 6 or 10 bytes, excludes itself.\r\n\r\n                        offset += xheadersize + 4;\r\n                      }\r\n                    }\r\n\r\n                    var id3 = {\r\n                      type: "ID3",\r\n                      version: "2." + major + "." + revision,\r\n                      major: major,\r\n                      revision: revision,\r\n                      flags: {\r\n                        unsynchronisation: unsynch,\r\n                        extended_header: xheader,\r\n                        experimental_indicator: xindicator,\r\n                        // TODO: footer_present\r\n                        footer_present: false,\r\n                      },\r\n                      size: size,\r\n                      tags: {},\r\n                    };\r\n\r\n                    if (tags) {\r\n                      var expandedTags = this._expandShortcutTags(tags);\r\n                    }\r\n\r\n                    var offsetEnd = size + 10; // When this flag is set the entire tag needs to be un-unsynchronised\r\n                    /*header size*/\r\n                    // before parsing each individual frame. Individual frame sizes might not\r\n                    // take unsynchronisation into consideration when it\'s set on the tag\r\n                    // header.\r\n\r\n                    if (id3.flags.unsynchronisation) {\r\n                      data = ID3v2FrameReader.getUnsyncFileReader(\r\n                        data,\r\n                        offset,\r\n                        size\r\n                      );\r\n                      offset = 0;\r\n                      offsetEnd = data.getSize();\r\n                    }\r\n\r\n                    var frames = ID3v2FrameReader.readFrames(\r\n                      offset,\r\n                      offsetEnd,\r\n                      data,\r\n                      id3,\r\n                      expandedTags\r\n                    ); // create shortcuts for most common data.\r\n\r\n                    for (var name in SHORTCUTS) {\r\n                      if (SHORTCUTS.hasOwnProperty(name)) {\r\n                        var frameData = this._getFrameData(\r\n                          frames,\r\n                          SHORTCUTS[name]\r\n                        );\r\n\r\n                        if (frameData) {\r\n                          id3.tags[name] = frameData;\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                    for (var frame in frames) {\r\n                      if (frames.hasOwnProperty(frame)) {\r\n                        id3.tags[frame] = frames[frame];\r\n                      }\r\n                    }\r\n\r\n                    return id3;\r\n                  },\r\n                },\r\n                {\r\n                  key: "_getFrameData",\r\n                  value: function _getFrameData(frames, ids) {\r\n                    var frame;\r\n\r\n                    for (var i = 0, id; (id = ids[i]); i++) {\r\n                      if (id in frames) {\r\n                        if (frames[id] instanceof Array) {\r\n                          frame = frames[id][0];\r\n                        } else {\r\n                          frame = frames[id];\r\n                        }\r\n\r\n                        return frame.data;\r\n                      }\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "getShortcuts",\r\n                  value: function getShortcuts() {\r\n                    return SHORTCUTS;\r\n                  },\r\n                },\r\n              ],\r\n              [\r\n                {\r\n                  key: "getTagIdentifierByteRange",\r\n                  value: function getTagIdentifierByteRange() {\r\n                    // ID3 header\r\n                    return {\r\n                      offset: 0,\r\n                      length: ID3_HEADER_SIZE,\r\n                    };\r\n                  },\r\n                },\r\n                {\r\n                  key: "canReadTagFormat",\r\n                  value: function canReadTagFormat(tagIdentifier) {\r\n                    var id = String.fromCharCode.apply(\r\n                      String,\r\n                      tagIdentifier.slice(0, 3)\r\n                    );\r\n                    return id === "ID3";\r\n                  },\r\n                },\r\n              ]\r\n            );\r\n\r\n            return ID3v2TagReader;\r\n          })(MediaTagReader);\r\n\r\n          var SHORTCUTS = {\r\n            title: ["TIT2", "TT2"],\r\n            artist: ["TPE1", "TP1"],\r\n            album: ["TALB", "TAL"],\r\n            year: ["TYER", "TYE"],\r\n            comment: ["COMM", "COM"],\r\n            track: ["TRCK", "TRK"],\r\n            genre: ["TCON", "TCO"],\r\n            picture: ["APIC", "PIC"],\r\n            lyrics: ["USLT", "ULT"],\r\n          };\r\n          module.exports = ID3v2TagReader;\r\n        },\r\n        {\r\n          "./ID3v2FrameReader": 8,\r\n          "./MediaFileReader": 11,\r\n          "./MediaTagReader": 12,\r\n        },\r\n      ],\r\n      10: [\r\n        function (require, module, exports) {\r\n          /**\r\n           * Support for iTunes-style m4a tags\r\n           * See:\r\n           *   http://atomicparsley.sourceforge.net/mpeg-4files.html\r\n           *   http://developer.apple.com/mac/library/documentation/QuickTime/QTFF/Metadata/Metadata.html\r\n           * Authored by Joshua Kifer <joshua.kifer gmail.com>\r\n           *\r\n           */\r\n          "use strict";\r\n\r\n          function _typeof(obj) {\r\n            "@babel/helpers - typeof";\r\n            if (\r\n              typeof Symbol === "function" &&\r\n              typeof Symbol.iterator === "symbol"\r\n            ) {\r\n              _typeof = function _typeof(obj) {\r\n                return typeof obj;\r\n              };\r\n            } else {\r\n              _typeof = function _typeof(obj) {\r\n                return obj &&\r\n                  typeof Symbol === "function" &&\r\n                  obj.constructor === Symbol &&\r\n                  obj !== Symbol.prototype\r\n                  ? "symbol"\r\n                  : typeof obj;\r\n              };\r\n            }\r\n            return _typeof(obj);\r\n          }\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _inherits(subClass, superClass) {\r\n            if (typeof superClass !== "function" && superClass !== null) {\r\n              throw new TypeError(\r\n                "Super expression must either be null or a function"\r\n              );\r\n            }\r\n            subClass.prototype = Object.create(\r\n              superClass && superClass.prototype,\r\n              {\r\n                constructor: {\r\n                  value: subClass,\r\n                  writable: true,\r\n                  configurable: true,\r\n                },\r\n              }\r\n            );\r\n            if (superClass) _setPrototypeOf(subClass, superClass);\r\n          }\r\n\r\n          function _setPrototypeOf(o, p) {\r\n            _setPrototypeOf =\r\n              Object.setPrototypeOf ||\r\n              function _setPrototypeOf(o, p) {\r\n                o.__proto__ = p;\r\n                return o;\r\n              };\r\n            return _setPrototypeOf(o, p);\r\n          }\r\n\r\n          function _createSuper(Derived) {\r\n            var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n            return function _createSuperInternal() {\r\n              var Super = _getPrototypeOf(Derived),\r\n                result;\r\n              if (hasNativeReflectConstruct) {\r\n                var NewTarget = _getPrototypeOf(this).constructor;\r\n                result = Reflect.construct(Super, arguments, NewTarget);\r\n              } else {\r\n                result = Super.apply(this, arguments);\r\n              }\r\n              return _possibleConstructorReturn(this, result);\r\n            };\r\n          }\r\n\r\n          function _possibleConstructorReturn(self, call) {\r\n            if (\r\n              call &&\r\n              (_typeof(call) === "object" || typeof call === "function")\r\n            ) {\r\n              return call;\r\n            }\r\n            return _assertThisInitialized(self);\r\n          }\r\n\r\n          function _assertThisInitialized(self) {\r\n            if (self === void 0) {\r\n              throw new ReferenceError(\r\n                "this hasn\'t been initialised - super() hasn\'t been called"\r\n              );\r\n            }\r\n            return self;\r\n          }\r\n\r\n          function _isNativeReflectConstruct() {\r\n            if (typeof Reflect === "undefined" || !Reflect.construct)\r\n              return false;\r\n            if (Reflect.construct.sham) return false;\r\n            if (typeof Proxy === "function") return true;\r\n            try {\r\n              Boolean.prototype.valueOf.call(\r\n                Reflect.construct(Boolean, [], function () {})\r\n              );\r\n              return true;\r\n            } catch (e) {\r\n              return false;\r\n            }\r\n          }\r\n\r\n          function _getPrototypeOf(o) {\r\n            _getPrototypeOf = Object.setPrototypeOf\r\n              ? Object.getPrototypeOf\r\n              : function _getPrototypeOf(o) {\r\n                  return o.__proto__ || Object.getPrototypeOf(o);\r\n                };\r\n            return _getPrototypeOf(o);\r\n          }\r\n\r\n          var MediaTagReader = require("./MediaTagReader");\r\n\r\n          var MediaFileReader = require("./MediaFileReader");\r\n\r\n          var MP4TagReader = /*#__PURE__*/ (function (_MediaTagReader) {\r\n            _inherits(MP4TagReader, _MediaTagReader);\r\n\r\n            var _super = _createSuper(MP4TagReader);\r\n\r\n            function MP4TagReader() {\r\n              _classCallCheck(this, MP4TagReader);\r\n\r\n              return _super.apply(this, arguments);\r\n            }\r\n\r\n            _createClass(\r\n              MP4TagReader,\r\n              [\r\n                {\r\n                  key: "_loadData",\r\n                  value: function _loadData(mediaFileReader, callbacks) {\r\n                    // MP4 metadata isn\'t located in a specific location of the file. Roughly\r\n                    // speaking, it\'s composed of blocks chained together like a linked list.\r\n                    // These blocks are called atoms (or boxes).\r\n                    // Each atom of the list can have its own child linked list. Atoms in this\r\n                    // situation do not possess any data and are called "container" as they only\r\n                    // contain other atoms.\r\n                    // Other atoms represent a particular set of data, like audio, video or\r\n                    // metadata. In order to find and load all the interesting atoms we need\r\n                    // to traverse the entire linked list of atoms and only load the ones\r\n                    // associated with metadata.\r\n                    // The metadata atoms can be find under the "moov.udta.meta.ilst" hierarchy.\r\n                    var self = this; // Load the header of the first atom\r\n\r\n                    mediaFileReader.loadRange([0, 16], {\r\n                      onSuccess: function onSuccess() {\r\n                        self._loadAtom(mediaFileReader, 0, "", callbacks);\r\n                      },\r\n                      onError: callbacks.onError,\r\n                    });\r\n                  },\r\n                },\r\n                {\r\n                  key: "_loadAtom",\r\n                  value: function _loadAtom(\r\n                    mediaFileReader,\r\n                    offset,\r\n                    parentAtomFullName,\r\n                    callbacks\r\n                  ) {\r\n                    if (offset >= mediaFileReader.getSize()) {\r\n                      callbacks.onSuccess();\r\n                      return;\r\n                    }\r\n\r\n                    var self = this; // 8 is the size of the atomSize and atomName fields.\r\n                    // When reading the current block we always read 8 more bytes in order\r\n                    // to also read the header of the next block.\r\n\r\n                    var atomSize = mediaFileReader.getLongAt(offset, true);\r\n\r\n                    if (atomSize == 0 || isNaN(atomSize)) {\r\n                      callbacks.onSuccess();\r\n                      return;\r\n                    }\r\n\r\n                    var atomName = mediaFileReader.getStringAt(offset + 4, 4); // console.log(parentAtomFullName, atomName, atomSize);\r\n                    // Container atoms (no actual data)\r\n\r\n                    if (this._isContainerAtom(atomName)) {\r\n                      if (atomName == "meta") {\r\n                        // The "meta" atom breaks convention and is a container with data.\r\n                        offset += 4; // next_item_id (uint32)\r\n                      }\r\n\r\n                      var atomFullName =\r\n                        (parentAtomFullName ? parentAtomFullName + "." : "") +\r\n                        atomName;\r\n\r\n                      if (atomFullName === "moov.udta.meta.ilst") {\r\n                        mediaFileReader.loadRange(\r\n                          [offset, offset + atomSize],\r\n                          callbacks\r\n                        );\r\n                      } else {\r\n                        mediaFileReader.loadRange(\r\n                          [offset + 8, offset + 8 + 8],\r\n                          {\r\n                            onSuccess: function onSuccess() {\r\n                              self._loadAtom(\r\n                                mediaFileReader,\r\n                                offset + 8,\r\n                                atomFullName,\r\n                                callbacks\r\n                              );\r\n                            },\r\n                            onError: callbacks.onError,\r\n                          }\r\n                        );\r\n                      }\r\n                    } else {\r\n                      mediaFileReader.loadRange(\r\n                        [offset + atomSize, offset + atomSize + 8],\r\n                        {\r\n                          onSuccess: function onSuccess() {\r\n                            self._loadAtom(\r\n                              mediaFileReader,\r\n                              offset + atomSize,\r\n                              parentAtomFullName,\r\n                              callbacks\r\n                            );\r\n                          },\r\n                          onError: callbacks.onError,\r\n                        }\r\n                      );\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "_isContainerAtom",\r\n                  value: function _isContainerAtom(atomName) {\r\n                    return (\r\n                      ["moov", "udta", "meta", "ilst"].indexOf(atomName) >= 0\r\n                    );\r\n                  },\r\n                },\r\n                {\r\n                  key: "_canReadAtom",\r\n                  value: function _canReadAtom(atomName) {\r\n                    return atomName !== "----";\r\n                  },\r\n                },\r\n                {\r\n                  key: "_parseData",\r\n                  value: function _parseData(data, tagsToRead) {\r\n                    var tags = {};\r\n                    tagsToRead = this._expandShortcutTags(tagsToRead);\r\n\r\n                    this._readAtom(tags, data, 0, data.getSize(), tagsToRead); // create shortcuts for most common data.\r\n\r\n                    for (var name in SHORTCUTS) {\r\n                      if (SHORTCUTS.hasOwnProperty(name)) {\r\n                        var tag = tags[SHORTCUTS[name]];\r\n\r\n                        if (tag) {\r\n                          if (name === "track") {\r\n                            tags[name] = tag.data.track;\r\n                          } else {\r\n                            tags[name] = tag.data;\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                    return {\r\n                      type: "MP4",\r\n                      ftyp: data.getStringAt(8, 4),\r\n                      version: data.getLongAt(12, true),\r\n                      tags: tags,\r\n                    };\r\n                  },\r\n                },\r\n                {\r\n                  key: "_readAtom",\r\n                  value: function _readAtom(\r\n                    tags,\r\n                    data,\r\n                    offset,\r\n                    length,\r\n                    tagsToRead,\r\n                    parentAtomFullName,\r\n                    indent\r\n                  ) {\r\n                    indent = indent === undefined ? "" : indent + "  ";\r\n                    var seek = offset;\r\n\r\n                    while (seek < offset + length) {\r\n                      var atomSize = data.getLongAt(seek, true);\r\n\r\n                      if (atomSize == 0) {\r\n                        return;\r\n                      }\r\n\r\n                      var atomName = data.getStringAt(seek + 4, 4); // console.log(seek, parentAtomFullName, atomName, atomSize);\r\n\r\n                      if (this._isContainerAtom(atomName)) {\r\n                        if (atomName == "meta") {\r\n                          seek += 4; // next_item_id (uint32)\r\n                        }\r\n\r\n                        var atomFullName =\r\n                          (parentAtomFullName ? parentAtomFullName + "." : "") +\r\n                          atomName;\r\n\r\n                        this._readAtom(\r\n                          tags,\r\n                          data,\r\n                          seek + 8,\r\n                          atomSize - 8,\r\n                          tagsToRead,\r\n                          atomFullName,\r\n                          indent\r\n                        );\r\n\r\n                        return;\r\n                      } // Value atoms\r\n\r\n                      if (\r\n                        (!tagsToRead || tagsToRead.indexOf(atomName) >= 0) &&\r\n                        parentAtomFullName === "moov.udta.meta.ilst" &&\r\n                        this._canReadAtom(atomName)\r\n                      ) {\r\n                        tags[atomName] = this._readMetadataAtom(data, seek);\r\n                      }\r\n\r\n                      seek += atomSize;\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "_readMetadataAtom",\r\n                  value: function _readMetadataAtom(data, offset) {\r\n                    // 16: size + name + size + "data" (4 bytes each)\r\n                    // 8: 1 byte atom version & 3 bytes atom flags + 4 bytes NULL space\r\n                    // 8: 4 bytes track + 4 bytes total\r\n                    var METADATA_HEADER = 16;\r\n                    var atomSize = data.getLongAt(offset, true);\r\n                    var atomName = data.getStringAt(offset + 4, 4);\r\n                    var klass = data.getInteger24At(\r\n                      offset + METADATA_HEADER + 1,\r\n                      true\r\n                    );\r\n                    var type = TYPES[klass];\r\n                    var atomData;\r\n                    var bigEndian = true;\r\n\r\n                    if (atomName == "trkn") {\r\n                      atomData = {\r\n                        track: data.getShortAt(\r\n                          offset + METADATA_HEADER + 10,\r\n                          bigEndian\r\n                        ),\r\n                        total: data.getShortAt(\r\n                          offset + METADATA_HEADER + 14,\r\n                          bigEndian\r\n                        ),\r\n                      };\r\n                    } else if (atomName == "disk") {\r\n                      atomData = {\r\n                        disk: data.getShortAt(\r\n                          offset + METADATA_HEADER + 10,\r\n                          bigEndian\r\n                        ),\r\n                        total: data.getShortAt(\r\n                          offset + METADATA_HEADER + 14,\r\n                          bigEndian\r\n                        ),\r\n                      };\r\n                    } else {\r\n                      // 4: atom version (1 byte) + atom flags (3 bytes)\r\n                      // 4: NULL (usually locale indicator)\r\n                      var atomHeader = METADATA_HEADER + 4 + 4;\r\n                      var dataStart = offset + atomHeader;\r\n                      var dataLength = atomSize - atomHeader;\r\n                      var atomData; // Workaround for covers being parsed as \'uint8\' type despite being an \'covr\' atom\r\n\r\n                      if (atomName === "covr" && type === "uint8") {\r\n                        type = "jpeg";\r\n                      }\r\n\r\n                      switch (type) {\r\n                        case "text":\r\n                          atomData = data\r\n                            .getStringWithCharsetAt(\r\n                              dataStart,\r\n                              dataLength,\r\n                              "utf-8"\r\n                            )\r\n                            .toString();\r\n                          break;\r\n\r\n                        case "uint8":\r\n                          atomData = data.getShortAt(dataStart, false);\r\n                          break;\r\n\r\n                        case "int":\r\n                        case "uint":\r\n                          // Though the QuickTime spec doesn\'t state it, there are 64-bit values\r\n                          // such as plID (Playlist/Collection ID). With its single 64-bit floating\r\n                          // point number type, these are hard to parse and pass in JavaScript.\r\n                          // The high word of plID seems to always be zero, so, as this is the\r\n                          // only current 64-bit atom handled, it is parsed from its 32-bit\r\n                          // low word as an unsigned long.\r\n                          //\r\n                          var intReader =\r\n                            type == "int"\r\n                              ? dataLength == 1\r\n                                ? data.getSByteAt\r\n                                : dataLength == 2\r\n                                ? data.getSShortAt\r\n                                : dataLength == 4\r\n                                ? data.getSLongAt\r\n                                : data.getLongAt\r\n                              : dataLength == 1\r\n                              ? data.getByteAt\r\n                              : dataLength == 2\r\n                              ? data.getShortAt\r\n                              : data.getLongAt; // $FlowFixMe - getByteAt doesn\'t receive a second argument\r\n\r\n                          atomData = intReader.call(\r\n                            data,\r\n                            dataStart + (dataLength == 8 ? 4 : 0),\r\n                            true\r\n                          );\r\n                          break;\r\n\r\n                        case "jpeg":\r\n                        case "png":\r\n                          atomData = {\r\n                            format: "image/" + type,\r\n                            data: data.getBytesAt(dataStart, dataLength),\r\n                          };\r\n                          break;\r\n                      }\r\n                    }\r\n\r\n                    return {\r\n                      id: atomName,\r\n                      size: atomSize,\r\n                      description: ATOM_DESCRIPTIONS[atomName] || "Unknown",\r\n                      data: atomData,\r\n                    };\r\n                  },\r\n                },\r\n                {\r\n                  key: "getShortcuts",\r\n                  value: function getShortcuts() {\r\n                    return SHORTCUTS;\r\n                  },\r\n                },\r\n              ],\r\n              [\r\n                {\r\n                  key: "getTagIdentifierByteRange",\r\n                  value: function getTagIdentifierByteRange() {\r\n                    // The tag identifier is located in [4, 8] but since we\'ll need to reader\r\n                    // the header of the first block anyway, we load it instead to avoid\r\n                    // making two requests.\r\n                    return {\r\n                      offset: 0,\r\n                      length: 16,\r\n                    };\r\n                  },\r\n                },\r\n                {\r\n                  key: "canReadTagFormat",\r\n                  value: function canReadTagFormat(tagIdentifier) {\r\n                    var id = String.fromCharCode.apply(\r\n                      String,\r\n                      tagIdentifier.slice(4, 8)\r\n                    );\r\n                    return id === "ftyp";\r\n                  },\r\n                },\r\n              ]\r\n            );\r\n\r\n            return MP4TagReader;\r\n          })(MediaTagReader);\r\n          /*\r\n           * https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\r\n           */\r\n\r\n          var TYPES = {\r\n            0: "uint8",\r\n            1: "text",\r\n            13: "jpeg",\r\n            14: "png",\r\n            21: "int",\r\n            22: "uint",\r\n          };\r\n          var ATOM_DESCRIPTIONS = {\r\n            "©alb": "Album",\r\n            "©ART": "Artist",\r\n            aART: "Album Artist",\r\n            "©day": "Release Date",\r\n            "©nam": "Title",\r\n            "©gen": "Genre",\r\n            gnre: "Genre",\r\n            trkn: "Track Number",\r\n            "©wrt": "Composer",\r\n            "©too": "Encoding Tool",\r\n            "©enc": "Encoded By",\r\n            cprt: "Copyright",\r\n            covr: "Cover Art",\r\n            "©grp": "Grouping",\r\n            keyw: "Keywords",\r\n            "©lyr": "Lyrics",\r\n            "©cmt": "Comment",\r\n            tmpo: "Tempo",\r\n            cpil: "Compilation",\r\n            disk: "Disc Number",\r\n            tvsh: "TV Show Name",\r\n            tven: "TV Episode ID",\r\n            tvsn: "TV Season",\r\n            tves: "TV Episode",\r\n            tvnn: "TV Network",\r\n            desc: "Description",\r\n            ldes: "Long Description",\r\n            sonm: "Sort Name",\r\n            soar: "Sort Artist",\r\n            soaa: "Sort Album",\r\n            soco: "Sort Composer",\r\n            sosn: "Sort Show",\r\n            purd: "Purchase Date",\r\n            pcst: "Podcast",\r\n            purl: "Podcast URL",\r\n            catg: "Category",\r\n            hdvd: "HD Video",\r\n            stik: "Media Type",\r\n            rtng: "Content Rating",\r\n            pgap: "Gapless Playback",\r\n            apID: "Purchase Account",\r\n            sfID: "Country Code",\r\n            atID: "Artist ID",\r\n            cnID: "Catalog ID",\r\n            plID: "Collection ID",\r\n            geID: "Genre ID",\r\n            "xid ": "Vendor Information",\r\n            flvr: "Codec Flavor",\r\n          };\r\n          var UNSUPPORTED_ATOMS = {\r\n            "----": 1,\r\n          };\r\n          var SHORTCUTS = {\r\n            title: "©nam",\r\n            artist: "©ART",\r\n            album: "©alb",\r\n            year: "©day",\r\n            comment: "©cmt",\r\n            track: "trkn",\r\n            genre: "©gen",\r\n            picture: "covr",\r\n            lyrics: "©lyr",\r\n          };\r\n          module.exports = MP4TagReader;\r\n        },\r\n        { "./MediaFileReader": 11, "./MediaTagReader": 12 },\r\n      ],\r\n      11: [\r\n        function (require, module, exports) {\r\n          "use strict";\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _defineProperty(obj, key, value) {\r\n            if (key in obj) {\r\n              Object.defineProperty(obj, key, {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true,\r\n              });\r\n            } else {\r\n              obj[key] = value;\r\n            }\r\n            return obj;\r\n          }\r\n\r\n          var StringUtils = require("./StringUtils");\r\n\r\n          var MediaFileReader = /*#__PURE__*/ (function () {\r\n            function MediaFileReader(path) {\r\n              _classCallCheck(this, MediaFileReader);\r\n\r\n              _defineProperty(this, "_isInitialized", void 0);\r\n\r\n              _defineProperty(this, "_size", void 0);\r\n\r\n              this._isInitialized = false;\r\n              this._size = 0;\r\n            }\r\n            /**\r\n             * Decides if this media file reader is able to read the given file.\r\n             */\r\n\r\n            _createClass(\r\n              MediaFileReader,\r\n              [\r\n                {\r\n                  key: "init",\r\n                  value:\r\n                    /**\r\n                     * This function needs to be called before any other function.\r\n                     * Loads the necessary initial information from the file.\r\n                     */\r\n                    function init(callbacks) {\r\n                      var self = this;\r\n\r\n                      if (this._isInitialized) {\r\n                        setTimeout(callbacks.onSuccess, 1);\r\n                      } else {\r\n                        return this._init({\r\n                          onSuccess: function onSuccess() {\r\n                            self._isInitialized = true;\r\n                            callbacks.onSuccess();\r\n                          },\r\n                          onError: callbacks.onError,\r\n                        });\r\n                      }\r\n                    },\r\n                },\r\n                {\r\n                  key: "_init",\r\n                  value: function _init(callbacks) {\r\n                    throw new Error("Must implement init function");\r\n                  },\r\n                  /**\r\n                   * @param range The start and end indexes of the range to load.\r\n                   *        Ex: [0, 7] load bytes 0 to 7 inclusive.\r\n                   */\r\n                },\r\n                {\r\n                  key: "loadRange",\r\n                  value: function loadRange(range, callbacks) {\r\n                    throw new Error("Must implement loadRange function");\r\n                  },\r\n                  /**\r\n                   * @return The size of the file in bytes.\r\n                   */\r\n                },\r\n                {\r\n                  key: "getSize",\r\n                  value: function getSize() {\r\n                    if (!this._isInitialized) {\r\n                      throw new Error("init() must be called first.");\r\n                    }\r\n\r\n                    return this._size;\r\n                  },\r\n                },\r\n                {\r\n                  key: "getByteAt",\r\n                  value: function getByteAt(offset) {\r\n                    throw new Error("Must implement getByteAt function");\r\n                  },\r\n                },\r\n                {\r\n                  key: "getBytesAt",\r\n                  value: function getBytesAt(offset, length) {\r\n                    var bytes = new Array(length);\r\n\r\n                    for (var i = 0; i < length; i++) {\r\n                      bytes[i] = this.getByteAt(offset + i);\r\n                    }\r\n\r\n                    return bytes;\r\n                  },\r\n                },\r\n                {\r\n                  key: "isBitSetAt",\r\n                  value: function isBitSetAt(offset, bit) {\r\n                    var iByte = this.getByteAt(offset);\r\n                    return (iByte & (1 << bit)) != 0;\r\n                  },\r\n                },\r\n                {\r\n                  key: "getSByteAt",\r\n                  value: function getSByteAt(offset) {\r\n                    var iByte = this.getByteAt(offset);\r\n\r\n                    if (iByte > 127) {\r\n                      return iByte - 256;\r\n                    } else {\r\n                      return iByte;\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "getShortAt",\r\n                  value: function getShortAt(offset, isBigEndian) {\r\n                    var iShort = isBigEndian\r\n                      ? (this.getByteAt(offset) << 8) +\r\n                        this.getByteAt(offset + 1)\r\n                      : (this.getByteAt(offset + 1) << 8) +\r\n                        this.getByteAt(offset);\r\n\r\n                    if (iShort < 0) {\r\n                      iShort += 65536;\r\n                    }\r\n\r\n                    return iShort;\r\n                  },\r\n                },\r\n                {\r\n                  key: "getSShortAt",\r\n                  value: function getSShortAt(offset, isBigEndian) {\r\n                    var iUShort = this.getShortAt(offset, isBigEndian);\r\n\r\n                    if (iUShort > 32767) {\r\n                      return iUShort - 65536;\r\n                    } else {\r\n                      return iUShort;\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "getLongAt",\r\n                  value: function getLongAt(offset, isBigEndian) {\r\n                    var iByte1 = this.getByteAt(offset),\r\n                      iByte2 = this.getByteAt(offset + 1),\r\n                      iByte3 = this.getByteAt(offset + 2),\r\n                      iByte4 = this.getByteAt(offset + 3);\r\n                    var iLong = isBigEndian\r\n                      ? (((((iByte1 << 8) + iByte2) << 8) + iByte3) << 8) +\r\n                        iByte4\r\n                      : (((((iByte4 << 8) + iByte3) << 8) + iByte2) << 8) +\r\n                        iByte1;\r\n\r\n                    if (iLong < 0) {\r\n                      iLong += 4294967296;\r\n                    }\r\n\r\n                    return iLong;\r\n                  },\r\n                },\r\n                {\r\n                  key: "getSLongAt",\r\n                  value: function getSLongAt(offset, isBigEndian) {\r\n                    var iULong = this.getLongAt(offset, isBigEndian);\r\n\r\n                    if (iULong > 2147483647) {\r\n                      return iULong - 4294967296;\r\n                    } else {\r\n                      return iULong;\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "getInteger24At",\r\n                  value: function getInteger24At(offset, isBigEndian) {\r\n                    var iByte1 = this.getByteAt(offset),\r\n                      iByte2 = this.getByteAt(offset + 1),\r\n                      iByte3 = this.getByteAt(offset + 2);\r\n                    var iInteger = isBigEndian\r\n                      ? (((iByte1 << 8) + iByte2) << 8) + iByte3\r\n                      : (((iByte3 << 8) + iByte2) << 8) + iByte1;\r\n\r\n                    if (iInteger < 0) {\r\n                      iInteger += 16777216;\r\n                    }\r\n\r\n                    return iInteger;\r\n                  },\r\n                },\r\n                {\r\n                  key: "getStringAt",\r\n                  value: function getStringAt(offset, length) {\r\n                    var string = [];\r\n\r\n                    for (var i = offset, j = 0; i < offset + length; i++, j++) {\r\n                      string[j] = String.fromCharCode(this.getByteAt(i));\r\n                    }\r\n\r\n                    return string.join("");\r\n                  },\r\n                },\r\n                {\r\n                  key: "getStringWithCharsetAt",\r\n                  value: function getStringWithCharsetAt(\r\n                    offset,\r\n                    length,\r\n                    charset\r\n                  ) {\r\n                    var bytes = this.getBytesAt(offset, length);\r\n                    var string;\r\n\r\n                    switch ((charset || "").toLowerCase()) {\r\n                      case "utf-16":\r\n                      case "utf-16le":\r\n                      case "utf-16be":\r\n                        string = StringUtils.readUTF16String(\r\n                          bytes,\r\n                          charset === "utf-16be"\r\n                        );\r\n                        break;\r\n\r\n                      case "utf-8":\r\n                        string = StringUtils.readUTF8String(bytes);\r\n                        break;\r\n\r\n                      default:\r\n                        string = StringUtils.readNullTerminatedString(bytes);\r\n                        break;\r\n                    }\r\n\r\n                    return string;\r\n                  },\r\n                },\r\n                {\r\n                  key: "getCharAt",\r\n                  value: function getCharAt(offset) {\r\n                    return String.fromCharCode(this.getByteAt(offset));\r\n                  },\r\n                  /**\r\n                   * The ID3v2 tag/frame size is encoded with four bytes where the most\r\n                   * significant bit (bit 7) is set to zero in every byte, making a total of 28\r\n                   * bits. The zeroed bits are ignored, so a 257 bytes long tag is represented\r\n                   * as $00 00 02 01.\r\n                   */\r\n                },\r\n                {\r\n                  key: "getSynchsafeInteger32At",\r\n                  value: function getSynchsafeInteger32At(offset) {\r\n                    var size1 = this.getByteAt(offset);\r\n                    var size2 = this.getByteAt(offset + 1);\r\n                    var size3 = this.getByteAt(offset + 2);\r\n                    var size4 = this.getByteAt(offset + 3); // 0x7f = 0b01111111\r\n\r\n                    var size =\r\n                      (size4 & 0x7f) |\r\n                      ((size3 & 0x7f) << 7) |\r\n                      ((size2 & 0x7f) << 14) |\r\n                      ((size1 & 0x7f) << 21);\r\n                    return size;\r\n                  },\r\n                },\r\n              ],\r\n              [\r\n                {\r\n                  key: "canReadFile",\r\n                  value: function canReadFile(file) {\r\n                    throw new Error("Must implement canReadFile function");\r\n                  },\r\n                },\r\n              ]\r\n            );\r\n\r\n            return MediaFileReader;\r\n          })();\r\n\r\n          module.exports = MediaFileReader;\r\n        },\r\n        { "./StringUtils": 13 },\r\n      ],\r\n      12: [\r\n        function (require, module, exports) {\r\n          "use strict";\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _defineProperty(obj, key, value) {\r\n            if (key in obj) {\r\n              Object.defineProperty(obj, key, {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true,\r\n              });\r\n            } else {\r\n              obj[key] = value;\r\n            }\r\n            return obj;\r\n          }\r\n\r\n          var MediaFileReader = require("./MediaFileReader");\r\n\r\n          var MediaTagReader = /*#__PURE__*/ (function () {\r\n            function MediaTagReader(mediaFileReader) {\r\n              _classCallCheck(this, MediaTagReader);\r\n\r\n              _defineProperty(this, "_mediaFileReader", void 0);\r\n\r\n              _defineProperty(this, "_tags", void 0);\r\n\r\n              this._mediaFileReader = mediaFileReader;\r\n              this._tags = null;\r\n            }\r\n            /**\r\n             * Returns the byte range that needs to be loaded and fed to\r\n             * _canReadTagFormat in order to identify if the file contains tag\r\n             * information that can be read.\r\n             */\r\n\r\n            _createClass(\r\n              MediaTagReader,\r\n              [\r\n                {\r\n                  key: "setTagsToRead",\r\n                  value: function setTagsToRead(tags) {\r\n                    this._tags = tags;\r\n                    return this;\r\n                  },\r\n                },\r\n                {\r\n                  key: "read",\r\n                  value: function read(callbacks) {\r\n                    var self = this;\r\n\r\n                    this._mediaFileReader.init({\r\n                      onSuccess: function onSuccess() {\r\n                        self._loadData(self._mediaFileReader, {\r\n                          onSuccess: function onSuccess() {\r\n                            try {\r\n                              var tags = self._parseData(\r\n                                self._mediaFileReader,\r\n                                self._tags\r\n                              );\r\n                            } catch (ex) {\r\n                              if (callbacks.onError) {\r\n                                callbacks.onError({\r\n                                  type: "parseData",\r\n                                  info: ex.message,\r\n                                });\r\n                                return;\r\n                              }\r\n                            } // TODO: destroy mediaFileReader\r\n\r\n                            callbacks.onSuccess(tags);\r\n                          },\r\n                          onError: callbacks.onError,\r\n                        });\r\n                      },\r\n                      onError: callbacks.onError,\r\n                    });\r\n                  },\r\n                },\r\n                {\r\n                  key: "getShortcuts",\r\n                  value: function getShortcuts() {\r\n                    return {};\r\n                  },\r\n                  /**\r\n                   * Load the necessary bytes from the media file.\r\n                   */\r\n                },\r\n                {\r\n                  key: "_loadData",\r\n                  value: function _loadData(mediaFileReader, callbacks) {\r\n                    throw new Error("Must implement _loadData function");\r\n                  },\r\n                  /**\r\n                   * Parse the loaded data to read the media tags.\r\n                   */\r\n                },\r\n                {\r\n                  key: "_parseData",\r\n                  value: function _parseData(mediaFileReader, tags) {\r\n                    throw new Error("Must implement _parseData function");\r\n                  },\r\n                },\r\n                {\r\n                  key: "_expandShortcutTags",\r\n                  value: function _expandShortcutTags(tagsWithShortcuts) {\r\n                    if (!tagsWithShortcuts) {\r\n                      return null;\r\n                    }\r\n\r\n                    var tags = [];\r\n                    var shortcuts = this.getShortcuts();\r\n\r\n                    for (\r\n                      var i = 0, tagOrShortcut;\r\n                      (tagOrShortcut = tagsWithShortcuts[i]);\r\n                      i++\r\n                    ) {\r\n                      tags = tags.concat(\r\n                        shortcuts[tagOrShortcut] || [tagOrShortcut]\r\n                      );\r\n                    }\r\n\r\n                    return tags;\r\n                  },\r\n                },\r\n              ],\r\n              [\r\n                {\r\n                  key: "getTagIdentifierByteRange",\r\n                  value: function getTagIdentifierByteRange() {\r\n                    throw new Error("Must implement");\r\n                  },\r\n                  /**\r\n                   * Given a tag identifier (read from the file byte positions speficied by\r\n                   * getTagIdentifierByteRange) this function checks if it can read the tag\r\n                   * format or not.\r\n                   */\r\n                },\r\n                {\r\n                  key: "canReadTagFormat",\r\n                  value: function canReadTagFormat(tagIdentifier) {\r\n                    throw new Error("Must implement");\r\n                  },\r\n                },\r\n              ]\r\n            );\r\n\r\n            return MediaTagReader;\r\n          })();\r\n\r\n          module.exports = MediaTagReader;\r\n        },\r\n        { "./MediaFileReader": 11 },\r\n      ],\r\n      13: [\r\n        function (require, module, exports) {\r\n          "use strict";\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _defineProperty(obj, key, value) {\r\n            if (key in obj) {\r\n              Object.defineProperty(obj, key, {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true,\r\n              });\r\n            } else {\r\n              obj[key] = value;\r\n            }\r\n            return obj;\r\n          }\r\n\r\n          var InternalDecodedString = /*#__PURE__*/ (function () {\r\n            function InternalDecodedString(value, bytesReadCount) {\r\n              _classCallCheck(this, InternalDecodedString);\r\n\r\n              _defineProperty(this, "_value", void 0);\r\n\r\n              _defineProperty(this, "bytesReadCount", void 0);\r\n\r\n              _defineProperty(this, "length", void 0);\r\n\r\n              this._value = value;\r\n              this.bytesReadCount = bytesReadCount;\r\n              this.length = value.length;\r\n            }\r\n\r\n            _createClass(InternalDecodedString, [\r\n              {\r\n                key: "toString",\r\n                value: function toString() {\r\n                  return this._value;\r\n                },\r\n              },\r\n            ]);\r\n\r\n            return InternalDecodedString;\r\n          })();\r\n\r\n          var StringUtils = {\r\n            readUTF16String: function readUTF16String(\r\n              bytes,\r\n              bigEndian,\r\n              maxBytes\r\n            ) {\r\n              var ix = 0;\r\n              var offset1 = 1,\r\n                offset2 = 0;\r\n              maxBytes = Math.min(maxBytes || bytes.length, bytes.length);\r\n\r\n              if (bytes[0] == 0xfe && bytes[1] == 0xff) {\r\n                bigEndian = true;\r\n                ix = 2;\r\n              } else if (bytes[0] == 0xff && bytes[1] == 0xfe) {\r\n                bigEndian = false;\r\n                ix = 2;\r\n              }\r\n\r\n              if (bigEndian) {\r\n                offset1 = 0;\r\n                offset2 = 1;\r\n              }\r\n\r\n              var arr = [];\r\n\r\n              for (var j = 0; ix < maxBytes; j++) {\r\n                var byte1 = bytes[ix + offset1];\r\n                var byte2 = bytes[ix + offset2];\r\n                var word1 = (byte1 << 8) + byte2;\r\n                ix += 2;\r\n\r\n                if (word1 == 0x0000) {\r\n                  break;\r\n                } else if (byte1 < 0xd8 || byte1 >= 0xe0) {\r\n                  arr[j] = String.fromCharCode(word1);\r\n                } else {\r\n                  var byte3 = bytes[ix + offset1];\r\n                  var byte4 = bytes[ix + offset2];\r\n                  var word2 = (byte3 << 8) + byte4;\r\n                  ix += 2;\r\n                  arr[j] = String.fromCharCode(word1, word2);\r\n                }\r\n              }\r\n\r\n              return new InternalDecodedString(arr.join(""), ix);\r\n            },\r\n            readUTF8String: function readUTF8String(bytes, maxBytes) {\r\n              var ix = 0;\r\n              maxBytes = Math.min(maxBytes || bytes.length, bytes.length);\r\n\r\n              if (bytes[0] == 0xef && bytes[1] == 0xbb && bytes[2] == 0xbf) {\r\n                ix = 3;\r\n              }\r\n\r\n              var arr = [];\r\n\r\n              for (var j = 0; ix < maxBytes; j++) {\r\n                var byte1 = bytes[ix++];\r\n\r\n                if (byte1 == 0x00) {\r\n                  break;\r\n                } else if (byte1 < 0x80) {\r\n                  arr[j] = String.fromCharCode(byte1);\r\n                } else if (byte1 >= 0xc2 && byte1 < 0xe0) {\r\n                  var byte2 = bytes[ix++];\r\n                  arr[j] = String.fromCharCode(\r\n                    ((byte1 & 0x1f) << 6) + (byte2 & 0x3f)\r\n                  );\r\n                } else if (byte1 >= 0xe0 && byte1 < 0xf0) {\r\n                  var byte2 = bytes[ix++];\r\n                  var byte3 = bytes[ix++];\r\n                  arr[j] = String.fromCharCode(\r\n                    ((byte1 & 0xff) << 12) +\r\n                      ((byte2 & 0x3f) << 6) +\r\n                      (byte3 & 0x3f)\r\n                  );\r\n                } else if (byte1 >= 0xf0 && byte1 < 0xf5) {\r\n                  var byte2 = bytes[ix++];\r\n                  var byte3 = bytes[ix++];\r\n                  var byte4 = bytes[ix++];\r\n                  var codepoint =\r\n                    ((byte1 & 0x07) << 18) +\r\n                    ((byte2 & 0x3f) << 12) +\r\n                    ((byte3 & 0x3f) << 6) +\r\n                    (byte4 & 0x3f) -\r\n                    0x10000;\r\n                  arr[j] = String.fromCharCode(\r\n                    (codepoint >> 10) + 0xd800,\r\n                    (codepoint & 0x3ff) + 0xdc00\r\n                  );\r\n                }\r\n              }\r\n\r\n              return new InternalDecodedString(arr.join(""), ix);\r\n            },\r\n            readNullTerminatedString: function readNullTerminatedString(\r\n              bytes,\r\n              maxBytes\r\n            ) {\r\n              var arr = [];\r\n              maxBytes = maxBytes || bytes.length;\r\n\r\n              for (var i = 0; i < maxBytes; ) {\r\n                var byte1 = bytes[i++];\r\n\r\n                if (byte1 == 0x00) {\r\n                  break;\r\n                }\r\n\r\n                arr[i - 1] = String.fromCharCode(byte1);\r\n              }\r\n\r\n              return new InternalDecodedString(arr.join(""), i);\r\n            },\r\n          };\r\n          module.exports = StringUtils;\r\n        },\r\n        {},\r\n      ],\r\n      14: [\r\n        function (require, module, exports) {\r\n          "use strict";\r\n\r\n          function _typeof(obj) {\r\n            "@babel/helpers - typeof";\r\n            if (\r\n              typeof Symbol === "function" &&\r\n              typeof Symbol.iterator === "symbol"\r\n            ) {\r\n              _typeof = function _typeof(obj) {\r\n                return typeof obj;\r\n              };\r\n            } else {\r\n              _typeof = function _typeof(obj) {\r\n                return obj &&\r\n                  typeof Symbol === "function" &&\r\n                  obj.constructor === Symbol &&\r\n                  obj !== Symbol.prototype\r\n                  ? "symbol"\r\n                  : typeof obj;\r\n              };\r\n            }\r\n            return _typeof(obj);\r\n          }\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _inherits(subClass, superClass) {\r\n            if (typeof superClass !== "function" && superClass !== null) {\r\n              throw new TypeError(\r\n                "Super expression must either be null or a function"\r\n              );\r\n            }\r\n            subClass.prototype = Object.create(\r\n              superClass && superClass.prototype,\r\n              {\r\n                constructor: {\r\n                  value: subClass,\r\n                  writable: true,\r\n                  configurable: true,\r\n                },\r\n              }\r\n            );\r\n            if (superClass) _setPrototypeOf(subClass, superClass);\r\n          }\r\n\r\n          function _setPrototypeOf(o, p) {\r\n            _setPrototypeOf =\r\n              Object.setPrototypeOf ||\r\n              function _setPrototypeOf(o, p) {\r\n                o.__proto__ = p;\r\n                return o;\r\n              };\r\n            return _setPrototypeOf(o, p);\r\n          }\r\n\r\n          function _createSuper(Derived) {\r\n            var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n            return function _createSuperInternal() {\r\n              var Super = _getPrototypeOf(Derived),\r\n                result;\r\n              if (hasNativeReflectConstruct) {\r\n                var NewTarget = _getPrototypeOf(this).constructor;\r\n                result = Reflect.construct(Super, arguments, NewTarget);\r\n              } else {\r\n                result = Super.apply(this, arguments);\r\n              }\r\n              return _possibleConstructorReturn(this, result);\r\n            };\r\n          }\r\n\r\n          function _possibleConstructorReturn(self, call) {\r\n            if (\r\n              call &&\r\n              (_typeof(call) === "object" || typeof call === "function")\r\n            ) {\r\n              return call;\r\n            }\r\n            return _assertThisInitialized(self);\r\n          }\r\n\r\n          function _assertThisInitialized(self) {\r\n            if (self === void 0) {\r\n              throw new ReferenceError(\r\n                "this hasn\'t been initialised - super() hasn\'t been called"\r\n              );\r\n            }\r\n            return self;\r\n          }\r\n\r\n          function _isNativeReflectConstruct() {\r\n            if (typeof Reflect === "undefined" || !Reflect.construct)\r\n              return false;\r\n            if (Reflect.construct.sham) return false;\r\n            if (typeof Proxy === "function") return true;\r\n            try {\r\n              Boolean.prototype.valueOf.call(\r\n                Reflect.construct(Boolean, [], function () {})\r\n              );\r\n              return true;\r\n            } catch (e) {\r\n              return false;\r\n            }\r\n          }\r\n\r\n          function _getPrototypeOf(o) {\r\n            _getPrototypeOf = Object.setPrototypeOf\r\n              ? Object.getPrototypeOf\r\n              : function _getPrototypeOf(o) {\r\n                  return o.__proto__ || Object.getPrototypeOf(o);\r\n                };\r\n            return _getPrototypeOf(o);\r\n          }\r\n\r\n          function _defineProperty(obj, key, value) {\r\n            if (key in obj) {\r\n              Object.defineProperty(obj, key, {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true,\r\n              });\r\n            } else {\r\n              obj[key] = value;\r\n            }\r\n            return obj;\r\n          }\r\n\r\n          var ChunkedFileData = require("./ChunkedFileData");\r\n\r\n          var MediaFileReader = require("./MediaFileReader");\r\n\r\n          var CHUNK_SIZE = 1024;\r\n\r\n          var XhrFileReader = /*#__PURE__*/ (function (_MediaFileReader) {\r\n            _inherits(XhrFileReader, _MediaFileReader);\r\n\r\n            var _super = _createSuper(XhrFileReader);\r\n\r\n            function XhrFileReader(url) {\r\n              var _this;\r\n\r\n              _classCallCheck(this, XhrFileReader);\r\n\r\n              _this = _super.call(this);\r\n\r\n              _defineProperty(_assertThisInitialized(_this), "_url", void 0);\r\n\r\n              _defineProperty(\r\n                _assertThisInitialized(_this),\r\n                "_fileData",\r\n                void 0\r\n              );\r\n\r\n              _this._url = url;\r\n              _this._fileData = new ChunkedFileData();\r\n              return _this;\r\n            }\r\n\r\n            _createClass(\r\n              XhrFileReader,\r\n              [\r\n                {\r\n                  key: "_init",\r\n                  value: function _init(callbacks) {\r\n                    if (XhrFileReader._config.avoidHeadRequests) {\r\n                      this._fetchSizeWithGetRequest(callbacks);\r\n                    } else {\r\n                      this._fetchSizeWithHeadRequest(callbacks);\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "_fetchSizeWithHeadRequest",\r\n                  value: function _fetchSizeWithHeadRequest(callbacks) {\r\n                    var self = this;\r\n\r\n                    this._makeXHRRequest("HEAD", null, {\r\n                      onSuccess: function onSuccess(xhr) {\r\n                        var contentLength = self._parseContentLength(xhr);\r\n\r\n                        if (contentLength) {\r\n                          self._size = contentLength;\r\n                          callbacks.onSuccess();\r\n                        } else {\r\n                          // Content-Length not provided by the server, fallback to\r\n                          // GET requests.\r\n                          self._fetchSizeWithGetRequest(callbacks);\r\n                        }\r\n                      },\r\n                      onError: callbacks.onError,\r\n                    });\r\n                  },\r\n                },\r\n                {\r\n                  key: "_fetchSizeWithGetRequest",\r\n                  value: function _fetchSizeWithGetRequest(callbacks) {\r\n                    var self = this;\r\n\r\n                    var range = this._roundRangeToChunkMultiple([0, 0]);\r\n\r\n                    this._makeXHRRequest("GET", range, {\r\n                      onSuccess: function onSuccess(xhr) {\r\n                        var contentRange = self._parseContentRange(xhr);\r\n\r\n                        var data = self._getXhrResponseContent(xhr);\r\n\r\n                        if (contentRange) {\r\n                          if (contentRange.instanceLength == null) {\r\n                            // Last resort, server is not able to tell us the content length,\r\n                            // need to fetch entire file then.\r\n                            self._fetchEntireFile(callbacks);\r\n\r\n                            return;\r\n                          }\r\n\r\n                          self._size = contentRange.instanceLength;\r\n                        } else {\r\n                          // Range request not supported, we got the entire file\r\n                          self._size = data.length;\r\n                        }\r\n\r\n                        self._fileData.addData(0, data);\r\n\r\n                        callbacks.onSuccess();\r\n                      },\r\n                      onError: callbacks.onError,\r\n                    });\r\n                  },\r\n                },\r\n                {\r\n                  key: "_fetchEntireFile",\r\n                  value: function _fetchEntireFile(callbacks) {\r\n                    var self = this;\r\n\r\n                    this._makeXHRRequest("GET", null, {\r\n                      onSuccess: function onSuccess(xhr) {\r\n                        var data = self._getXhrResponseContent(xhr);\r\n\r\n                        self._size = data.length;\r\n\r\n                        self._fileData.addData(0, data);\r\n\r\n                        callbacks.onSuccess();\r\n                      },\r\n                      onError: callbacks.onError,\r\n                    });\r\n                  },\r\n                },\r\n                {\r\n                  key: "_getXhrResponseContent",\r\n                  value: function _getXhrResponseContent(xhr) {\r\n                    return xhr.responseBody || xhr.responseText || "";\r\n                  },\r\n                },\r\n                {\r\n                  key: "_parseContentLength",\r\n                  value: function _parseContentLength(xhr) {\r\n                    var contentLength = this._getResponseHeader(\r\n                      xhr,\r\n                      "Content-Length"\r\n                    );\r\n\r\n                    if (contentLength == null) {\r\n                      return contentLength;\r\n                    } else {\r\n                      return parseInt(contentLength, 10);\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "_parseContentRange",\r\n                  value: function _parseContentRange(xhr) {\r\n                    var contentRange = this._getResponseHeader(\r\n                      xhr,\r\n                      "Content-Range"\r\n                    );\r\n\r\n                    if (contentRange) {\r\n                      var parsedContentRange = contentRange.match(\r\n                        /bytes (\\d+)-(\\d+)\\/(?:(\\d+)|\\*)/i\r\n                      );\r\n\r\n                      if (!parsedContentRange) {\r\n                        throw new Error(\r\n                          "FIXME: Unknown Content-Range syntax: " + contentRange\r\n                        );\r\n                      }\r\n\r\n                      return {\r\n                        firstBytePosition: parseInt(parsedContentRange[1], 10),\r\n                        lastBytePosition: parseInt(parsedContentRange[2], 10),\r\n                        instanceLength: parsedContentRange[3]\r\n                          ? parseInt(parsedContentRange[3], 10)\r\n                          : null,\r\n                      };\r\n                    } else {\r\n                      return null;\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "loadRange",\r\n                  value: function loadRange(range, callbacks) {\r\n                    var self = this;\r\n\r\n                    if (\r\n                      self._fileData.hasDataRange(\r\n                        range[0],\r\n                        Math.min(self._size, range[1])\r\n                      )\r\n                    ) {\r\n                      setTimeout(callbacks.onSuccess, 1);\r\n                      return;\r\n                    } // Always download in multiples of CHUNK_SIZE. If we\'re going to make a\r\n                    // request might as well get a chunk that makes sense. The big cost is\r\n                    // establishing the connection so getting 10bytes or 1K doesn\'t really\r\n                    // make a difference.\r\n\r\n                    range = this._roundRangeToChunkMultiple(range); // Upper range should not be greater than max file size\r\n\r\n                    range[1] = Math.min(self._size, range[1]);\r\n\r\n                    this._makeXHRRequest("GET", range, {\r\n                      onSuccess: function onSuccess(xhr) {\r\n                        var data = self._getXhrResponseContent(xhr);\r\n\r\n                        self._fileData.addData(range[0], data);\r\n\r\n                        callbacks.onSuccess();\r\n                      },\r\n                      onError: callbacks.onError,\r\n                    });\r\n                  },\r\n                },\r\n                {\r\n                  key: "_roundRangeToChunkMultiple",\r\n                  value: function _roundRangeToChunkMultiple(range) {\r\n                    var length = range[1] - range[0] + 1;\r\n                    var newLength = Math.ceil(length / CHUNK_SIZE) * CHUNK_SIZE;\r\n                    return [range[0], range[0] + newLength - 1];\r\n                  },\r\n                },\r\n                {\r\n                  key: "_makeXHRRequest",\r\n                  value: function _makeXHRRequest(method, range, callbacks) {\r\n                    var xhr = this._createXHRObject();\r\n\r\n                    xhr.open(method, this._url);\r\n\r\n                    var onXHRLoad = function onXHRLoad() {\r\n                      // 200 - OK\r\n                      // 206 - Partial Content\r\n                      // $FlowIssue - xhr will not be null here\r\n                      if (xhr.status === 200 || xhr.status === 206) {\r\n                        callbacks.onSuccess(xhr);\r\n                      } else if (callbacks.onError) {\r\n                        callbacks.onError({\r\n                          type: "xhr",\r\n                          info: "Unexpected HTTP status " + xhr.status + ".",\r\n                          xhr: xhr,\r\n                        });\r\n                      }\r\n\r\n                      xhr = null;\r\n                    };\r\n\r\n                    if (typeof xhr.onload !== "undefined") {\r\n                      xhr.onload = onXHRLoad;\r\n\r\n                      xhr.onerror = function () {\r\n                        if (callbacks.onError) {\r\n                          callbacks.onError({\r\n                            type: "xhr",\r\n                            info: "Generic XHR error, check xhr object.",\r\n                            xhr: xhr,\r\n                          });\r\n                        }\r\n                      };\r\n                    } else {\r\n                      xhr.onreadystatechange = function () {\r\n                        // $FlowIssue - xhr will not be null here\r\n                        if (xhr.readyState === 4) {\r\n                          onXHRLoad();\r\n                        }\r\n                      };\r\n                    }\r\n\r\n                    if (XhrFileReader._config.timeoutInSec) {\r\n                      xhr.timeout = XhrFileReader._config.timeoutInSec * 1000;\r\n\r\n                      xhr.ontimeout = function () {\r\n                        if (callbacks.onError) {\r\n                          callbacks.onError({\r\n                            type: "xhr",\r\n                            // $FlowIssue - xhr.timeout will not be null\r\n                            info:\r\n                              "Timeout after " +\r\n                              xhr.timeout / 1000 +\r\n                              "s. Use jsmediatags.Config.setXhrTimeout to override.",\r\n                            xhr: xhr,\r\n                          });\r\n                        }\r\n                      };\r\n                    }\r\n\r\n                    xhr.overrideMimeType("text/plain; charset=x-user-defined");\r\n\r\n                    if (range) {\r\n                      this._setRequestHeader(\r\n                        xhr,\r\n                        "Range",\r\n                        "bytes=" + range[0] + "-" + range[1]\r\n                      );\r\n                    }\r\n\r\n                    this._setRequestHeader(\r\n                      xhr,\r\n                      "If-Modified-Since",\r\n                      "Sat, 01 Jan 1970 00:00:00 GMT"\r\n                    );\r\n\r\n                    xhr.send(null);\r\n                  },\r\n                },\r\n                {\r\n                  key: "_setRequestHeader",\r\n                  value: function _setRequestHeader(\r\n                    xhr,\r\n                    headerName,\r\n                    headerValue\r\n                  ) {\r\n                    if (\r\n                      XhrFileReader._config.disallowedXhrHeaders.indexOf(\r\n                        headerName.toLowerCase()\r\n                      ) < 0\r\n                    ) {\r\n                      xhr.setRequestHeader(headerName, headerValue);\r\n                    }\r\n                  },\r\n                },\r\n                {\r\n                  key: "_hasResponseHeader",\r\n                  value: function _hasResponseHeader(xhr, headerName) {\r\n                    var allResponseHeaders = xhr.getAllResponseHeaders();\r\n\r\n                    if (!allResponseHeaders) {\r\n                      return false;\r\n                    }\r\n\r\n                    var headers = allResponseHeaders.split("\\r\\n");\r\n                    var headerNames = [];\r\n\r\n                    for (var i = 0; i < headers.length; i++) {\r\n                      headerNames[i] = headers[i].split(":")[0].toLowerCase();\r\n                    }\r\n\r\n                    return headerNames.indexOf(headerName.toLowerCase()) >= 0;\r\n                  },\r\n                },\r\n                {\r\n                  key: "_getResponseHeader",\r\n                  value: function _getResponseHeader(xhr, headerName) {\r\n                    if (!this._hasResponseHeader(xhr, headerName)) {\r\n                      return null;\r\n                    }\r\n\r\n                    return xhr.getResponseHeader(headerName);\r\n                  },\r\n                },\r\n                {\r\n                  key: "getByteAt",\r\n                  value: function getByteAt(offset) {\r\n                    var character = this._fileData.getByteAt(offset);\r\n\r\n                    return character.charCodeAt(0) & 0xff;\r\n                  },\r\n                },\r\n                {\r\n                  key: "_isWebWorker",\r\n                  value: function _isWebWorker() {\r\n                    return (\r\n                      typeof WorkerGlobalScope !== "undefined" &&\r\n                      self instanceof WorkerGlobalScope\r\n                    );\r\n                  },\r\n                },\r\n                {\r\n                  key: "_createXHRObject",\r\n                  value: function _createXHRObject() {\r\n                    if (typeof window === "undefined" && !this._isWebWorker()) {\r\n                      // $FlowIssue - flow is not able to recognize this module.\r\n                      return new (require("xhr2").XMLHttpRequest)();\r\n                    }\r\n\r\n                    if (typeof XMLHttpRequest !== "undefined") {\r\n                      return new XMLHttpRequest();\r\n                    }\r\n\r\n                    throw new Error("XMLHttpRequest is not supported");\r\n                  },\r\n                },\r\n              ],\r\n              [\r\n                {\r\n                  key: "canReadFile",\r\n                  value: function canReadFile(file) {\r\n                    return (\r\n                      typeof file === "string" && /^[a-z]+:\\/\\//i.test(file)\r\n                    );\r\n                  },\r\n                },\r\n                {\r\n                  key: "setConfig",\r\n                  value: function setConfig(config) {\r\n                    for (var key in config) {\r\n                      if (config.hasOwnProperty(key)) {\r\n                        this._config[key] = config[key];\r\n                      }\r\n                    }\r\n\r\n                    var disallowedXhrHeaders =\r\n                      this._config.disallowedXhrHeaders;\r\n\r\n                    for (var i = 0; i < disallowedXhrHeaders.length; i++) {\r\n                      disallowedXhrHeaders[i] =\r\n                        disallowedXhrHeaders[i].toLowerCase();\r\n                    }\r\n                  },\r\n                },\r\n              ]\r\n            );\r\n\r\n            return XhrFileReader;\r\n          })(MediaFileReader);\r\n\r\n          _defineProperty(XhrFileReader, "_config", void 0);\r\n\r\n          XhrFileReader._config = {\r\n            avoidHeadRequests: false,\r\n            disallowedXhrHeaders: [],\r\n            timeoutInSec: 30,\r\n          };\r\n          module.exports = XhrFileReader;\r\n        },\r\n        { "./ChunkedFileData": 5, "./MediaFileReader": 11, xhr2: 2 },\r\n      ],\r\n      15: [\r\n        function (require, module, exports) {\r\n          "use strict";\r\n\r\n          function _classCallCheck(instance, Constructor) {\r\n            if (!(instance instanceof Constructor)) {\r\n              throw new TypeError("Cannot call a class as a function");\r\n            }\r\n          }\r\n\r\n          function _defineProperties(target, props) {\r\n            for (var i = 0; i < props.length; i++) {\r\n              var descriptor = props[i];\r\n              descriptor.enumerable = descriptor.enumerable || false;\r\n              descriptor.configurable = true;\r\n              if ("value" in descriptor) descriptor.writable = true;\r\n              Object.defineProperty(target, descriptor.key, descriptor);\r\n            }\r\n          }\r\n\r\n          function _createClass(Constructor, protoProps, staticProps) {\r\n            if (protoProps)\r\n              _defineProperties(Constructor.prototype, protoProps);\r\n            if (staticProps) _defineProperties(Constructor, staticProps);\r\n            return Constructor;\r\n          }\r\n\r\n          function _defineProperty(obj, key, value) {\r\n            if (key in obj) {\r\n              Object.defineProperty(obj, key, {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true,\r\n              });\r\n            } else {\r\n              obj[key] = value;\r\n            }\r\n            return obj;\r\n          }\r\n\r\n          var MediaFileReader = require("./MediaFileReader");\r\n\r\n          var XhrFileReader = require("./XhrFileReader");\r\n\r\n          var BlobFileReader = require("./BlobFileReader");\r\n\r\n          var ArrayFileReader = require("./ArrayFileReader");\r\n\r\n          var MediaTagReader = require("./MediaTagReader");\r\n\r\n          var ID3v1TagReader = require("./ID3v1TagReader");\r\n\r\n          var ID3v2TagReader = require("./ID3v2TagReader");\r\n\r\n          var MP4TagReader = require("./MP4TagReader");\r\n\r\n          var FLACTagReader = require("./FLACTagReader");\r\n\r\n          var mediaFileReaders = [];\r\n          var mediaTagReaders = [];\r\n\r\n          function read(location, callbacks) {\r\n            new Reader(location).read(callbacks);\r\n          }\r\n\r\n          function isRangeValid(range, fileSize) {\r\n            var invalidPositiveRange =\r\n              range.offset >= 0 && range.offset + range.length >= fileSize;\r\n            var invalidNegativeRange =\r\n              range.offset < 0 &&\r\n              (-range.offset > fileSize || range.offset + range.length > 0);\r\n            return !(invalidPositiveRange || invalidNegativeRange);\r\n          }\r\n\r\n          var Reader = /*#__PURE__*/ (function () {\r\n            function Reader(file) {\r\n              _classCallCheck(this, Reader);\r\n\r\n              _defineProperty(this, "_file", void 0);\r\n\r\n              _defineProperty(this, "_tagsToRead", void 0);\r\n\r\n              _defineProperty(this, "_fileReader", void 0);\r\n\r\n              _defineProperty(this, "_tagReader", void 0);\r\n\r\n              this._file = file;\r\n            }\r\n\r\n            _createClass(Reader, [\r\n              {\r\n                key: "setTagsToRead",\r\n                value: function setTagsToRead(tagsToRead) {\r\n                  this._tagsToRead = tagsToRead;\r\n                  return this;\r\n                },\r\n              },\r\n              {\r\n                key: "setFileReader",\r\n                value: function setFileReader(fileReader) {\r\n                  this._fileReader = fileReader;\r\n                  return this;\r\n                },\r\n              },\r\n              {\r\n                key: "setTagReader",\r\n                value: function setTagReader(tagReader) {\r\n                  this._tagReader = tagReader;\r\n                  return this;\r\n                },\r\n              },\r\n              {\r\n                key: "read",\r\n                value: function read(callbacks) {\r\n                  var FileReader = this._getFileReader();\r\n\r\n                  var fileReader = new FileReader(this._file);\r\n                  var self = this;\r\n                  fileReader.init({\r\n                    onSuccess: function onSuccess() {\r\n                      self._getTagReader(fileReader, {\r\n                        onSuccess: function onSuccess(TagReader) {\r\n                          new TagReader(fileReader)\r\n                            .setTagsToRead(self._tagsToRead)\r\n                            .read(callbacks);\r\n                        },\r\n                        onError: callbacks.onError,\r\n                      });\r\n                    },\r\n                    onError: callbacks.onError,\r\n                  });\r\n                },\r\n              },\r\n              {\r\n                key: "_getFileReader",\r\n                value: function _getFileReader() {\r\n                  if (this._fileReader) {\r\n                    return this._fileReader;\r\n                  } else {\r\n                    return this._findFileReader();\r\n                  }\r\n                },\r\n              },\r\n              {\r\n                key: "_findFileReader",\r\n                value: function _findFileReader() {\r\n                  for (var i = 0; i < mediaFileReaders.length; i++) {\r\n                    if (mediaFileReaders[i].canReadFile(this._file)) {\r\n                      return mediaFileReaders[i];\r\n                    }\r\n                  }\r\n\r\n                  throw new Error(\r\n                    "No suitable file reader found for " + this._file\r\n                  );\r\n                },\r\n              },\r\n              {\r\n                key: "_getTagReader",\r\n                value: function _getTagReader(fileReader, callbacks) {\r\n                  if (this._tagReader) {\r\n                    var tagReader = this._tagReader;\r\n                    setTimeout(function () {\r\n                      callbacks.onSuccess(tagReader);\r\n                    }, 1);\r\n                  } else {\r\n                    this._findTagReader(fileReader, callbacks);\r\n                  }\r\n                },\r\n              },\r\n              {\r\n                key: "_findTagReader",\r\n                value: function _findTagReader(fileReader, callbacks) {\r\n                  // We don\'t want to make multiple fetches per tag reader to get the tag\r\n                  // identifier. The strategy here is to combine all the tag identifier\r\n                  // ranges into one and make a single fetch. This is particularly important\r\n                  // in file readers that have expensive loads like the XHR one.\r\n                  // However, with this strategy we run into the problem of loading the\r\n                  // entire file because tag identifiers might be at the start or end of\r\n                  // the file.\r\n                  // To get around this we divide the tag readers into two categories, the\r\n                  // ones that read their tag identifiers from the start of the file and the\r\n                  // ones that read from the end of the file.\r\n                  var tagReadersAtFileStart = [];\r\n                  var tagReadersAtFileEnd = [];\r\n                  var fileSize = fileReader.getSize();\r\n\r\n                  for (var i = 0; i < mediaTagReaders.length; i++) {\r\n                    var range = mediaTagReaders[i].getTagIdentifierByteRange();\r\n\r\n                    if (!isRangeValid(range, fileSize)) {\r\n                      continue;\r\n                    }\r\n\r\n                    if (\r\n                      (range.offset >= 0 && range.offset < fileSize / 2) ||\r\n                      (range.offset < 0 && range.offset < -fileSize / 2)\r\n                    ) {\r\n                      tagReadersAtFileStart.push(mediaTagReaders[i]);\r\n                    } else {\r\n                      tagReadersAtFileEnd.push(mediaTagReaders[i]);\r\n                    }\r\n                  }\r\n\r\n                  var tagsLoaded = false;\r\n                  var loadTagIdentifiersCallbacks = {\r\n                    onSuccess: function onSuccess() {\r\n                      if (!tagsLoaded) {\r\n                        // We\'re expecting to load two sets of tag identifiers. This flag\r\n                        // indicates when the first one has been loaded.\r\n                        tagsLoaded = true;\r\n                        return;\r\n                      }\r\n\r\n                      for (var i = 0; i < mediaTagReaders.length; i++) {\r\n                        var range =\r\n                          mediaTagReaders[i].getTagIdentifierByteRange();\r\n\r\n                        if (!isRangeValid(range, fileSize)) {\r\n                          continue;\r\n                        }\r\n\r\n                        try {\r\n                          var tagIndentifier = fileReader.getBytesAt(\r\n                            range.offset >= 0\r\n                              ? range.offset\r\n                              : range.offset + fileSize,\r\n                            range.length\r\n                          );\r\n                        } catch (ex) {\r\n                          if (callbacks.onError) {\r\n                            callbacks.onError({\r\n                              type: "fileReader",\r\n                              info: ex.message,\r\n                            });\r\n                          }\r\n\r\n                          return;\r\n                        }\r\n\r\n                        if (\r\n                          mediaTagReaders[i].canReadTagFormat(tagIndentifier)\r\n                        ) {\r\n                          callbacks.onSuccess(mediaTagReaders[i]);\r\n                          return;\r\n                        }\r\n                      }\r\n\r\n                      if (callbacks.onError) {\r\n                        callbacks.onError({\r\n                          type: "tagFormat",\r\n                          info: "No suitable tag reader found",\r\n                        });\r\n                      }\r\n                    },\r\n                    onError: callbacks.onError,\r\n                  };\r\n\r\n                  this._loadTagIdentifierRanges(\r\n                    fileReader,\r\n                    tagReadersAtFileStart,\r\n                    loadTagIdentifiersCallbacks\r\n                  );\r\n\r\n                  this._loadTagIdentifierRanges(\r\n                    fileReader,\r\n                    tagReadersAtFileEnd,\r\n                    loadTagIdentifiersCallbacks\r\n                  );\r\n                },\r\n              },\r\n              {\r\n                key: "_loadTagIdentifierRanges",\r\n                value: function _loadTagIdentifierRanges(\r\n                  fileReader,\r\n                  tagReaders,\r\n                  callbacks\r\n                ) {\r\n                  if (tagReaders.length === 0) {\r\n                    // Force async\r\n                    setTimeout(callbacks.onSuccess, 1);\r\n                    return;\r\n                  }\r\n\r\n                  var tagIdentifierRange = [Number.MAX_VALUE, 0];\r\n                  var fileSize = fileReader.getSize(); // Create a super set of all ranges so we can load them all at once.\r\n                  // Might need to rethink this approach if there are tag ranges too far\r\n                  // a part from each other. We\'re good for now though.\r\n\r\n                  for (var i = 0; i < tagReaders.length; i++) {\r\n                    var range = tagReaders[i].getTagIdentifierByteRange();\r\n                    var start =\r\n                      range.offset >= 0\r\n                        ? range.offset\r\n                        : range.offset + fileSize;\r\n                    var end = start + range.length - 1;\r\n                    tagIdentifierRange[0] = Math.min(\r\n                      start,\r\n                      tagIdentifierRange[0]\r\n                    );\r\n                    tagIdentifierRange[1] = Math.max(\r\n                      end,\r\n                      tagIdentifierRange[1]\r\n                    );\r\n                  }\r\n\r\n                  fileReader.loadRange(tagIdentifierRange, callbacks);\r\n                },\r\n              },\r\n            ]);\r\n\r\n            return Reader;\r\n          })();\r\n\r\n          var Config = /*#__PURE__*/ (function () {\r\n            function Config() {\r\n              _classCallCheck(this, Config);\r\n            }\r\n\r\n            _createClass(Config, null, [\r\n              {\r\n                key: "addFileReader",\r\n                value: function addFileReader(fileReader) {\r\n                  mediaFileReaders.push(fileReader);\r\n                  return Config;\r\n                },\r\n              },\r\n              {\r\n                key: "addTagReader",\r\n                value: function addTagReader(tagReader) {\r\n                  mediaTagReaders.push(tagReader);\r\n                  return Config;\r\n                },\r\n              },\r\n              {\r\n                key: "removeTagReader",\r\n                value: function removeTagReader(tagReader) {\r\n                  var tagReaderIx = mediaTagReaders.indexOf(tagReader);\r\n\r\n                  if (tagReaderIx >= 0) {\r\n                    mediaTagReaders.splice(tagReaderIx, 1);\r\n                  }\r\n\r\n                  return Config;\r\n                },\r\n              },\r\n              {\r\n                key: "EXPERIMENTAL_avoidHeadRequests",\r\n                value: function EXPERIMENTAL_avoidHeadRequests() {\r\n                  XhrFileReader.setConfig({\r\n                    avoidHeadRequests: true,\r\n                  });\r\n                },\r\n              },\r\n              {\r\n                key: "setDisallowedXhrHeaders",\r\n                value: function setDisallowedXhrHeaders(disallowedXhrHeaders) {\r\n                  XhrFileReader.setConfig({\r\n                    disallowedXhrHeaders: disallowedXhrHeaders,\r\n                  });\r\n                },\r\n              },\r\n              {\r\n                key: "setXhrTimeoutInSec",\r\n                value: function setXhrTimeoutInSec(timeoutInSec) {\r\n                  XhrFileReader.setConfig({\r\n                    timeoutInSec: timeoutInSec,\r\n                  });\r\n                },\r\n              },\r\n            ]);\r\n\r\n            return Config;\r\n          })();\r\n\r\n          Config.addFileReader(XhrFileReader)\r\n            .addFileReader(BlobFileReader)\r\n            .addFileReader(ArrayFileReader)\r\n            .addTagReader(ID3v2TagReader)\r\n            .addTagReader(ID3v1TagReader)\r\n            .addTagReader(MP4TagReader)\r\n            .addTagReader(FLACTagReader);\r\n\r\n          if (typeof process !== "undefined" && !process.browser) {\r\n            if (\r\n              typeof navigator !== "undefined" &&\r\n              navigator.product === "ReactNative"\r\n            ) {\r\n              var ReactNativeFileReader = require("./ReactNativeFileReader");\r\n\r\n              Config.addFileReader(ReactNativeFileReader);\r\n            } else {\r\n              var NodeFileReader = require("./NodeFileReader");\r\n\r\n              Config.addFileReader(NodeFileReader);\r\n            }\r\n          }\r\n\r\n          module.exports = {\r\n            read: read,\r\n            Reader: Reader,\r\n            Config: Config,\r\n          };\r\n        },\r\n        {\r\n          "./ArrayFileReader": 3,\r\n          "./BlobFileReader": 4,\r\n          "./FLACTagReader": 6,\r\n          "./ID3v1TagReader": 7,\r\n          "./ID3v2TagReader": 9,\r\n          "./MP4TagReader": 10,\r\n          "./MediaFileReader": 11,\r\n          "./MediaTagReader": 12,\r\n          "./NodeFileReader": 1,\r\n          "./ReactNativeFileReader": 1,\r\n          "./XhrFileReader": 14,\r\n        },\r\n      ],\r\n    },\r\n    {},\r\n    [15]\r\n  )(15);\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hELCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFVBQVUsaURBQWlEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGlCQUFpQjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxjQUFjO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnBhY2stYmFiZWwtdGVtcGxhdGUvLi9zcmMvcGFnZXMveXQtbXVzaWMtbHlyaWNzL3NjcmlwdHMvanNtZWRpYXRhZ3MvanNtZWRpYXRhZ3MuanM/Njg1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtbm9jaGVja1xyXG4oZnVuY3Rpb24gKGYpIHtcclxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmKCk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKFtdLCBmKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGc7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICBnID0gd2luZG93O1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgIGcgPSBnbG9iYWw7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgIGcgPSBzZWxmO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZyA9IHRoaXM7XHJcbiAgICB9XHJcbiAgICBnLmpzbWVkaWF0YWdzID0gZigpO1xyXG4gIH1cclxufSkoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBkZWZpbmUsIG1vZHVsZSwgZXhwb3J0cztcclxuICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIHIoZSwgbiwgdCkge1xyXG4gICAgICBmdW5jdGlvbiBvKGksIGYpIHtcclxuICAgICAgICBpZiAoIW5baV0pIHtcclxuICAgICAgICAgIGlmICghZVtpXSkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcmVxdWlyZSAmJiByZXF1aXJlO1xyXG4gICAgICAgICAgICBpZiAoIWYgJiYgYykgcmV0dXJuIGMoaSwgITApO1xyXG4gICAgICAgICAgICBpZiAodSkgcmV0dXJuIHUoaSwgITApO1xyXG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyBpICsgXCInXCIpO1xyXG4gICAgICAgICAgICB0aHJvdyAoKGEuY29kZSA9IFwiTU9EVUxFX05PVF9GT1VORFwiKSwgYSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgcCA9IChuW2ldID0geyBleHBvcnRzOiB7fSB9KTtcclxuICAgICAgICAgIGVbaV1bMF0uY2FsbChcclxuICAgICAgICAgICAgcC5leHBvcnRzLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICAgIHZhciBuID0gZVtpXVsxXVtyXTtcclxuICAgICAgICAgICAgICByZXR1cm4gbyhuIHx8IHIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwLFxyXG4gICAgICAgICAgICBwLmV4cG9ydHMsXHJcbiAgICAgICAgICAgIHIsXHJcbiAgICAgICAgICAgIGUsXHJcbiAgICAgICAgICAgIG4sXHJcbiAgICAgICAgICAgIHRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuW2ldLmV4cG9ydHM7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChcclxuICAgICAgICB2YXIgdSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcmVxdWlyZSAmJiByZXF1aXJlLCBpID0gMDtcclxuICAgICAgICBpIDwgdC5sZW5ndGg7XHJcbiAgICAgICAgaSsrXHJcbiAgICAgIClcclxuICAgICAgICBvKHRbaV0pO1xyXG4gICAgICByZXR1cm4gbztcclxuICAgIH1cclxuICAgIHJldHVybiByO1xyXG4gIH0pKCkoXHJcbiAgICB7XHJcbiAgICAgIDE6IFtmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7fSwge31dLFxyXG4gICAgICAyOiBbXHJcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xyXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBYTUxIdHRwUmVxdWVzdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHt9LFxyXG4gICAgICBdLFxyXG4gICAgICAzOiBbXHJcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xyXG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgICAgICAgICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIlxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmXHJcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG4gICAgICAgICAgICAgICAgICBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJlxyXG4gICAgICAgICAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcclxuICAgICAgICAgICAgICAgICAgPyBcInN5bWJvbFwiXHJcbiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIG9iajtcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdHlwZW9mKG9iaik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm90b1Byb3BzKVxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcclxuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgICAgIFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcclxuICAgICAgICAgICAgICBzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xyXG4gICAgICAgICAgICBfc2V0UHJvdG90eXBlT2YgPVxyXG4gICAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XHJcbiAgICAgICAgICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbztcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XHJcbiAgICAgICAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0O1xyXG4gICAgICAgICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgY2FsbCAmJlxyXG4gICAgICAgICAgICAgIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjYWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xyXG4gICAgICAgICAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIlxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdClcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFxyXG4gICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xyXG4gICAgICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcclxuICAgICAgICAgICAgICA/IE9iamVjdC5nZXRQcm90b3R5cGVPZlxyXG4gICAgICAgICAgICAgIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgTWVkaWFGaWxlUmVhZGVyID0gcmVxdWlyZShcIi4vTWVkaWFGaWxlUmVhZGVyXCIpO1xyXG5cclxuICAgICAgICAgIHZhciBBcnJheUZpbGVSZWFkZXIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX01lZGlhRmlsZVJlYWRlcikge1xyXG4gICAgICAgICAgICBfaW5oZXJpdHMoQXJyYXlGaWxlUmVhZGVyLCBfTWVkaWFGaWxlUmVhZGVyKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQXJyYXlGaWxlUmVhZGVyKTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEFycmF5RmlsZVJlYWRlcihhcnJheSkge1xyXG4gICAgICAgICAgICAgIHZhciBfdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFycmF5RmlsZVJlYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfYXJyYXlcIiwgdm9pZCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9zaXplXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgICAgICAgICAgIF90aGlzLl9hcnJheSA9IGFycmF5O1xyXG4gICAgICAgICAgICAgIF90aGlzLl9zaXplID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIF90aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhcclxuICAgICAgICAgICAgICBBcnJheUZpbGVSZWFkZXIsXHJcbiAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiaW5pdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrcy5vblN1Y2Nlc3MsIDApO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImxvYWRSYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFJhbmdlKHJhbmdlLCBjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrcy5vblN1Y2Nlc3MsIDApO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImdldEJ5dGVBdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qnl0ZUF0KG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPj0gdGhpcy5fYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiT2Zmc2V0IFwiICsgb2Zmc2V0ICsgXCIgaGFzbid0IGJlZW4gbG9hZGVkIHlldC5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcnJheVtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImNhblJlYWRGaWxlXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5SZWFkRmlsZShmaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZmlsZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgQnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiYgQnVmZmVyLmlzQnVmZmVyKGZpbGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBBcnJheUZpbGVSZWFkZXI7XHJcbiAgICAgICAgICB9KShNZWRpYUZpbGVSZWFkZXIpO1xyXG5cclxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gQXJyYXlGaWxlUmVhZGVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeyBcIi4vTWVkaWFGaWxlUmVhZGVyXCI6IDExIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIDQ6IFtcclxuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XHJcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xyXG4gICAgICAgICAgICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiZcclxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiZcclxuICAgICAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgICAgICAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmXHJcbiAgICAgICAgICAgICAgICAgIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICA/IFwic3ltYm9sXCJcclxuICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygb2JqO1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3RvUHJvcHMpXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcclxuICAgICAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFxyXG4gICAgICAgICAgICAgIHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxyXG4gICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XHJcbiAgICAgICAgICAgIF9zZXRQcm90b3R5cGVPZiA9XHJcbiAgICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcclxuICAgICAgICAgICAgICAgIG8uX19wcm90b19fID0gcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvO1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcclxuICAgICAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcclxuICAgICAgICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICBjYWxsICYmXHJcbiAgICAgICAgICAgICAgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KVxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoXHJcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XHJcbiAgICAgICAgICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZlxyXG4gICAgICAgICAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXHJcbiAgICAgICAgICAgICAgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBDaHVua2VkRmlsZURhdGEgPSByZXF1aXJlKFwiLi9DaHVua2VkRmlsZURhdGFcIik7XHJcblxyXG4gICAgICAgICAgdmFyIE1lZGlhRmlsZVJlYWRlciA9IHJlcXVpcmUoXCIuL01lZGlhRmlsZVJlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgQmxvYkZpbGVSZWFkZXIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX01lZGlhRmlsZVJlYWRlcikge1xyXG4gICAgICAgICAgICBfaW5oZXJpdHMoQmxvYkZpbGVSZWFkZXIsIF9NZWRpYUZpbGVSZWFkZXIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCbG9iRmlsZVJlYWRlcik7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBCbG9iRmlsZVJlYWRlcihibG9iKSB7XHJcbiAgICAgICAgICAgICAgdmFyIF90aGlzO1xyXG5cclxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmxvYkZpbGVSZWFkZXIpO1xyXG5cclxuICAgICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2Jsb2JcIiwgdm9pZCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KFxyXG4gICAgICAgICAgICAgICAgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXHJcbiAgICAgICAgICAgICAgICBcIl9maWxlRGF0YVwiLFxyXG4gICAgICAgICAgICAgICAgdm9pZCAwXHJcbiAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgX3RoaXMuX2Jsb2IgPSBibG9iO1xyXG4gICAgICAgICAgICAgIF90aGlzLl9maWxlRGF0YSA9IG5ldyBDaHVua2VkRmlsZURhdGEoKTtcclxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhcclxuICAgICAgICAgICAgICBCbG9iRmlsZVJlYWRlcixcclxuICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfaW5pdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IHRoaXMuX2Jsb2Iuc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrcy5vblN1Y2Nlc3MsIDEpO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImxvYWRSYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFJhbmdlKHJhbmdlLCBjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7IC8vICRGbG93SXNzdWUgLSBmbG93IGlzbid0IGF3YXJlIG9mIG1velNsaWNlIG9yIHdlYmtpdFNsaWNlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9iU2xpY2UgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvYi5zbGljZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvYi5tb3pTbGljZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvYi53ZWJraXRTbGljZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IGJsb2JTbGljZS5jYWxsKFxyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvYixcclxuICAgICAgICAgICAgICAgICAgICAgIHJhbmdlWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0gKyAxXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnJvd3NlckZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicm93c2VyRmlsZVJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGJyb3dzZXJGaWxlUmVhZGVyLnJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZmlsZURhdGEuYWRkRGF0YShyYW5nZVswXSwgaW50QXJyYXkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicm93c2VyRmlsZVJlYWRlci5vbmVycm9yID0gYnJvd3NlckZpbGVSZWFkZXIub25hYm9ydCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uRXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJibG9iXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvOiBicm93c2VyRmlsZVJlYWRlci5lcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJvd3NlckZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiZ2V0Qnl0ZUF0XCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCeXRlQXQob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGVEYXRhLmdldEJ5dGVBdChvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImNhblJlYWRGaWxlXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5SZWFkRmlsZShmaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlIGluc3RhbmNlb2YgQmxvYikgfHwgLy8gRmlsZSBleHRlbmRzIEJsb2IgYnV0IGl0IHNlZW1zIHRoYXQgRmlsZSBpbnN0YW5jZW9mIEJsb2IgZG9lc24ndFxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcXVpdGUgd29yayBhcyBleHBlY3RlZCBpbiBDb3Jkb3ZhL1Bob25lR2FwLlxyXG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBGaWxlICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGUgaW5zdGFuY2VvZiBGaWxlKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBCbG9iRmlsZVJlYWRlcjtcclxuICAgICAgICAgIH0pKE1lZGlhRmlsZVJlYWRlcik7XHJcblxyXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBCbG9iRmlsZVJlYWRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHsgXCIuL0NodW5rZWRGaWxlRGF0YVwiOiA1LCBcIi4vTWVkaWFGaWxlUmVhZGVyXCI6IDExIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIDU6IFtcclxuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIGZpbGUgdGhhdCBtaWdodCBub3QgaGF2ZSBhbGwgaXRzIGRhdGEgbG9hZGVkIHlldC5cclxuICAgICAgICAgICAqIEl0IGlzIHVzZWQgd2hlbiBsb2FkaW5nIHRoZSBlbnRpcmUgZmlsZSBpcyBub3QgYW4gb3B0aW9uIGJlY2F1c2UgaXQncyB0b29cclxuICAgICAgICAgICAqIGV4cGVuc2l2ZS4gSW5zdGVhZCwgcGFydHMgb2YgdGhlIGZpbGUgYXJlIGxvYWRlZCBhbmQgYWRkZWQgb25seSB3aGVuIG5lZWRlZC5cclxuICAgICAgICAgICAqIEZyb20gYSByZWFkaW5nIHBvaW50IG9mIHZpZXcgaXMgYXMgaWYgdGhlIGVudGlyZSBmaWxlIGlzIGxvYWRlZC4gVGhlXHJcbiAgICAgICAgICAgKiBleGNlcHRpb24gaXMgd2hlbiB0aGUgZGF0YSBpcyBub3QgYXZhaWxhYmxlIHlldCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcbiAgICAgICAgICAgKiBUaGlzIGNsYXNzIGRvZXMgbm90IGxvYWQgdGhlIGRhdGEsIGl0IGp1c3QgbWFuYWdlcyBpdC4gSXQgcHJvdmlkZXMgb3BlcmF0aW9uc1xyXG4gICAgICAgICAgICogdG8gYWRkIGFuZCByZWFkIGRhdGEgZnJvbSB0aGUgZmlsZS5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3RvUHJvcHMpXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcclxuICAgICAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgTk9UX0ZPVU5EID0gLTE7XHJcblxyXG4gICAgICAgICAgdmFyIENodW5rZWRGaWxlRGF0YSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ2h1bmtlZEZpbGVEYXRhKCkge1xyXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaHVua2VkRmlsZURhdGEpO1xyXG5cclxuICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZmlsZURhdGFcIiwgdm9pZCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgdGhpcy5fZmlsZURhdGEgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBkYXRhIHRvIHRoZSBmaWxlIHN0b3JhZ2UgYXQgYSBzcGVjaWZpYyBvZmZzZXQuXHJcbiAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFxyXG4gICAgICAgICAgICAgIENodW5rZWRGaWxlRGF0YSxcclxuICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJhZGREYXRhXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGREYXRhKG9mZnNldCwgZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRFbmQgPSBvZmZzZXQgKyBkYXRhLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHVua1JhbmdlID0gdGhpcy5fZ2V0Q2h1bmtSYW5nZShvZmZzZXQsIG9mZnNldEVuZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVua1JhbmdlLnN0YXJ0SXggPT09IE5PVF9GT1VORCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsZURhdGEuc3BsaWNlKGNodW5rUmFuZ2UuaW5zZXJ0SXggfHwgMCwgMCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGF0YSB0byBhZGQgY29sbGlkZXMgd2l0aCBleGlzdGluZyBjaHVua3Mgd2UgcHJlcGVuZCBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBkYXRhIGZyb20gdGhlIGhhbGYgY29sbGlkaW5nIGNodW5rcyB0byBtYWtlIHRoZSBjb2xsaXNpb24gYXRcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIDEwMCUuIFRoZSBuZXcgZGF0YSBjYW4gdGhlbiByZXBsYWNlIGFsbCB0aGUgY29sbGlkaW5nIGNodW5rZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RDaHVuayA9IHRoaXMuX2ZpbGVEYXRhW2NodW5rUmFuZ2Uuc3RhcnRJeF07XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdENodW5rID0gdGhpcy5fZmlsZURhdGFbY2h1bmtSYW5nZS5lbmRJeF07XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVlZHNQcmVwZW5kID0gb2Zmc2V0ID4gZmlyc3RDaHVuay5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVlZHNBcHBlbmQgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRFbmQgPFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2h1bmsub2Zmc2V0ICsgbGFzdENodW5rLmRhdGEubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVuayA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBNYXRoLm1pbihvZmZzZXQsIGZpcnN0Q2h1bmsub2Zmc2V0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzUHJlcGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xpY2VkRGF0YSA9IHRoaXMuX3NsaWNlRGF0YShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdENodW5rLmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgLSBmaXJzdENodW5rLm9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuZGF0YSA9IHRoaXMuX2NvbmNhdERhdGEoc2xpY2VkRGF0YSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzQXBwZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgbGFzdENodW5rIGJlY2F1c2UgdGhlIHNsaWNlIGxvZ2ljIGlzIGVhc2llciB0byBoYW5kbGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbGljZWREYXRhID0gdGhpcy5fc2xpY2VEYXRhKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2h1bmsub2Zmc2V0IC0gY2h1bmsub2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5kYXRhID0gdGhpcy5fY29uY2F0RGF0YShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZWREYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaHVuay5kYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsZURhdGEuc3BsaWNlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua1JhbmdlLnN0YXJ0SXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rUmFuZ2UuZW5kSXggLSBjaHVua1JhbmdlLnN0YXJ0SXggKyAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua1xyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiX2NvbmNhdERhdGFcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb25jYXREYXRhKGRhdGFBLCBkYXRhQikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGVkQXJyYXlzIGRvbid0IHN1cHBvcnQgY29uY2F0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YUEpXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyAkRmxvd0lzc3VlIC0gZmxvdyB0aGlua3MgZGF0YUFhbmRCIGlzIGEgc3RyaW5nIGJ1dCBpdCdzIG5vdFxyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFBYW5kQiA9IG5ldyBkYXRhQS5jb25zdHJ1Y3RvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUEubGVuZ3RoICsgZGF0YUIubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICApOyAvLyAkRmxvd0lzc3VlIC0gZmxvdyB0aGlua3MgZGF0YUFhbmRCIGlzIGEgc3RyaW5nIGJ1dCBpdCdzIG5vdFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIGRhdGFBYW5kQi5zZXQoZGF0YUEsIDApOyAvLyAkRmxvd0lzc3VlIC0gZmxvdyB0aGlua3MgZGF0YUFhbmRCIGlzIGEgc3RyaW5nIGJ1dCBpdCdzIG5vdFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIGRhdGFBYW5kQi5zZXQoZGF0YUIsIGRhdGFBLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUFhbmRCO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyAkRmxvd0lzc3VlIC0gZmxvdyB0aGlua3MgZGF0YUFhbmRCIGlzIGEgVHlwZWRBcnJheSBidXQgaXQncyBub3RcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhQS5jb25jYXQoZGF0YUIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfc2xpY2VEYXRhXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2xpY2VEYXRhKGRhdGEsIGJlZ2luLCBlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTb21lIFR5cGVBcnJheSBpbXBsZW1lbnRhdGlvbnMgZG8gbm90IHN1cHBvcnQgc2xpY2UgeWV0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnNsaWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zbGljZShiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gJEZsb3dJc3N1ZSAtIGZsb3cgdGhpbmtzIGRhdGEgaXMgYSBzdHJpbmcgYnV0IGl0J3Mgbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zdWJhcnJheShiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgKiBGaW5kcyB0aGUgY2h1bmsgcmFuZ2UgdGhhdCBvdmVybGFwcyB0aGUgW29mZnNldFN0YXJ0LTEsb2Zmc2V0RW5kKzFdIHJhbmdlLlxyXG4gICAgICAgICAgICAgICAgICAgKiBXaGVuIGEgY2h1bmsgaXMgYWRqYWNlbnQgdG8gdGhlIG9mZnNldCB3ZSBzdGlsbCBjb25zaWRlciBpdCBwYXJ0IG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgKiByYW5nZSAodGhpcyBpcyB0aGUgc2l0dWF0aW9uIG9mIG9mZnNldFN0YXJ0LTEgb3Igb2Zmc2V0RW5kKzEpLlxyXG4gICAgICAgICAgICAgICAgICAgKiBXaGVuIG5vIGNodW5rcyBhcmUgZm91bmQgYGluc2VydEl4YCBkZW5vdGVzIHRoZSBpbmRleCB3aGVyZSB0aGUgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW4gdGhlIGRhdGEgbGlzdCAoc3RhcnRJeCA9PSBOT1RfRk9VTkQgYW5kIGVuZElYID09XHJcbiAgICAgICAgICAgICAgICAgICAqIE5PVF9GT1VORCkuXHJcbiAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9nZXRDaHVua1JhbmdlXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2h1bmtSYW5nZShvZmZzZXRTdGFydCwgb2Zmc2V0RW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q2h1bmtJeCA9IE5PVF9GT1VORDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQ2h1bmtJeCA9IE5PVF9GT1VORDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0SXggPSAwOyAvLyBDb3VsZCB1c2UgYmluYXJ5IHNlYXJjaCBidXQgbm90IGV4cGVjdGluZyB0aGF0IG1hbnkgYmxvY2tzIHRvIGV4aXN0LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaSA8IHRoaXMuX2ZpbGVEYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgIGkrKywgaW5zZXJ0SXggPSBpXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtPZmZzZXRTdGFydCA9IHRoaXMuX2ZpbGVEYXRhW2ldLm9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVua09mZnNldEVuZCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rT2Zmc2V0U3RhcnQgKyB0aGlzLl9maWxlRGF0YVtpXS5kYXRhLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0RW5kIDwgY2h1bmtPZmZzZXRTdGFydCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBvZmZzZXQgcmFuZ2UgZG9lc24ndCBvdmVybGFwIHdpdGggYW55IGNodW5rcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9IC8vIElmIGl0IGlzIGFkamFjZW50IHdlIHN0aWxsIGNvbnNpZGVyIGl0IHBhcnQgb2YgdGhlIHJhbmdlIGJlY2F1c2VcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGdvaW5nIGVuZCB1cCB3aXRoIGEgc2luZ2xlIGJsb2NrIHdpdGggYWxsIGNvbnRpZ3VvdXMgZGF0YS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFN0YXJ0IDw9IGNodW5rT2Zmc2V0RW5kICsgMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRFbmQgPj0gY2h1bmtPZmZzZXRTdGFydCAtIDFcclxuICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydENodW5rSXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IC8vIE5vIHN0YXJ0aW5nIGNodW5rIHdhcyBmb3VuZCwgbWVhbmluZyB0aGF0IHRoZSBvZmZzZXQgaXMgZWl0aGVyIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIGFmdGVyIHRoZSBjdXJyZW50IHN0b3JlZCBjaHVua3MuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydENodW5rSXggPT09IE5PVF9GT1VORCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJeDogTk9UX0ZPVU5ELFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRJeDogTk9UX0ZPVU5ELFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRJeDogaW5zZXJ0SXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gRmluZCB0aGUgZW5kaW5nIGNodW5rLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRDaHVua0l4OyBpIDwgdGhpcy5fZmlsZURhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVua09mZnNldFN0YXJ0ID0gdGhpcy5fZmlsZURhdGFbaV0ub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGNodW5rT2Zmc2V0RW5kID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtPZmZzZXRTdGFydCArIHRoaXMuX2ZpbGVEYXRhW2ldLmRhdGEubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRFbmQgPj0gY2h1bmtPZmZzZXRTdGFydCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FuZGlkYXRlIGZvciB0aGUgZW5kIGNodW5rLCBpdCBkb2Vzbid0IG1lYW4gaXQgaXMgeWV0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRDaHVua0l4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0RW5kIDw9IGNodW5rT2Zmc2V0RW5kICsgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRDaHVua0l4ID09PSBOT1RfRk9VTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGVuZENodW5rSXggPSBzdGFydENodW5rSXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnRJeDogc3RhcnRDaHVua0l4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgZW5kSXg6IGVuZENodW5rSXgsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJoYXNEYXRhUmFuZ2VcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0RhdGFSYW5nZShvZmZzZXRTdGFydCwgb2Zmc2V0RW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9maWxlRGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGNodW5rID0gdGhpcy5fZmlsZURhdGFbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldEVuZCA8IGNodW5rLm9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRTdGFydCA+PSBjaHVuay5vZmZzZXQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0RW5kIDwgY2h1bmsub2Zmc2V0ICsgY2h1bmsuZGF0YS5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRCeXRlQXRcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJ5dGVBdChvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUNodW5rO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ZpbGVEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUNodW5rU3RhcnQgPSB0aGlzLl9maWxlRGF0YVtpXS5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUNodW5rRW5kID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUNodW5rU3RhcnQgKyB0aGlzLl9maWxlRGF0YVtpXS5kYXRhLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA+PSBkYXRhQ2h1bmtTdGFydCAmJiBvZmZzZXQgPD0gZGF0YUNodW5rRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFDaHVuayA9IHRoaXMuX2ZpbGVEYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhQ2h1bmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhQ2h1bmsuZGF0YVtvZmZzZXQgLSBkYXRhQ2h1bmsub2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgIFwiT2Zmc2V0IFwiICsgb2Zmc2V0ICsgXCIgaGFzbid0IGJlZW4gbG9hZGVkIHlldC5cIlxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiTk9UX0ZPVU5EXCIsXHJcbiAgICAgICAgICAgICAgICAgIC8vICRGbG93SXNzdWUgLSBnZXQvc2V0IHByb3BlcnRpZXMgbm90IHlldCBzdXBwb3J0ZWRcclxuICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5PVF9GT1VORDtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIENodW5rZWRGaWxlRGF0YTtcclxuICAgICAgICAgIH0pKCk7XHJcblxyXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBDaHVua2VkRmlsZURhdGE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7fSxcclxuICAgICAgXSxcclxuICAgICAgNjogW1xyXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcclxuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XHJcbiAgICAgICAgICAgIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG4gICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCJcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJlxyXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiZcclxuICAgICAgICAgICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcclxuICAgICAgICAgICAgICAgICAgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlXHJcbiAgICAgICAgICAgICAgICAgID8gXCJzeW1ib2xcIlxyXG4gICAgICAgICAgICAgICAgICA6IHR5cGVvZiBvYmo7XHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3R5cGVvZihvYmopO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcclxuICAgICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAocHJvdG9Qcm9wcylcclxuICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCJcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXHJcbiAgICAgICAgICAgICAgc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcclxuICAgICAgICAgICAgX3NldFByb3RvdHlwZU9mID1cclxuICAgICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xyXG4gICAgICAgICAgICAgICAgby5fX3Byb3RvX18gPSBwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xyXG4gICAgICAgICAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xyXG4gICAgICAgICAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcclxuICAgICAgICAgICAgICAgIHJlc3VsdDtcclxuICAgICAgICAgICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgIGNhbGwgJiZcclxuICAgICAgICAgICAgICAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICByZXR1cm4gY2FsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcclxuICAgICAgICAgICAgICAgIFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCJcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpXHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChcclxuICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSlcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcclxuICAgICAgICAgICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mXHJcbiAgICAgICAgICAgICAgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcclxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIE1lZGlhVGFnUmVhZGVyID0gcmVxdWlyZShcIi4vTWVkaWFUYWdSZWFkZXJcIik7XHJcbiAgICAgICAgICAvKiBUaGUgZmlyc3QgNCBieXRlcyBvZiBhIEZMQUMgZmlsZSBkZXNjcmliZXMgdGhlIGhlYWRlciBmb3IgdGhlIGZpbGUuIElmIHRoZXNlXHJcbiAgICAgICAgICAgKiBieXRlcyByZXNwZWN0aXZlbHkgcmVhZCBcImZMYUNcIiwgd2UgY2FuIGRldGVybWluZSBpdCBpcyBhIEZMQUMgZmlsZS5cclxuICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgIHZhciBGTEFDX0hFQURFUl9TSVpFID0gNDtcclxuICAgICAgICAgIC8qIEZMQUMgbWV0YWRhdGEgaXMgc3RvcmVkIGluIGJsb2NrcyBjb250YWluaW5nIGRhdGEgcmFuZ2luZyBmcm9tIFNUUkVBTUlORk8gdG9cclxuICAgICAgICAgICAqIFZPUkJJU19DT01NRU5ULCB3aGljaCBpcyB3aGF0IHdlIHdhbnQgdG8gd29yayB3aXRoLlxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEVhY2ggbWV0YWRhdGEgaGVhZGVyIGlzIDQgYnl0ZXMgbG9uZywgd2l0aCB0aGUgZmlyc3QgYnl0ZSBkZXRlcm1pbmluZyB3aGV0aGVyXHJcbiAgICAgICAgICAgKiBpdCBpcyB0aGUgbGFzdCBtZXRhZGF0YSBibG9jayBiZWZvcmUgdGhlIGF1ZGlvIGRhdGEgYW5kIHdoYXQgdGhlIGJsb2NrIHR5cGUgaXMuXHJcbiAgICAgICAgICAgKiBUaGlzIGZpcnN0IGJ5dGUgY2FuIGZ1cnRoZXIgYmUgc3BsaXQgaW50byA4IGJpdHMsIHdpdGggdGhlIGZpcnN0IGJpdCBiZWluZyB0aGVcclxuICAgICAgICAgICAqIGxhc3QtbWV0YWRhdGEtYmxvY2sgZmxhZywgYW5kIHRoZSBsYXN0IHRocmVlIGJpdHMgYmVpbmcgdGhlIGJsb2NrIHR5cGUuXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogU2luY2UgdGhlIHNwZWNpZmljYXRpb24gc3RhdGVzIHRoYXQgdGhlIGRlY2ltYWwgdmFsdWUgZm9yIGEgVk9SQklTX0NPTU1FTlQgYmxvY2tcclxuICAgICAgICAgICAqIHR5cGUgaXMgNCwgdGhlIHR3byBwb3NzaWJpbGl0aWVzIGZvciB0aGUgY29tbWVudCBibG9jayBoZWFkZXIgdmFsdWVzIGFyZTpcclxuICAgICAgICAgICAqIC0gMDAwMDAxMDAgKE5vdCBhIGxhc3QgbWV0YWRhdGEgY29tbWVudCBibG9jaywgdmFsdWUgb2YgNClcclxuICAgICAgICAgICAqIC0gMTAwMDAxMDAgKEEgbGFzdCBtZXRhZGF0YSBjb21tZW50IGJsb2NrLCB2YWx1ZSBvZiAxMzIpXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogU2ltaWxhcmx5LCB0aGUgcGljdHVyZSBibG9jayBoZWFkZXIgdmFsdWVzIGFyZSA2IGFuZCAxMjguXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogQWxsIHZhbHVlcyBmb3IgTUVUQURBVEFfQkxPQ0tfSEVBREVSIGNhbiBiZSBmb3VuZCBoZXJlLlxyXG4gICAgICAgICAgICogaHR0cHM6Ly94aXBoLm9yZy9mbGFjL2Zvcm1hdC5odG1sI21ldGFkYXRhX2Jsb2NrX2hlYWRlclxyXG4gICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgdmFyIENPTU1FTlRfSEVBREVSUyA9IFs0LCAxMzJdO1xyXG4gICAgICAgICAgdmFyIFBJQ1RVUkVfSEVBREVSUyA9IFs2LCAxMzRdOyAvLyBUaGVzZSBhcmUgdGhlIHBvc3NpYmxlIGltYWdlIHR5cGVzIGFzIGRlZmluZWQgYnkgdGhlIEZMQUMgc3BlY2lmaWNhdGlvbi5cclxuXHJcbiAgICAgICAgICB2YXIgSU1BR0VfVFlQRVMgPSBbXHJcbiAgICAgICAgICAgIFwiT3RoZXJcIixcclxuICAgICAgICAgICAgXCIzMngzMiBwaXhlbHMgJ2ZpbGUgaWNvbicgKFBORyBvbmx5KVwiLFxyXG4gICAgICAgICAgICBcIk90aGVyIGZpbGUgaWNvblwiLFxyXG4gICAgICAgICAgICBcIkNvdmVyIChmcm9udClcIixcclxuICAgICAgICAgICAgXCJDb3ZlciAoYmFjaylcIixcclxuICAgICAgICAgICAgXCJMZWFmbGV0IHBhZ2VcIixcclxuICAgICAgICAgICAgXCJNZWRpYSAoZS5nLiBsYWJlbCBzaWRlIG9mIENEKVwiLFxyXG4gICAgICAgICAgICBcIkxlYWQgYXJ0aXN0L2xlYWQgcGVyZm9ybWVyL3NvbG9pc3RcIixcclxuICAgICAgICAgICAgXCJBcnRpc3QvcGVyZm9ybWVyXCIsXHJcbiAgICAgICAgICAgIFwiQ29uZHVjdG9yXCIsXHJcbiAgICAgICAgICAgIFwiQmFuZC9PcmNoZXN0cmFcIixcclxuICAgICAgICAgICAgXCJDb21wb3NlclwiLFxyXG4gICAgICAgICAgICBcIkx5cmljaXN0L3RleHQgd3JpdGVyXCIsXHJcbiAgICAgICAgICAgIFwiUmVjb3JkaW5nIExvY2F0aW9uXCIsXHJcbiAgICAgICAgICAgIFwiRHVyaW5nIHJlY29yZGluZ1wiLFxyXG4gICAgICAgICAgICBcIkR1cmluZyBwZXJmb3JtYW5jZVwiLFxyXG4gICAgICAgICAgICBcIk1vdmllL3ZpZGVvIHNjcmVlbiBjYXB0dXJlXCIsXHJcbiAgICAgICAgICAgIFwiQSBicmlnaHQgY29sb3VyZWQgZmlzaFwiLFxyXG4gICAgICAgICAgICBcIklsbHVzdHJhdGlvblwiLFxyXG4gICAgICAgICAgICBcIkJhbmQvYXJ0aXN0IGxvZ290eXBlXCIsXHJcbiAgICAgICAgICAgIFwiUHVibGlzaGVyL1N0dWRpbyBsb2dvdHlwZVwiLFxyXG4gICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhIE1lZGlhVGFnUmVhZGVyIHRoYXQgcGFyc2VzIEZMQUMgdGFncy5cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgdmFyIEZMQUNUYWdSZWFkZXIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX01lZGlhVGFnUmVhZGVyKSB7XHJcbiAgICAgICAgICAgIF9pbmhlcml0cyhGTEFDVGFnUmVhZGVyLCBfTWVkaWFUYWdSZWFkZXIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihGTEFDVGFnUmVhZGVyKTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZMQUNUYWdSZWFkZXIoKSB7XHJcbiAgICAgICAgICAgICAgdmFyIF90aGlzO1xyXG5cclxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRkxBQ1RhZ1JlYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgIGZvciAoXHJcbiAgICAgICAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwO1xyXG4gICAgICAgICAgICAgICAgX2tleSA8IF9sZW47XHJcbiAgICAgICAgICAgICAgICBfa2V5KytcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XHJcblxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eShcclxuICAgICAgICAgICAgICAgIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLFxyXG4gICAgICAgICAgICAgICAgXCJfY29tbWVudE9mZnNldFwiLFxyXG4gICAgICAgICAgICAgICAgdm9pZCAwXHJcbiAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KFxyXG4gICAgICAgICAgICAgICAgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXHJcbiAgICAgICAgICAgICAgICBcIl9waWN0dXJlT2Zmc2V0XCIsXHJcbiAgICAgICAgICAgICAgICB2b2lkIDBcclxuICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhcclxuICAgICAgICAgICAgICBGTEFDVGFnUmVhZGVyLFxyXG4gICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9sb2FkRGF0YVwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTpcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBGdW5jdGlvbiBjYWxsZWQgdG8gbG9hZCB0aGUgZGF0YSBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVG8gYmVnaW4gcHJvY2Vzc2luZyB0aGUgYmxvY2tzLCB0aGUgbmV4dCA0IGJ5dGVzIGFmdGVyIHRoZSBpbml0aWFsIDQgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgKiAoYnl0ZXMgNCB0aHJvdWdoIDcpIGFyZSBsb2FkZWQuIEZyb20gdGhlcmUsIHRoZSByZXN0IG9mIHRoZSBsb2FkaW5nIHByb2Nlc3NcclxuICAgICAgICAgICAgICAgICAgICAgKiBpcyBwYXNzZWQgb24gdG8gdGhlIF9sb2FkQmxvY2sgZnVuY3Rpb24sIHdoaWNoIHdpbGwgaGFuZGxlIHRoZSByZXN0IG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIHBhcnNpbmcgZm9yIHRoZSBtZXRhZGF0YSBibG9ja3MuXHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge01lZGlhRmlsZVJlYWRlcn0gbWVkaWFGaWxlUmVhZGVyIC0gVGhlIE1lZGlhRmlsZVJlYWRlciB1c2VkIHRvIHBhcnNlIHRoZSBmaWxlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TG9hZENhbGxiYWNrVHlwZX0gY2FsbGJhY2tzIC0gVGhlIGNhbGxiYWNrIHRvIGNhbGwgb25jZSBfbG9hZERhdGEgaXMgY29tcGxldGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9sb2FkRGF0YShtZWRpYUZpbGVSZWFkZXIsIGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgbWVkaWFGaWxlUmVhZGVyLmxvYWRSYW5nZShbNCwgN10sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbG9hZEJsb2NrKG1lZGlhRmlsZVJlYWRlciwgNCwgY2FsbGJhY2tzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgKiBTcGVjaWFsIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gcGFyc2UgdGhlIGRpZmZlcmVudCBGTEFDIGJsb2Nrcy5cclxuICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICogVGhlIEZMQUMgc3BlY2lmaWNhdGlvbiBkb2Vzbid0IHNwZWNpZnkgYSBzcGVjaWZpYyBsb2NhdGlvbiBmb3IgbWV0YWRhdGEgdG8gcmVzaWduLCBidXRcclxuICAgICAgICAgICAgICAgICAgICogZGljdGF0ZXMgdGhhdCBpdCBtYXkgYmUgaW4gb25lIG9mIHZhcmlvdXMgYmxvY2tzIGxvY2F0ZWQgdGhyb3VnaG91dCB0aGUgZmlsZS4gVG8gbG9hZCB0aGVcclxuICAgICAgICAgICAgICAgICAgICogbWV0YWRhdGEsIHdlIG11c3QgbG9jYXRlIHRoZSBoZWFkZXIgZmlyc3QuIFRoaXMgY2FuIGJlIGRvbmUgYnkgcmVhZGluZyB0aGUgZmlyc3QgYnl0ZSBvZlxyXG4gICAgICAgICAgICAgICAgICAgKiBlYWNoIGJsb2NrIHRvIGRldGVybWluZSB0aGUgYmxvY2sgdHlwZS4gQWZ0ZXIgdGhlIGJsb2NrIHR5cGUgY29tZXMgYSAyNCBiaXQgaW50ZWdlciB0aGF0IHN0b3Jlc1xyXG4gICAgICAgICAgICAgICAgICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBibG9jayBhcyBiaWcgZW5kaWFuLiBVc2luZyB0aGlzLCB3ZSBsb2NhdGUgdGhlIGJsb2NrIGFuZCBzdG9yZSB0aGUgb2Zmc2V0IGZvclxyXG4gICAgICAgICAgICAgICAgICAgKiBwYXJzaW5nIGxhdGVyLlxyXG4gICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgKiBBZnRlciBlYWNoIGJsb2NrIGhhcyBiZWVuIHBhcnNlZCwgdGhlIF9uZXh0QmxvY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGluIG9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAqIHRvIHBhcnNlIHRoZSBpbmZvcm1hdGlvbiBvZiB0aGUgbmV4dCBibG9jay4gQWxsIGJsb2NrcyBuZWVkIHRvIGJlIHBhcnNlZCBpbiBvcmRlciB0byBmaW5kXHJcbiAgICAgICAgICAgICAgICAgICAqIGFsbCBvZiB0aGUgcGljdHVyZSBhbmQgY29tbWVudCBibG9ja3MuXHJcbiAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAqIE1vcmUgaW5mbyBvbiB0aGUgRkxBQyBzcGVjaWZpY2F0aW9uIG1heSBiZSBmb3VuZCBoZXJlOlxyXG4gICAgICAgICAgICAgICAgICAgKiBodHRwczovL3hpcGgub3JnL2ZsYWMvZm9ybWF0Lmh0bWxcclxuICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtNZWRpYUZpbGVSZWFkZXJ9IG1lZGlhRmlsZVJlYWRlciAtIFRoZSBNZWRpYUZpbGVSZWFkZXIgdXNlZCB0byBwYXJzZSB0aGUgZmlsZS5cclxuICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgdG8gc3RhcnQgY2hlY2tpbmcgdGhlIGhlYWRlciBmcm9tLlxyXG4gICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0xvYWRDYWxsYmFja1R5cGV9IGNhbGxiYWNrcyAtIFRoZSBjYWxsYmFjayB0byBjYWxsIG9uY2UgdGhlIGhlYWRlciBoYXMgYmVlbiBmb3VuZC5cclxuICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiX2xvYWRCbG9ja1wiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRCbG9jayhcclxuICAgICAgICAgICAgICAgICAgICBtZWRpYUZpbGVSZWFkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogQXMgbWVudGlvbmVkIGFib3ZlLCB0aGlzIGZpcnN0IGJ5dGUgaXMgbG9hZGVkIHRvIHNlZSB3aGF0IG1ldGFkYXRhIHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIGJsb2NrIHJlcHJlc2VudHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0hlYWRlciA9IG1lZGlhRmlsZVJlYWRlci5nZXRCeXRlQXQob2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAvKiBUaGUgbGFzdCB0aHJlZSBieXRlcyAoaW50ZWdlciAyNCkgY29udGFpbiBhIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICogb2YgdGhlIGZvbGxvd2luZyBtZXRhZGF0YSBibG9jay4gVGhlIDEgaXMgYWRkZWQgaW4gb3JkZXIgdG8gc2hpZnQgdGhlIG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAqIGJ5IG9uZSB0byBnZXQgdGhlIGxhc3QgdGhyZWUgYnl0ZXMgaW4gdGhlIGJsb2NrIGhlYWRlci5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IG1lZGlhRmlsZVJlYWRlci5nZXRJbnRlZ2VyMjRBdChcclxuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGNvbmRpdGlvbmFsIGNoZWNrcyBpZiBibG9ja0hlYWRlciAodGhlIGJ5dGUgcmV0cmlldmVkIHJlcHJlc2VudGluZyB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgKiB0eXBlIG9mIHRoZSBoZWFkZXIpIGlzIG9uZSB0aGUgaGVhZGVycyB3ZSBhcmUgbG9va2luZyBmb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGF0IGlzIG5vdCB0cnVlLCB0aGUgYmxvY2sgaXMgc2tpcHBlZCBvdmVyIGFuZCB0aGUgbmV4dCByYW5nZSBpcyBsb2FkZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICogLSBvZmZzZXQgKyA0ICsgYmxvY2tTaXplIGFkZHMgNCB0byBza2lwIG92ZXIgdGhlIGluaXRpYWwgbWV0YWRhdGEgaGVhZGVyIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIGJsb2NrU2l6ZSB0byBza2lwIG92ZXIgdGhlIGJsb2NrIG92ZXJhbGwsIHBsYWNpbmcgaXQgYXQgdGhlIGhlYWQgb2YgdGhlIG5leHRcclxuICAgICAgICAgICAgICAgICAgICAgKiBtZXRhZGF0YSBoZWFkZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICogLSBvZmZzZXQgKyA0ICsgNCArIGJsb2NrU2l6ZSBkb2VzIHRoZSBzYW1lIHRoaW5nIGFzIHRoZSBwcmV2aW91cyBibG9jayB3aXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIGV4Y2VwdGlvbiBvZiBhZGRpbmcgYW5vdGhlciA0IGJ5dGVzIHRvIG1vdmUgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbmV3IG1ldGFkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICogaGVhZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoQ09NTUVOVF9IRUFERVJTLmluZGV4T2YoYmxvY2tIZWFkZXIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLyogNCBpcyBhZGRlZCB0byBvZmZzZXQgdG8gbW92ZSBpdCB0byB0aGUgaGVhZCBvZiB0aGUgYWN0dWFsIG1ldGFkYXRhLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICogVGhlIHJhbmdlIHN0YXJ0aW5nIGZyb20gb2Zmc2V0TWF0YWRhdGEgKHRoZSBiZWdpbm5pbmcgb2YgdGhlIGJsb2NrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICogYW5kIG9mZnNldE1ldGFkYXRhICsgYmxvY2tTaXplICh0aGUgZW5kIG9mIHRoZSBibG9jaykgaXMgbG9hZGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TWV0YWRhdGEgPSBvZmZzZXQgKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgbWVkaWFGaWxlUmVhZGVyLmxvYWRSYW5nZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgW29mZnNldE1ldGFkYXRhLCBvZmZzZXRNZXRhZGF0YSArIGJsb2NrU2l6ZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2NvbW1lbnRPZmZzZXQgPSBvZmZzZXRNZXRhZGF0YTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9uZXh0QmxvY2soXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRmlsZVJlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0hlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFBJQ1RVUkVfSEVBREVSUy5pbmRleE9mKGJsb2NrSGVhZGVyKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRNZXRhZGF0YSA9IG9mZnNldCArIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICBtZWRpYUZpbGVSZWFkZXIubG9hZFJhbmdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbb2Zmc2V0TWV0YWRhdGEsIG9mZnNldE1ldGFkYXRhICsgYmxvY2tTaXplXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGljdHVyZU9mZnNldCA9IG9mZnNldE1ldGFkYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX25leHRCbG9jayhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFGaWxlUmVhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrSGVhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1NpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9uZXh0QmxvY2soXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRmlsZVJlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0hlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byBsb2FkIHRoZSBuZXh0IHJhbmdlIGFuZCByZXNwZWN0aXZlIGJsb2NrLlxyXG4gICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbWV0YWRhdGEgYmxvY2sgdGhhdCB3YXMgaWRlbnRpZmllZCBpcyBub3QgdGhlIGxhc3QgYmxvY2sgYmVmb3JlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgKiBhdWRpbyBibG9ja3MsIHRoZSBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIGxvYWRpbmcgdGhlIG5leHQgYmxvY2tzLiBJZiBpdCBpc1xyXG4gICAgICAgICAgICAgICAgICAgKiB0aGUgbGFzdCBibG9jayAoaWRlbnRpZmllZCBieSBhbnkgdmFsdWVzIGdyZWF0ZXIgdGhhbiAxMjcsIHNlZSBGTEFDIHNwZWMuKSxcclxuICAgICAgICAgICAgICAgICAgICogdGhlIGZ1bmN0aW9uIHdpbGwgZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb21tZW50IGJsb2NrIGhhZCBiZWVuIGlkZW50aWZpZWQuXHJcbiAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBibG9jayBkb2VzIG5vdCBleGlzdCwgdGhlIGVycm9yIGNhbGxiYWNrIGlzIGNhbGxlZC4gT3RoZXJ3aXNlLCB0aGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICogd2lsbCBjYWxsIHRoZSBzdWNjZXNzIGNhbGxiYWNrLCBhbGxvd2luZyBkYXRhIHBhcnNpbmcgdG8gYmVnaW4uXHJcbiAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TWVkaWFGaWxlUmVhZGVyfSBtZWRpYUZpbGVSZWFkZXIgLSBUaGUgTWVkaWFGaWxlUmVhZGVyIHVzZWQgdG8gcGFyc2UgdGhlIGZpbGUuXHJcbiAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRoYXQgdGhlIGV4aXN0aW5nIGhlYWRlciB3YXMgbG9jYXRlZCBhdC5cclxuICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrSGVhZGVyIC0gQW4gaW50ZWdlciByZWZsZWN0aW5nIHRoZSBoZWFkZXIgdHlwZSBvZiB0aGUgYmxvY2suXHJcbiAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja1NpemUgLSBUaGUgc2l6ZSBvZiB0aGUgcHJldmlvdXNseSBwcm9jZXNzZWQgaGVhZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0xvYWRDYWxsYmFja1R5cGV9IGNhbGxiYWNrcyAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfbmV4dEJsb2NrXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV4dEJsb2NrKFxyXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhRmlsZVJlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tIZWFkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja0hlYWRlciA+IDEyNykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLl9jb21tZW50T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vbkVycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImxvYWREYXRhXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbzogXCJDb21tZW50IGJsb2NrIGNvdWxkIG5vdCBiZSBmb3VuZC5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25TdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRmlsZVJlYWRlci5sb2FkUmFuZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtvZmZzZXQgKyA0ICsgYmxvY2tTaXplLCBvZmZzZXQgKyA0ICsgNCArIGJsb2NrU2l6ZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2xvYWRCbG9jayhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFGaWxlUmVhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKyA0ICsgYmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgKiBQYXJzZXMgdGhlIGRhdGEgYW5kIHJldHVybnMgdGhlIHRhZ3MuXHJcbiAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgYW4gb3ZlcnZpZXcgb2YgdGhlIFZvcmJpc0NvbW1lbnQgZm9ybWF0IGFuZCB3aGF0IHRoaXMgZnVuY3Rpb24gYXR0ZW1wdHMgdG9cclxuICAgICAgICAgICAgICAgICAgICogcmV0cmlldmU6XHJcbiAgICAgICAgICAgICAgICAgICAqIC0gRmlyc3QgNCBieXRlczogYSBsb25nIHRoYXQgY29udGFpbnMgdGhlIGxlbmd0aCBvZiB0aGUgdmVuZG9yIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICogLSBOZXh0IG4gYnl0ZXM6IHRoZSB2ZW5kb3Igc3RyaW5nIGVuY29kZWQgaW4gVVRGLTguXHJcbiAgICAgICAgICAgICAgICAgICAqIC0gTmV4dCA0IGJ5dGVzOiBhIGxvbmcgcmVwcmVzZW50aW5nIGhvdyBtYW55IGNvbW1lbnRzIGFyZSBpbiB0aGlzIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAqIEZvciBlYWNoIGNvbW1lbnQgdGhhdCBleGlzdHM6XHJcbiAgICAgICAgICAgICAgICAgICAqIC0gRmlyc3QgNCBieXRlczogYSBsb25nIHJlcHJlc2VudGluZyB0aGUgbGVuZ3RoIG9mIHRoZSBjb21tZW50XHJcbiAgICAgICAgICAgICAgICAgICAqIC0gTmV4dCBuIGJ5dGVzOiB0aGUgY29tbWVudCBlbmNvZGVkIGluIFVURi04LlxyXG4gICAgICAgICAgICAgICAgICAgKiBUaGUgY29tbWVudCBzdHJpbmcgd2lsbCB1c3VhbGx5IGFwcGVhciBpbiBhIGZvcm1hdCBzaW1pbGFyIHRvOlxyXG4gICAgICAgICAgICAgICAgICAgKiBBUlRJU1Q9bWVcclxuICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoZSBsb25ncyBhbmQgaW50ZWdlcnMgaW4gdGhpcyBibG9jayBhcmUgZW5jb2RlZCBpbiBsaXR0bGUgZW5kaWFuXHJcbiAgICAgICAgICAgICAgICAgICAqIGFzIG9wcG9zZWQgdG8gYmlnIGVuZGlhbiBmb3IgdGhlIHJlc3Qgb2YgdGhlIEZMQUMgc3BlYy5cclxuICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtNZWRpYUZpbGVSZWFkZXJ9IGRhdGEgLSBUaGUgTWVkaWFGaWxlUmVhZGVyIHRvIHBhcnNlIHRoZSBmaWxlIHdpdGguXHJcbiAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3RhZ3NdIC0gT3B0aW9uYWwgdGFncyB0byBhbHNvIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtUYWdUeXBlfSAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0YWcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaWxlLlxyXG4gICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfcGFyc2VEYXRhXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VEYXRhKGRhdGEsIHRhZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVuZG9yTGVuZ3RoID0gZGF0YS5nZXRMb25nQXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21tZW50T2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRWZW5kb3IgPSB0aGlzLl9jb21tZW50T2Zmc2V0ICsgNDtcclxuICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGxpbmUgaXMgYWJsZSB0byByZXRyaWV2ZSB0aGUgdmVuZG9yIHN0cmluZyB0aGF0IHRoZSBWb3JiaXNDb21tZW50IGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgICogY29udGFpbnMuIEhvd2V2ZXIsIGl0IGlzIG5vdCBwYXJ0IG9mIHRoZSB0YWdzIHRoYXQgSlNNZWRpYVRhZ3Mgbm9ybWFsbHkgcmV0cmlldmVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAqIGFuZCBpcyB0aGVyZWZvcmUgY29tbWVudGVkIG91dC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgdmVuZG9yID0gZGF0YS5nZXRTdHJpbmdXaXRoQ2hhcnNldEF0KG9mZnNldFZlbmRvciwgdmVuZG9yTGVuZ3RoLCBcInV0Zi04XCIpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMaXN0ID0gdmVuZG9yTGVuZ3RoICsgb2Zmc2V0VmVuZG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIFRvIGdldCB0aGUgbWV0YWRhdGEgZnJvbSB0aGUgYmxvY2ssIHdlIGZpcnN0IGdldCB0aGUgbG9uZyB0aGF0IGNvbnRhaW5zIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIG51bWJlciBvZiBhY3R1YWwgY29tbWVudCB2YWx1ZXMgdGhhdCBhcmUgZXhpc3RlbnQgd2l0aGluIHRoZSBibG9jay5cclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEFzIHdlIGxvb3AgdGhyb3VnaCBhbGwgb2YgdGhlIGNvbW1lbnQgYmxvY2tzLCB3ZSBnZXQgdGhlIGRhdGEgbGVuZ3RoIGluIG9yZGVyIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICogZ2V0IHRoZSByaWdodCBzaXplIHN0cmluZywgYW5kIHRoZW4gZGV0ZXJtaW5lIHdoaWNoIGNhdGVnb3J5IHRoYXQgc3RyaW5nIGZhbGxzIHVuZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBkYXRhT2Zmc2V0IHZhcmlhYmxlIGlzIGNvbnN0YW50bHkgdXBkYXRlZCBzbyB0aGF0IGl0IGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICogY29tbWVudCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBwYXJzZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiBBZGRpdGlvbnMgb2YgNCBoZXJlIGFyZSB1c2VkIHRvIG1vdmUgdGhlIG9mZnNldCBwYXN0IHRoZSBmaXJzdCA0IGJ5dGVzIHdoaWNoIG9ubHkgY29udGFpblxyXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZSBsZW5ndGggb2YgdGhlIGNvbW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1Db21tZW50cyA9IGRhdGEuZ2V0TG9uZ0F0KG9mZnNldExpc3QsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YU9mZnNldCA9IG9mZnNldExpc3QgKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSwgYXJ0aXN0LCBhbGJ1bSwgdHJhY2ssIGdlbnJlLCBwaWN0dXJlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNvbW1lbnRzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBfZGF0YUxlbmd0aCA9IGRhdGEuZ2V0TG9uZ0F0KGRhdGFPZmZzZXQsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldFN0cmluZ1dpdGhDaGFyc2V0QXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldCArIDQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RhdGFMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1dGYtOFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHMuaW5kZXhPZihcIj1cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBbcy5zbGljZSgwLCBkKSwgcy5zbGljZShkICsgMSldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3BsaXRbMF0udG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVElUTEVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHNwbGl0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFSVElTVFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFydGlzdCA9IHNwbGl0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFMQlVNXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxidW0gPSBzcGxpdFsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJUUkFDS05VTUJFUlwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrID0gc3BsaXRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiR0VOUkVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5yZSA9IHNwbGl0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgKz0gNCArIF9kYXRhTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvKiBJZiBhIHBpY3R1cmUgb2Zmc2V0IHdhcyBmb3VuZCBhbmQgYXNzaWduZWQsIHRoZW4gdGhlIHJlYWRlciB3aWxsIHN0YXJ0IHByb2Nlc3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAgKiB0aGUgcGljdHVyZSBibG9jayBmcm9tIHRoYXQgcG9pbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiBBbGwgdGhlIGxlbmd0aHMgZm9yIHRoZSBwaWN0dXJlIGRhdGEgY2FuIGJlIGZvdW5kIG9ubGluZSBoZXJlOlxyXG4gICAgICAgICAgICAgICAgICAgICAqIGh0dHBzOi8veGlwaC5vcmcvZmxhYy9mb3JtYXQuaHRtbCNtZXRhZGF0YV9ibG9ja19waWN0dXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9waWN0dXJlT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VUeXBlID0gZGF0YS5nZXRMb25nQXQodGhpcy5fcGljdHVyZU9mZnNldCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TWltZUxlbmd0aCA9IHRoaXMuX3BpY3R1cmVPZmZzZXQgKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbWVMZW5ndGggPSBkYXRhLmdldExvbmdBdChvZmZzZXRNaW1lTGVuZ3RoLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRNaW1lID0gb2Zmc2V0TWltZUxlbmd0aCArIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbWltZSA9IGRhdGEuZ2V0U3RyaW5nQXQob2Zmc2V0TWltZSwgbWltZUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0RGVzY3JpcHRpb25MZW5ndGggPSBvZmZzZXRNaW1lICsgbWltZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdGlvbkxlbmd0aCA9IGRhdGEuZ2V0TG9uZ0F0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXREZXNjcmlwdGlvbkxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXREZXNjcmlwdGlvbiA9IG9mZnNldERlc2NyaXB0aW9uTGVuZ3RoICsgNDtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdGlvbiA9IGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldFN0cmluZ1dpdGhDaGFyc2V0QXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0RGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb25MZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1dGYtOFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0RGF0YUxlbmd0aCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldERlc2NyaXB0aW9uICsgZGVzY3JpcHRpb25MZW5ndGggKyAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhTGVuZ3RoID0gZGF0YS5nZXRMb25nQXQob2Zmc2V0RGF0YUxlbmd0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0RGF0YSA9IG9mZnNldERhdGFMZW5ndGggKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlRGF0YSA9IGRhdGEuZ2V0Qnl0ZXNBdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0RGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHBpY3R1cmUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogbWltZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogSU1BR0VfVFlQRVNbaW1hZ2VUeXBlXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpbWFnZURhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRkxBQ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICB0YWdzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJ0aXN0OiBhcnRpc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsYnVtOiBhbGJ1bSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2s6IHRyYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5yZTogZ2VucmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY3R1cmU6IHBpY3R1cmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRUYWdJZGVudGlmaWVyQnl0ZVJhbmdlXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOlxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGJ5dGUgcmFuZ2UgZm9yIHRoZSB0YWcgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEJlY2F1c2UgdGhlIFZvcmJpcyBjb21tZW50IGJsb2NrIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGluIGEgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICogbG9jYXRpb24sIHdlIGNhbiBvbmx5IGxvYWQgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIGZpbGUgdG8gY29uZmlybSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAqIGlzIGEgRkxBQyBmaXJzdC5cclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0J5dGVSYW5nZX0gVGhlIGJ5dGUgcmFuZ2UgdGhhdCBpZGVudGlmaWVzIHRoZSB0YWcgZm9yIGEgRkxBQy5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRUYWdJZGVudGlmaWVyQnl0ZVJhbmdlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IEZMQUNfSEVBREVSX1NJWkUsXHJcbiAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoaXMgcmVhZGVyIGNhbiByZWFkIGEgY2VydGFpbiB0YWcgZm9ybWF0LlxyXG4gICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgKiBUaGlzIGNoZWNrcyB0aGF0IHRoZSBmaXJzdCA0IGNoYXJhY3RlcnMgaW4gdGhlIGZpbGUgYXJlIGZMYUMsIHdoaWNoXHJcbiAgICAgICAgICAgICAgICAgICAqIGFjY29yZGluZyB0byB0aGUgRkxBQyBmaWxlIHNwZWNpZmljYXRpb24gc2hvdWxkIGJlIHRoZSBjaGFyYWN0ZXJzIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICogaW5kaWNhdGUgYSBGTEFDIGZpbGUuXHJcbiAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGhlYWRlciBpcyBmTGFDLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImNhblJlYWRUYWdGb3JtYXRcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhblJlYWRUYWdGb3JtYXQodGFnSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXHJcbiAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICB0YWdJZGVudGlmaWVyLnNsaWNlKDAsIDQpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQgPT09IFwiZkxhQ1wiO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gRkxBQ1RhZ1JlYWRlcjtcclxuICAgICAgICAgIH0pKE1lZGlhVGFnUmVhZGVyKTtcclxuXHJcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEZMQUNUYWdSZWFkZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IFwiLi9NZWRpYVRhZ1JlYWRlclwiOiAxMiB9LFxyXG4gICAgICBdLFxyXG4gICAgICA3OiBbXHJcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xyXG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgICAgICAgICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIlxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmXHJcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG4gICAgICAgICAgICAgICAgICBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJlxyXG4gICAgICAgICAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcclxuICAgICAgICAgICAgICAgICAgPyBcInN5bWJvbFwiXHJcbiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIG9iajtcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdHlwZW9mKG9iaik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm90b1Byb3BzKVxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcclxuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgICAgIFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcclxuICAgICAgICAgICAgICBzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xyXG4gICAgICAgICAgICBfc2V0UHJvdG90eXBlT2YgPVxyXG4gICAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XHJcbiAgICAgICAgICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbztcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XHJcbiAgICAgICAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0O1xyXG4gICAgICAgICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgY2FsbCAmJlxyXG4gICAgICAgICAgICAgIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjYWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xyXG4gICAgICAgICAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIlxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdClcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFxyXG4gICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xyXG4gICAgICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcclxuICAgICAgICAgICAgICA/IE9iamVjdC5nZXRQcm90b3R5cGVPZlxyXG4gICAgICAgICAgICAgIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIE1lZGlhVGFnUmVhZGVyID0gcmVxdWlyZShcIi4vTWVkaWFUYWdSZWFkZXJcIik7XHJcblxyXG4gICAgICAgICAgdmFyIE1lZGlhRmlsZVJlYWRlciA9IHJlcXVpcmUoXCIuL01lZGlhRmlsZVJlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgSUQzdjFUYWdSZWFkZXIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX01lZGlhVGFnUmVhZGVyKSB7XHJcbiAgICAgICAgICAgIF9pbmhlcml0cyhJRDN2MVRhZ1JlYWRlciwgX01lZGlhVGFnUmVhZGVyKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSUQzdjFUYWdSZWFkZXIpO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gSUQzdjFUYWdSZWFkZXIoKSB7XHJcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElEM3YxVGFnUmVhZGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoXHJcbiAgICAgICAgICAgICAgSUQzdjFUYWdSZWFkZXIsXHJcbiAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiX2xvYWREYXRhXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZERhdGEobWVkaWFGaWxlUmVhZGVyLCBjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZVNpemUgPSBtZWRpYUZpbGVSZWFkZXIuZ2V0U2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhRmlsZVJlYWRlci5sb2FkUmFuZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICBbZmlsZVNpemUgLSAxMjgsIGZpbGVTaXplIC0gMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9wYXJzZURhdGFcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZURhdGEoZGF0YSwgdGFncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBkYXRhLmdldFNpemUoKSAtIDEyODtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAuZ2V0U3RyaW5nV2l0aENoYXJzZXRBdChvZmZzZXQgKyAzLCAzMClcclxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnRpc3QgPSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAuZ2V0U3RyaW5nV2l0aENoYXJzZXRBdChvZmZzZXQgKyAzMywgMzApXHJcbiAgICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxidW0gPSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAuZ2V0U3RyaW5nV2l0aENoYXJzZXRBdChvZmZzZXQgKyA2MywgMzApXHJcbiAgICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeWVhciA9IGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgIC5nZXRTdHJpbmdXaXRoQ2hhcnNldEF0KG9mZnNldCArIDkzLCA0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrRmxhZyA9IGRhdGEuZ2V0Qnl0ZUF0KG9mZnNldCArIDk3ICsgMjgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IGRhdGEuZ2V0Qnl0ZUF0KG9mZnNldCArIDk3ICsgMjkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tGbGFnID09IDAgJiYgdHJhY2sgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBcIjEuMVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRTdHJpbmdXaXRoQ2hhcnNldEF0KG9mZnNldCArIDk3LCAyOClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gXCIxLjBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0U3RyaW5nV2l0aENoYXJzZXRBdChvZmZzZXQgKyA5NywgMzApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdHJhY2sgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdlbnJlSWR4ID0gZGF0YS5nZXRCeXRlQXQob2Zmc2V0ICsgOTcgKyAzMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChnZW5yZUlkeCA8IDI1NSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGdlbnJlID0gR0VOUkVTW2dlbnJlSWR4XTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGdlbnJlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIklEM1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnRpc3Q6IGFydGlzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxidW06IGFsYnVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ZWFyOiB5ZWFyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50OiBjb21tZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5yZTogZ2VucmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gJEZsb3dJc3N1ZSAtIGZsb3cgaXMgbm90IGhhcHB5IHdpdGggYWRkaW5nIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAgICAgIHRhZy50YWdzLnRyYWNrID0gdHJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImdldFRhZ0lkZW50aWZpZXJCeXRlUmFuZ2VcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRhZ0lkZW50aWZpZXJCeXRlUmFuZ2UoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlkZW50aWZpZXIgaXMgVEFHIGFuZCBpcyBhdCBvZmZzZXQ6IC0xMjguIEhvd2V2ZXIsIHRvIGF2b2lkIGFcclxuICAgICAgICAgICAgICAgICAgICAvLyBmZXRjaCBmb3IgdGhlIHRhZyBpZGVudGlmaWVyIGFuZCBhbm90aGVyIGZvciB0aGUgZGF0YSwgd2UgbG9hZCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbnRpcmUgZGF0YSBzaW5jZSBpdCdzIHNvIHNtYWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IC0xMjgsXHJcbiAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IDEyOCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImNhblJlYWRUYWdGb3JtYXRcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhblJlYWRUYWdGb3JtYXQodGFnSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXHJcbiAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICB0YWdJZGVudGlmaWVyLnNsaWNlKDAsIDMpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQgPT09IFwiVEFHXCI7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBJRDN2MVRhZ1JlYWRlcjtcclxuICAgICAgICAgIH0pKE1lZGlhVGFnUmVhZGVyKTtcclxuXHJcbiAgICAgICAgICB2YXIgR0VOUkVTID0gW1xyXG4gICAgICAgICAgICBcIkJsdWVzXCIsXHJcbiAgICAgICAgICAgIFwiQ2xhc3NpYyBSb2NrXCIsXHJcbiAgICAgICAgICAgIFwiQ291bnRyeVwiLFxyXG4gICAgICAgICAgICBcIkRhbmNlXCIsXHJcbiAgICAgICAgICAgIFwiRGlzY29cIixcclxuICAgICAgICAgICAgXCJGdW5rXCIsXHJcbiAgICAgICAgICAgIFwiR3J1bmdlXCIsXHJcbiAgICAgICAgICAgIFwiSGlwLUhvcFwiLFxyXG4gICAgICAgICAgICBcIkphenpcIixcclxuICAgICAgICAgICAgXCJNZXRhbFwiLFxyXG4gICAgICAgICAgICBcIk5ldyBBZ2VcIixcclxuICAgICAgICAgICAgXCJPbGRpZXNcIixcclxuICAgICAgICAgICAgXCJPdGhlclwiLFxyXG4gICAgICAgICAgICBcIlBvcFwiLFxyXG4gICAgICAgICAgICBcIlImQlwiLFxyXG4gICAgICAgICAgICBcIlJhcFwiLFxyXG4gICAgICAgICAgICBcIlJlZ2dhZVwiLFxyXG4gICAgICAgICAgICBcIlJvY2tcIixcclxuICAgICAgICAgICAgXCJUZWNobm9cIixcclxuICAgICAgICAgICAgXCJJbmR1c3RyaWFsXCIsXHJcbiAgICAgICAgICAgIFwiQWx0ZXJuYXRpdmVcIixcclxuICAgICAgICAgICAgXCJTa2FcIixcclxuICAgICAgICAgICAgXCJEZWF0aCBNZXRhbFwiLFxyXG4gICAgICAgICAgICBcIlByYW5rc1wiLFxyXG4gICAgICAgICAgICBcIlNvdW5kdHJhY2tcIixcclxuICAgICAgICAgICAgXCJFdXJvLVRlY2hub1wiLFxyXG4gICAgICAgICAgICBcIkFtYmllbnRcIixcclxuICAgICAgICAgICAgXCJUcmlwLUhvcFwiLFxyXG4gICAgICAgICAgICBcIlZvY2FsXCIsXHJcbiAgICAgICAgICAgIFwiSmF6eitGdW5rXCIsXHJcbiAgICAgICAgICAgIFwiRnVzaW9uXCIsXHJcbiAgICAgICAgICAgIFwiVHJhbmNlXCIsXHJcbiAgICAgICAgICAgIFwiQ2xhc3NpY2FsXCIsXHJcbiAgICAgICAgICAgIFwiSW5zdHJ1bWVudGFsXCIsXHJcbiAgICAgICAgICAgIFwiQWNpZFwiLFxyXG4gICAgICAgICAgICBcIkhvdXNlXCIsXHJcbiAgICAgICAgICAgIFwiR2FtZVwiLFxyXG4gICAgICAgICAgICBcIlNvdW5kIENsaXBcIixcclxuICAgICAgICAgICAgXCJHb3NwZWxcIixcclxuICAgICAgICAgICAgXCJOb2lzZVwiLFxyXG4gICAgICAgICAgICBcIkFsdGVyblJvY2tcIixcclxuICAgICAgICAgICAgXCJCYXNzXCIsXHJcbiAgICAgICAgICAgIFwiU291bFwiLFxyXG4gICAgICAgICAgICBcIlB1bmtcIixcclxuICAgICAgICAgICAgXCJTcGFjZVwiLFxyXG4gICAgICAgICAgICBcIk1lZGl0YXRpdmVcIixcclxuICAgICAgICAgICAgXCJJbnN0cnVtZW50YWwgUG9wXCIsXHJcbiAgICAgICAgICAgIFwiSW5zdHJ1bWVudGFsIFJvY2tcIixcclxuICAgICAgICAgICAgXCJFdGhuaWNcIixcclxuICAgICAgICAgICAgXCJHb3RoaWNcIixcclxuICAgICAgICAgICAgXCJEYXJrd2F2ZVwiLFxyXG4gICAgICAgICAgICBcIlRlY2huby1JbmR1c3RyaWFsXCIsXHJcbiAgICAgICAgICAgIFwiRWxlY3Ryb25pY1wiLFxyXG4gICAgICAgICAgICBcIlBvcC1Gb2xrXCIsXHJcbiAgICAgICAgICAgIFwiRXVyb2RhbmNlXCIsXHJcbiAgICAgICAgICAgIFwiRHJlYW1cIixcclxuICAgICAgICAgICAgXCJTb3V0aGVybiBSb2NrXCIsXHJcbiAgICAgICAgICAgIFwiQ29tZWR5XCIsXHJcbiAgICAgICAgICAgIFwiQ3VsdFwiLFxyXG4gICAgICAgICAgICBcIkdhbmdzdGFcIixcclxuICAgICAgICAgICAgXCJUb3AgNDBcIixcclxuICAgICAgICAgICAgXCJDaHJpc3RpYW4gUmFwXCIsXHJcbiAgICAgICAgICAgIFwiUG9wL0Z1bmtcIixcclxuICAgICAgICAgICAgXCJKdW5nbGVcIixcclxuICAgICAgICAgICAgXCJOYXRpdmUgQW1lcmljYW5cIixcclxuICAgICAgICAgICAgXCJDYWJhcmV0XCIsXHJcbiAgICAgICAgICAgIFwiTmV3IFdhdmVcIixcclxuICAgICAgICAgICAgXCJQc3ljaGFkZWxpY1wiLFxyXG4gICAgICAgICAgICBcIlJhdmVcIixcclxuICAgICAgICAgICAgXCJTaG93dHVuZXNcIixcclxuICAgICAgICAgICAgXCJUcmFpbGVyXCIsXHJcbiAgICAgICAgICAgIFwiTG8tRmlcIixcclxuICAgICAgICAgICAgXCJUcmliYWxcIixcclxuICAgICAgICAgICAgXCJBY2lkIFB1bmtcIixcclxuICAgICAgICAgICAgXCJBY2lkIEphenpcIixcclxuICAgICAgICAgICAgXCJQb2xrYVwiLFxyXG4gICAgICAgICAgICBcIlJldHJvXCIsXHJcbiAgICAgICAgICAgIFwiTXVzaWNhbFwiLFxyXG4gICAgICAgICAgICBcIlJvY2sgJiBSb2xsXCIsXHJcbiAgICAgICAgICAgIFwiSGFyZCBSb2NrXCIsXHJcbiAgICAgICAgICAgIFwiRm9sa1wiLFxyXG4gICAgICAgICAgICBcIkZvbGstUm9ja1wiLFxyXG4gICAgICAgICAgICBcIk5hdGlvbmFsIEZvbGtcIixcclxuICAgICAgICAgICAgXCJTd2luZ1wiLFxyXG4gICAgICAgICAgICBcIkZhc3QgRnVzaW9uXCIsXHJcbiAgICAgICAgICAgIFwiQmVib2JcIixcclxuICAgICAgICAgICAgXCJMYXRpblwiLFxyXG4gICAgICAgICAgICBcIlJldml2YWxcIixcclxuICAgICAgICAgICAgXCJDZWx0aWNcIixcclxuICAgICAgICAgICAgXCJCbHVlZ3Jhc3NcIixcclxuICAgICAgICAgICAgXCJBdmFudGdhcmRlXCIsXHJcbiAgICAgICAgICAgIFwiR290aGljIFJvY2tcIixcclxuICAgICAgICAgICAgXCJQcm9ncmVzc2l2ZSBSb2NrXCIsXHJcbiAgICAgICAgICAgIFwiUHN5Y2hlZGVsaWMgUm9ja1wiLFxyXG4gICAgICAgICAgICBcIlN5bXBob25pYyBSb2NrXCIsXHJcbiAgICAgICAgICAgIFwiU2xvdyBSb2NrXCIsXHJcbiAgICAgICAgICAgIFwiQmlnIEJhbmRcIixcclxuICAgICAgICAgICAgXCJDaG9ydXNcIixcclxuICAgICAgICAgICAgXCJFYXN5IExpc3RlbmluZ1wiLFxyXG4gICAgICAgICAgICBcIkFjb3VzdGljXCIsXHJcbiAgICAgICAgICAgIFwiSHVtb3VyXCIsXHJcbiAgICAgICAgICAgIFwiU3BlZWNoXCIsXHJcbiAgICAgICAgICAgIFwiQ2hhbnNvblwiLFxyXG4gICAgICAgICAgICBcIk9wZXJhXCIsXHJcbiAgICAgICAgICAgIFwiQ2hhbWJlciBNdXNpY1wiLFxyXG4gICAgICAgICAgICBcIlNvbmF0YVwiLFxyXG4gICAgICAgICAgICBcIlN5bXBob255XCIsXHJcbiAgICAgICAgICAgIFwiQm9vdHkgQmFzc1wiLFxyXG4gICAgICAgICAgICBcIlByaW11c1wiLFxyXG4gICAgICAgICAgICBcIlBvcm4gR3Jvb3ZlXCIsXHJcbiAgICAgICAgICAgIFwiU2F0aXJlXCIsXHJcbiAgICAgICAgICAgIFwiU2xvdyBKYW1cIixcclxuICAgICAgICAgICAgXCJDbHViXCIsXHJcbiAgICAgICAgICAgIFwiVGFuZ29cIixcclxuICAgICAgICAgICAgXCJTYW1iYVwiLFxyXG4gICAgICAgICAgICBcIkZvbGtsb3JlXCIsXHJcbiAgICAgICAgICAgIFwiQmFsbGFkXCIsXHJcbiAgICAgICAgICAgIFwiUG93ZXIgQmFsbGFkXCIsXHJcbiAgICAgICAgICAgIFwiUmh5dGhtaWMgU291bFwiLFxyXG4gICAgICAgICAgICBcIkZyZWVzdHlsZVwiLFxyXG4gICAgICAgICAgICBcIkR1ZXRcIixcclxuICAgICAgICAgICAgXCJQdW5rIFJvY2tcIixcclxuICAgICAgICAgICAgXCJEcnVtIFNvbG9cIixcclxuICAgICAgICAgICAgXCJBY2FwZWxsYVwiLFxyXG4gICAgICAgICAgICBcIkV1cm8tSG91c2VcIixcclxuICAgICAgICAgICAgXCJEYW5jZSBIYWxsXCIsXHJcbiAgICAgICAgICBdO1xyXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBJRDN2MVRhZ1JlYWRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHsgXCIuL01lZGlhRmlsZVJlYWRlclwiOiAxMSwgXCIuL01lZGlhVGFnUmVhZGVyXCI6IDEyIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIDg6IFtcclxuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XHJcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3RvUHJvcHMpXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcclxuICAgICAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIE1lZGlhRmlsZVJlYWRlciA9IHJlcXVpcmUoXCIuL01lZGlhRmlsZVJlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgU3RyaW5nVXRpbHMgPSByZXF1aXJlKFwiLi9TdHJpbmdVdGlsc1wiKTtcclxuXHJcbiAgICAgICAgICB2YXIgQXJyYXlGaWxlUmVhZGVyID0gcmVxdWlyZShcIi4vQXJyYXlGaWxlUmVhZGVyXCIpO1xyXG5cclxuICAgICAgICAgIHZhciBGUkFNRV9ERVNDUklQVElPTlMgPSB7XHJcbiAgICAgICAgICAgIC8vIHYyLjJcclxuICAgICAgICAgICAgQlVGOiBcIlJlY29tbWVuZGVkIGJ1ZmZlciBzaXplXCIsXHJcbiAgICAgICAgICAgIENOVDogXCJQbGF5IGNvdW50ZXJcIixcclxuICAgICAgICAgICAgQ09NOiBcIkNvbW1lbnRzXCIsXHJcbiAgICAgICAgICAgIENSQTogXCJBdWRpbyBlbmNyeXB0aW9uXCIsXHJcbiAgICAgICAgICAgIENSTTogXCJFbmNyeXB0ZWQgbWV0YSBmcmFtZVwiLFxyXG4gICAgICAgICAgICBFVEM6IFwiRXZlbnQgdGltaW5nIGNvZGVzXCIsXHJcbiAgICAgICAgICAgIEVRVTogXCJFcXVhbGl6YXRpb25cIixcclxuICAgICAgICAgICAgR0VPOiBcIkdlbmVyYWwgZW5jYXBzdWxhdGVkIG9iamVjdFwiLFxyXG4gICAgICAgICAgICBJUEw6IFwiSW52b2x2ZWQgcGVvcGxlIGxpc3RcIixcclxuICAgICAgICAgICAgTE5LOiBcIkxpbmtlZCBpbmZvcm1hdGlvblwiLFxyXG4gICAgICAgICAgICBNQ0k6IFwiTXVzaWMgQ0QgSWRlbnRpZmllclwiLFxyXG4gICAgICAgICAgICBNTEw6IFwiTVBFRyBsb2NhdGlvbiBsb29rdXAgdGFibGVcIixcclxuICAgICAgICAgICAgUElDOiBcIkF0dGFjaGVkIHBpY3R1cmVcIixcclxuICAgICAgICAgICAgUE9QOiBcIlBvcHVsYXJpbWV0ZXJcIixcclxuICAgICAgICAgICAgUkVWOiBcIlJldmVyYlwiLFxyXG4gICAgICAgICAgICBSVkE6IFwiUmVsYXRpdmUgdm9sdW1lIGFkanVzdG1lbnRcIixcclxuICAgICAgICAgICAgU0xUOiBcIlN5bmNocm9uaXplZCBseXJpYy90ZXh0XCIsXHJcbiAgICAgICAgICAgIFNUQzogXCJTeW5jZWQgdGVtcG8gY29kZXNcIixcclxuICAgICAgICAgICAgVEFMOiBcIkFsYnVtL01vdmllL1Nob3cgdGl0bGVcIixcclxuICAgICAgICAgICAgVEJQOiBcIkJQTSAoQmVhdHMgUGVyIE1pbnV0ZSlcIixcclxuICAgICAgICAgICAgVENNOiBcIkNvbXBvc2VyXCIsXHJcbiAgICAgICAgICAgIFRDTzogXCJDb250ZW50IHR5cGVcIixcclxuICAgICAgICAgICAgVENSOiBcIkNvcHlyaWdodCBtZXNzYWdlXCIsXHJcbiAgICAgICAgICAgIFREQTogXCJEYXRlXCIsXHJcbiAgICAgICAgICAgIFREWTogXCJQbGF5bGlzdCBkZWxheVwiLFxyXG4gICAgICAgICAgICBURU46IFwiRW5jb2RlZCBieVwiLFxyXG4gICAgICAgICAgICBURlQ6IFwiRmlsZSB0eXBlXCIsXHJcbiAgICAgICAgICAgIFRJTTogXCJUaW1lXCIsXHJcbiAgICAgICAgICAgIFRLRTogXCJJbml0aWFsIGtleVwiLFxyXG4gICAgICAgICAgICBUTEE6IFwiTGFuZ3VhZ2UocylcIixcclxuICAgICAgICAgICAgVExFOiBcIkxlbmd0aFwiLFxyXG4gICAgICAgICAgICBUTVQ6IFwiTWVkaWEgdHlwZVwiLFxyXG4gICAgICAgICAgICBUT0E6IFwiT3JpZ2luYWwgYXJ0aXN0KHMpL3BlcmZvcm1lcihzKVwiLFxyXG4gICAgICAgICAgICBUT0Y6IFwiT3JpZ2luYWwgZmlsZW5hbWVcIixcclxuICAgICAgICAgICAgVE9MOiBcIk9yaWdpbmFsIEx5cmljaXN0KHMpL3RleHQgd3JpdGVyKHMpXCIsXHJcbiAgICAgICAgICAgIFRPUjogXCJPcmlnaW5hbCByZWxlYXNlIHllYXJcIixcclxuICAgICAgICAgICAgVE9UOiBcIk9yaWdpbmFsIGFsYnVtL01vdmllL1Nob3cgdGl0bGVcIixcclxuICAgICAgICAgICAgVFAxOiBcIkxlYWQgYXJ0aXN0KHMpL0xlYWQgcGVyZm9ybWVyKHMpL1NvbG9pc3QocykvUGVyZm9ybWluZyBncm91cFwiLFxyXG4gICAgICAgICAgICBUUDI6IFwiQmFuZC9PcmNoZXN0cmEvQWNjb21wYW5pbWVudFwiLFxyXG4gICAgICAgICAgICBUUDM6IFwiQ29uZHVjdG9yL1BlcmZvcm1lciByZWZpbmVtZW50XCIsXHJcbiAgICAgICAgICAgIFRQNDogXCJJbnRlcnByZXRlZCwgcmVtaXhlZCwgb3Igb3RoZXJ3aXNlIG1vZGlmaWVkIGJ5XCIsXHJcbiAgICAgICAgICAgIFRQQTogXCJQYXJ0IG9mIGEgc2V0XCIsXHJcbiAgICAgICAgICAgIFRQQjogXCJQdWJsaXNoZXJcIixcclxuICAgICAgICAgICAgVFJDOiBcIklTUkMgKEludGVybmF0aW9uYWwgU3RhbmRhcmQgUmVjb3JkaW5nIENvZGUpXCIsXHJcbiAgICAgICAgICAgIFRSRDogXCJSZWNvcmRpbmcgZGF0ZXNcIixcclxuICAgICAgICAgICAgVFJLOiBcIlRyYWNrIG51bWJlci9Qb3NpdGlvbiBpbiBzZXRcIixcclxuICAgICAgICAgICAgVFNJOiBcIlNpemVcIixcclxuICAgICAgICAgICAgVFNTOiBcIlNvZnR3YXJlL2hhcmR3YXJlIGFuZCBzZXR0aW5ncyB1c2VkIGZvciBlbmNvZGluZ1wiLFxyXG4gICAgICAgICAgICBUVDE6IFwiQ29udGVudCBncm91cCBkZXNjcmlwdGlvblwiLFxyXG4gICAgICAgICAgICBUVDI6IFwiVGl0bGUvU29uZ25hbWUvQ29udGVudCBkZXNjcmlwdGlvblwiLFxyXG4gICAgICAgICAgICBUVDM6IFwiU3VidGl0bGUvRGVzY3JpcHRpb24gcmVmaW5lbWVudFwiLFxyXG4gICAgICAgICAgICBUWFQ6IFwiTHlyaWNpc3QvdGV4dCB3cml0ZXJcIixcclxuICAgICAgICAgICAgVFhYOiBcIlVzZXIgZGVmaW5lZCB0ZXh0IGluZm9ybWF0aW9uIGZyYW1lXCIsXHJcbiAgICAgICAgICAgIFRZRTogXCJZZWFyXCIsXHJcbiAgICAgICAgICAgIFVGSTogXCJVbmlxdWUgZmlsZSBpZGVudGlmaWVyXCIsXHJcbiAgICAgICAgICAgIFVMVDogXCJVbnN5Y2hyb25pemVkIGx5cmljL3RleHQgdHJhbnNjcmlwdGlvblwiLFxyXG4gICAgICAgICAgICBXQUY6IFwiT2ZmaWNpYWwgYXVkaW8gZmlsZSB3ZWJwYWdlXCIsXHJcbiAgICAgICAgICAgIFdBUjogXCJPZmZpY2lhbCBhcnRpc3QvcGVyZm9ybWVyIHdlYnBhZ2VcIixcclxuICAgICAgICAgICAgV0FTOiBcIk9mZmljaWFsIGF1ZGlvIHNvdXJjZSB3ZWJwYWdlXCIsXHJcbiAgICAgICAgICAgIFdDTTogXCJDb21tZXJjaWFsIGluZm9ybWF0aW9uXCIsXHJcbiAgICAgICAgICAgIFdDUDogXCJDb3B5cmlnaHQvTGVnYWwgaW5mb3JtYXRpb25cIixcclxuICAgICAgICAgICAgV1BCOiBcIlB1Ymxpc2hlcnMgb2ZmaWNpYWwgd2VicGFnZVwiLFxyXG4gICAgICAgICAgICBXWFg6IFwiVXNlciBkZWZpbmVkIFVSTCBsaW5rIGZyYW1lXCIsXHJcbiAgICAgICAgICAgIC8vIHYyLjNcclxuICAgICAgICAgICAgQUVOQzogXCJBdWRpbyBlbmNyeXB0aW9uXCIsXHJcbiAgICAgICAgICAgIEFQSUM6IFwiQXR0YWNoZWQgcGljdHVyZVwiLFxyXG4gICAgICAgICAgICBBU1BJOiBcIkF1ZGlvIHNlZWsgcG9pbnQgaW5kZXhcIixcclxuICAgICAgICAgICAgQ0hBUDogXCJDaGFwdGVyXCIsXHJcbiAgICAgICAgICAgIENUT0M6IFwiVGFibGUgb2YgY29udGVudHNcIixcclxuICAgICAgICAgICAgQ09NTTogXCJDb21tZW50c1wiLFxyXG4gICAgICAgICAgICBDT01SOiBcIkNvbW1lcmNpYWwgZnJhbWVcIixcclxuICAgICAgICAgICAgRU5DUjogXCJFbmNyeXB0aW9uIG1ldGhvZCByZWdpc3RyYXRpb25cIixcclxuICAgICAgICAgICAgRVFVMjogXCJFcXVhbGlzYXRpb24gKDIpXCIsXHJcbiAgICAgICAgICAgIEVRVUE6IFwiRXF1YWxpemF0aW9uXCIsXHJcbiAgICAgICAgICAgIEVUQ086IFwiRXZlbnQgdGltaW5nIGNvZGVzXCIsXHJcbiAgICAgICAgICAgIEdFT0I6IFwiR2VuZXJhbCBlbmNhcHN1bGF0ZWQgb2JqZWN0XCIsXHJcbiAgICAgICAgICAgIEdSSUQ6IFwiR3JvdXAgaWRlbnRpZmljYXRpb24gcmVnaXN0cmF0aW9uXCIsXHJcbiAgICAgICAgICAgIElQTFM6IFwiSW52b2x2ZWQgcGVvcGxlIGxpc3RcIixcclxuICAgICAgICAgICAgTElOSzogXCJMaW5rZWQgaW5mb3JtYXRpb25cIixcclxuICAgICAgICAgICAgTUNESTogXCJNdXNpYyBDRCBpZGVudGlmaWVyXCIsXHJcbiAgICAgICAgICAgIE1MTFQ6IFwiTVBFRyBsb2NhdGlvbiBsb29rdXAgdGFibGVcIixcclxuICAgICAgICAgICAgT1dORTogXCJPd25lcnNoaXAgZnJhbWVcIixcclxuICAgICAgICAgICAgUFJJVjogXCJQcml2YXRlIGZyYW1lXCIsXHJcbiAgICAgICAgICAgIFBDTlQ6IFwiUGxheSBjb3VudGVyXCIsXHJcbiAgICAgICAgICAgIFBPUE06IFwiUG9wdWxhcmltZXRlclwiLFxyXG4gICAgICAgICAgICBQT1NTOiBcIlBvc2l0aW9uIHN5bmNocm9uaXNhdGlvbiBmcmFtZVwiLFxyXG4gICAgICAgICAgICBSQlVGOiBcIlJlY29tbWVuZGVkIGJ1ZmZlciBzaXplXCIsXHJcbiAgICAgICAgICAgIFJWQTI6IFwiUmVsYXRpdmUgdm9sdW1lIGFkanVzdG1lbnQgKDIpXCIsXHJcbiAgICAgICAgICAgIFJWQUQ6IFwiUmVsYXRpdmUgdm9sdW1lIGFkanVzdG1lbnRcIixcclxuICAgICAgICAgICAgUlZSQjogXCJSZXZlcmJcIixcclxuICAgICAgICAgICAgU0VFSzogXCJTZWVrIGZyYW1lXCIsXHJcbiAgICAgICAgICAgIFNZTFQ6IFwiU3luY2hyb25pemVkIGx5cmljL3RleHRcIixcclxuICAgICAgICAgICAgU1lUQzogXCJTeW5jaHJvbml6ZWQgdGVtcG8gY29kZXNcIixcclxuICAgICAgICAgICAgVEFMQjogXCJBbGJ1bS9Nb3ZpZS9TaG93IHRpdGxlXCIsXHJcbiAgICAgICAgICAgIFRCUE06IFwiQlBNIChiZWF0cyBwZXIgbWludXRlKVwiLFxyXG4gICAgICAgICAgICBUQ09NOiBcIkNvbXBvc2VyXCIsXHJcbiAgICAgICAgICAgIFRDT046IFwiQ29udGVudCB0eXBlXCIsXHJcbiAgICAgICAgICAgIFRDT1A6IFwiQ29weXJpZ2h0IG1lc3NhZ2VcIixcclxuICAgICAgICAgICAgVERBVDogXCJEYXRlXCIsXHJcbiAgICAgICAgICAgIFRETFk6IFwiUGxheWxpc3QgZGVsYXlcIixcclxuICAgICAgICAgICAgVERSQzogXCJSZWNvcmRpbmcgdGltZVwiLFxyXG4gICAgICAgICAgICBURFJMOiBcIlJlbGVhc2UgdGltZVwiLFxyXG4gICAgICAgICAgICBURFRHOiBcIlRhZ2dpbmcgdGltZVwiLFxyXG4gICAgICAgICAgICBURU5DOiBcIkVuY29kZWQgYnlcIixcclxuICAgICAgICAgICAgVEVYVDogXCJMeXJpY2lzdC9UZXh0IHdyaXRlclwiLFxyXG4gICAgICAgICAgICBURkxUOiBcIkZpbGUgdHlwZVwiLFxyXG4gICAgICAgICAgICBUSU1FOiBcIlRpbWVcIixcclxuICAgICAgICAgICAgVElQTDogXCJJbnZvbHZlZCBwZW9wbGUgbGlzdFwiLFxyXG4gICAgICAgICAgICBUSVQxOiBcIkNvbnRlbnQgZ3JvdXAgZGVzY3JpcHRpb25cIixcclxuICAgICAgICAgICAgVElUMjogXCJUaXRsZS9zb25nbmFtZS9jb250ZW50IGRlc2NyaXB0aW9uXCIsXHJcbiAgICAgICAgICAgIFRJVDM6IFwiU3VidGl0bGUvRGVzY3JpcHRpb24gcmVmaW5lbWVudFwiLFxyXG4gICAgICAgICAgICBUS0VZOiBcIkluaXRpYWwga2V5XCIsXHJcbiAgICAgICAgICAgIFRMQU46IFwiTGFuZ3VhZ2UocylcIixcclxuICAgICAgICAgICAgVExFTjogXCJMZW5ndGhcIixcclxuICAgICAgICAgICAgVE1DTDogXCJNdXNpY2lhbiBjcmVkaXRzIGxpc3RcIixcclxuICAgICAgICAgICAgVE1FRDogXCJNZWRpYSB0eXBlXCIsXHJcbiAgICAgICAgICAgIFRNT086IFwiTW9vZFwiLFxyXG4gICAgICAgICAgICBUT0FMOiBcIk9yaWdpbmFsIGFsYnVtL21vdmllL3Nob3cgdGl0bGVcIixcclxuICAgICAgICAgICAgVE9GTjogXCJPcmlnaW5hbCBmaWxlbmFtZVwiLFxyXG4gICAgICAgICAgICBUT0xZOiBcIk9yaWdpbmFsIGx5cmljaXN0KHMpL3RleHQgd3JpdGVyKHMpXCIsXHJcbiAgICAgICAgICAgIFRPUEU6IFwiT3JpZ2luYWwgYXJ0aXN0KHMpL3BlcmZvcm1lcihzKVwiLFxyXG4gICAgICAgICAgICBUT1JZOiBcIk9yaWdpbmFsIHJlbGVhc2UgeWVhclwiLFxyXG4gICAgICAgICAgICBUT1dOOiBcIkZpbGUgb3duZXIvbGljZW5zZWVcIixcclxuICAgICAgICAgICAgVFBFMTogXCJMZWFkIHBlcmZvcm1lcihzKS9Tb2xvaXN0KHMpXCIsXHJcbiAgICAgICAgICAgIFRQRTI6IFwiQmFuZC9vcmNoZXN0cmEvYWNjb21wYW5pbWVudFwiLFxyXG4gICAgICAgICAgICBUUEUzOiBcIkNvbmR1Y3Rvci9wZXJmb3JtZXIgcmVmaW5lbWVudFwiLFxyXG4gICAgICAgICAgICBUUEU0OiBcIkludGVycHJldGVkLCByZW1peGVkLCBvciBvdGhlcndpc2UgbW9kaWZpZWQgYnlcIixcclxuICAgICAgICAgICAgVFBPUzogXCJQYXJ0IG9mIGEgc2V0XCIsXHJcbiAgICAgICAgICAgIFRQUk86IFwiUHJvZHVjZWQgbm90aWNlXCIsXHJcbiAgICAgICAgICAgIFRQVUI6IFwiUHVibGlzaGVyXCIsXHJcbiAgICAgICAgICAgIFRSQ0s6IFwiVHJhY2sgbnVtYmVyL1Bvc2l0aW9uIGluIHNldFwiLFxyXG4gICAgICAgICAgICBUUkRBOiBcIlJlY29yZGluZyBkYXRlc1wiLFxyXG4gICAgICAgICAgICBUUlNOOiBcIkludGVybmV0IHJhZGlvIHN0YXRpb24gbmFtZVwiLFxyXG4gICAgICAgICAgICBUUlNPOiBcIkludGVybmV0IHJhZGlvIHN0YXRpb24gb3duZXJcIixcclxuICAgICAgICAgICAgVFNPQTogXCJBbGJ1bSBzb3J0IG9yZGVyXCIsXHJcbiAgICAgICAgICAgIFRTT1A6IFwiUGVyZm9ybWVyIHNvcnQgb3JkZXJcIixcclxuICAgICAgICAgICAgVFNPVDogXCJUaXRsZSBzb3J0IG9yZGVyXCIsXHJcbiAgICAgICAgICAgIFRTSVo6IFwiU2l6ZVwiLFxyXG4gICAgICAgICAgICBUU1JDOiBcIklTUkMgKGludGVybmF0aW9uYWwgc3RhbmRhcmQgcmVjb3JkaW5nIGNvZGUpXCIsXHJcbiAgICAgICAgICAgIFRTU0U6IFwiU29mdHdhcmUvSGFyZHdhcmUgYW5kIHNldHRpbmdzIHVzZWQgZm9yIGVuY29kaW5nXCIsXHJcbiAgICAgICAgICAgIFRTU1Q6IFwiU2V0IHN1YnRpdGxlXCIsXHJcbiAgICAgICAgICAgIFRZRVI6IFwiWWVhclwiLFxyXG4gICAgICAgICAgICBUWFhYOiBcIlVzZXIgZGVmaW5lZCB0ZXh0IGluZm9ybWF0aW9uIGZyYW1lXCIsXHJcbiAgICAgICAgICAgIFVGSUQ6IFwiVW5pcXVlIGZpbGUgaWRlbnRpZmllclwiLFxyXG4gICAgICAgICAgICBVU0VSOiBcIlRlcm1zIG9mIHVzZVwiLFxyXG4gICAgICAgICAgICBVU0xUOiBcIlVuc3ljaHJvbml6ZWQgbHlyaWMvdGV4dCB0cmFuc2NyaXB0aW9uXCIsXHJcbiAgICAgICAgICAgIFdDT006IFwiQ29tbWVyY2lhbCBpbmZvcm1hdGlvblwiLFxyXG4gICAgICAgICAgICBXQ09QOiBcIkNvcHlyaWdodC9MZWdhbCBpbmZvcm1hdGlvblwiLFxyXG4gICAgICAgICAgICBXT0FGOiBcIk9mZmljaWFsIGF1ZGlvIGZpbGUgd2VicGFnZVwiLFxyXG4gICAgICAgICAgICBXT0FSOiBcIk9mZmljaWFsIGFydGlzdC9wZXJmb3JtZXIgd2VicGFnZVwiLFxyXG4gICAgICAgICAgICBXT0FTOiBcIk9mZmljaWFsIGF1ZGlvIHNvdXJjZSB3ZWJwYWdlXCIsXHJcbiAgICAgICAgICAgIFdPUlM6IFwiT2ZmaWNpYWwgaW50ZXJuZXQgcmFkaW8gc3RhdGlvbiBob21lcGFnZVwiLFxyXG4gICAgICAgICAgICBXUEFZOiBcIlBheW1lbnRcIixcclxuICAgICAgICAgICAgV1BVQjogXCJQdWJsaXNoZXJzIG9mZmljaWFsIHdlYnBhZ2VcIixcclxuICAgICAgICAgICAgV1hYWDogXCJVc2VyIGRlZmluZWQgVVJMIGxpbmsgZnJhbWVcIixcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgdmFyIElEM3YyRnJhbWVSZWFkZXIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIElEM3YyRnJhbWVSZWFkZXIoKSB7XHJcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElEM3YyRnJhbWVSZWFkZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSUQzdjJGcmFtZVJlYWRlciwgbnVsbCwgW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogXCJnZXRGcmFtZVJlYWRlckZ1bmN0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnJhbWVSZWFkZXJGdW5jdGlvbihmcmFtZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUlkIGluIGZyYW1lUmVhZGVyRnVuY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lUmVhZGVyRnVuY3Rpb25zW2ZyYW1lSWRdO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lSWRbMF0gPT09IFwiVFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGZyYW1lIGlkcyBzdGFydGluZyB3aXRoIFQgYXJlIHRleHQgdGFncy5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWVSZWFkZXJGdW5jdGlvbnNbXCJUKlwiXTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmcmFtZUlkWzBdID09PSBcIldcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBmcmFtZSBpZHMgc3RhcnRpbmcgd2l0aCBXIGFyZSB1cmwgdGFncy5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWVSZWFkZXJGdW5jdGlvbnNbXCJXKlwiXTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWxsIHRoZSBmcmFtZXMgY29uc2lzdHMgb2YgYSBmcmFtZSBoZWFkZXIgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZmllbGRzXHJcbiAgICAgICAgICAgICAgICAgKiBjb250YWluaW5nIHRoZSBhY3R1YWwgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZnJhbWUgSUQgbWFkZSBvdXQgb2YgdGhlIGNoYXJhY3RlcnMgY2FwaXRhbCBBLVogYW5kIDAtOS4gSWRlbnRpZmllcnNcclxuICAgICAgICAgICAgICAgICAqIGJlZ2lubmluZyB3aXRoIFwiWFwiLCBcIllcIiBhbmQgXCJaXCIgYXJlIGZvciBleHBlcmltZW50YWwgdXNlIGFuZCBmcmVlIGZvclxyXG4gICAgICAgICAgICAgICAgICogZXZlcnlvbmUgdG8gdXNlLCB3aXRob3V0IHRoZSBuZWVkIHRvIHNldCB0aGUgZXhwZXJpbWVudGFsIGJpdCBpbiB0aGUgdGFnXHJcbiAgICAgICAgICAgICAgICAgKiBoZWFkZXIuIEhhdmUgaW4gbWluZCB0aGF0IHNvbWVvbmUgZWxzZSBtaWdodCBoYXZlIHVzZWQgdGhlIHNhbWUgaWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgICogYXMgeW91LiBBbGwgb3RoZXIgaWRlbnRpZmllcnMgYXJlIGVpdGhlciB1c2VkIG9yIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlLlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGZyYW1lIElEIGlzIGZvbGxvd2VkIGJ5IGEgc2l6ZSBkZXNjcmlwdG9yLCBtYWtpbmcgYSB0b3RhbCBoZWFkZXIgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICogb2YgdGVuIGJ5dGVzIGluIGV2ZXJ5IGZyYW1lLiBUaGUgc2l6ZSBpcyBjYWxjdWxhdGVkIGFzIGZyYW1lIHNpemUgZXhjbHVkaW5nXHJcbiAgICAgICAgICAgICAgICAgKiBmcmFtZSBoZWFkZXIgKGZyYW1lIHNpemUgLSAxMCkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogXCJyZWFkRnJhbWVzXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZEZyYW1lcyhvZmZzZXQsIGVuZCwgZGF0YSwgaWQzaGVhZGVyLCB0YWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUhlYWRlclNpemUgPSB0aGlzLl9nZXRGcmFtZUhlYWRlclNpemUoaWQzaGVhZGVyKTsgLy8gY29uc29sZS5sb2coJ2hlYWRlcicsIGlkM2hlYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVhZCBhdCBsZWFzdCB0aGUgZnJhbWUgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IDxcclxuICAgICAgICAgICAgICAgICAgICBlbmQgLSBmcmFtZUhlYWRlclNpemVcclxuICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuX3JlYWRGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQsIGlkM2hlYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZUlkID0gaGVhZGVyLmlkOyAvLyBObyBmcmFtZSBJRCBzb21ldGltZXMgbWVhbnMgaXQncyB0aGUgbGFzdCBmcmFtZSAoR1RGTykuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZnJhbWVJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSBoZWFkZXIuZmxhZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lU2l6ZSA9IGhlYWRlci5zaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZURhdGFPZmZzZXQgPSBvZmZzZXQgKyBoZWFkZXIuaGVhZGVyU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVEYXRhID0gZGF0YTsgLy8gY29uc29sZS5sb2cob2Zmc2V0LCBmcmFtZUlkLCBoZWFkZXIuc2l6ZSArIGhlYWRlci5oZWFkZXJTaXplLCBmbGFncyAmJiBmbGFncy5mb3JtYXQudW5zeW5jaHJvbmlzYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkdmFuY2UgZGF0YSBvZmZzZXQgdG8gdGhlIG5leHQgZnJhbWUgZGF0YVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gaGVhZGVyLmhlYWRlclNpemUgKyBoZWFkZXIuc2l6ZTsgLy8gc2tpcCB1bndhbnRlZCB0YWdzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdzICYmIHRhZ3MuaW5kZXhPZihmcmFtZUlkKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gV29ya2Fyb3VuZDogTVAzZXh0IFYzLjMuMTcgcGxhY2VzIGEgbm9uLWNvbXBsaWFudCBwYWRkaW5nIHN0cmluZyBhdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIElEM3YyIGhlYWRlci4gQSBzdHJpbmcgbGlrZSBcIk1QM2V4dCBWMy4zLjE5KGFuc2kpXCJcclxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBhZGRlZCBtdWx0aXBsZSB0aW1lcyBhdCB0aGUgZW5kIG9mIHRoZSBJRDMgdGFnLiBNb3JlIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWJvdXQgdGhpcyBpc3N1ZSBjYW4gYmUgZm91bmQgYXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYWFkc20vanNtZWRpYXRhZ3MvaXNzdWVzLzU4I2lzc3VlY29tbWVudC0zMTM4NjUzMzZcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgZnJhbWVJZCA9PT0gXCJNUDNlXCIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSWQgPT09IFwiXFx4MDBNUDNcIiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgZnJhbWVJZCA9PT0gXCJcXHgwMFxceDAwTVBcIiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgZnJhbWVJZCA9PT0gXCIgTVAzXCJcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVuc3luY0RhdGE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncy5mb3JtYXQudW5zeW5jaHJvbmlzYXRpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICFpZDNoZWFkZXIuZmxhZ3MudW5zeW5jaHJvbmlzYXRpb25cclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGZyYW1lRGF0YSA9IHRoaXMuZ2V0VW5zeW5jRmlsZVJlYWRlcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZURhdGFPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lU2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGZyYW1lRGF0YU9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICBmcmFtZVNpemUgPSBmcmFtZURhdGEuZ2V0U2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gdGhlIGZpcnN0IDQgYnl0ZXMgYXJlIHRoZSByZWFsIGRhdGEgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIChhZnRlciB1bnN5bmNocm9uaXNhdGlvbiAmJiBlbmNyeXB0aW9uKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MgJiYgZmxhZ3MuZm9ybWF0LmRhdGFfbGVuZ3RoX2luZGljYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGZyYW1lRGF0YVNpemUgPSBmcmFtZURhdGEuZ2V0U3luY2hzYWZlSW50ZWdlcjMyQXQoZnJhbWVEYXRhT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgIGZyYW1lRGF0YU9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgZnJhbWVTaXplIC09IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZEZyYW1lRnVuYyA9XHJcbiAgICAgICAgICAgICAgICAgICAgICBJRDN2MkZyYW1lUmVhZGVyLmdldEZyYW1lUmVhZGVyRnVuY3Rpb24oZnJhbWVJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZERhdGEgPSByZWFkRnJhbWVGdW5jXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IHJlYWRGcmFtZUZ1bmMuYXBwbHkodGhpcywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lRGF0YU9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZVNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkM2hlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB0aGlzLl9nZXRGcmFtZURlc2NyaXB0aW9uKGZyYW1lSWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZDogZnJhbWVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGZyYW1lU2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogcGFyc2VkRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJZCBpbiBmcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZXNbZnJhbWVJZF0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVzW2ZyYW1lSWRdID0gW2ZyYW1lc1tmcmFtZUlkXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgZnJhbWVzW2ZyYW1lSWRdLnB1c2goZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBmcmFtZXNbZnJhbWVJZF0gPSBmcmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiBcIl9nZXRGcmFtZUhlYWRlclNpemVcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RnJhbWVIZWFkZXJTaXplKGlkM2hlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgbWFqb3IgPSBpZDNoZWFkZXIubWFqb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAobWFqb3IgPT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA2O1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ham9yID09IDMgfHwgbWFqb3IgPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxMDtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogXCJfcmVhZEZyYW1lSGVhZGVyXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWRGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQsIGlkM2hlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgbWFqb3IgPSBpZDNoZWFkZXIubWFqb3I7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBmbGFncyA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICB2YXIgZnJhbWVIZWFkZXJTaXplID0gdGhpcy5fZ2V0RnJhbWVIZWFkZXJTaXplKGlkM2hlYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1ham9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lSWQgPSBkYXRhLmdldFN0cmluZ0F0KG9mZnNldCwgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVTaXplID0gZGF0YS5nZXRJbnRlZ2VyMjRBdChvZmZzZXQgKyAzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVJZCA9IGRhdGEuZ2V0U3RyaW5nQXQob2Zmc2V0LCA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVNpemUgPSBkYXRhLmdldExvbmdBdChvZmZzZXQgKyA0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVJZCA9IGRhdGEuZ2V0U3RyaW5nQXQob2Zmc2V0LCA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVNpemUgPSBkYXRhLmdldFN5bmNoc2FmZUludGVnZXIzMkF0KG9mZnNldCArIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZUlkID09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMCwgMCkgfHxcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZUlkID09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMCwgMCwgMClcclxuICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVJZCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgIH0gLy8gaWYgZnJhbWVJZCBpcyBlbXB0eSB0aGVuIGl0J3MgdGhlIGxhc3QgZnJhbWVcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZCBmcmFtZSBtZXNzYWdlIGFuZCBmb3JtYXQgZmxhZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFqb3IgPiAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncyA9IHRoaXMuX3JlYWRGcmFtZUZsYWdzKGRhdGEsIG9mZnNldCArIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogZnJhbWVJZCB8fCBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGZyYW1lU2l6ZSB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlclNpemU6IGZyYW1lSGVhZGVyU2l6ZSB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncyxcclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXk6IFwiX3JlYWRGcmFtZUZsYWdzXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWRGcmFtZUZsYWdzKGRhdGEsIG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgICAgIHRhZ19hbHRlcl9wcmVzZXJ2YXRpb246IGRhdGEuaXNCaXRTZXRBdChvZmZzZXQsIDYpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZmlsZV9hbHRlcl9wcmVzZXJ2YXRpb246IGRhdGEuaXNCaXRTZXRBdChvZmZzZXQsIDUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVhZF9vbmx5OiBkYXRhLmlzQml0U2V0QXQob2Zmc2V0LCA0KSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZ3JvdXBpbmdfaWRlbnRpdHk6IGRhdGEuaXNCaXRTZXRBdChvZmZzZXQgKyAxLCA3KSxcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uOiBkYXRhLmlzQml0U2V0QXQob2Zmc2V0ICsgMSwgMyksXHJcbiAgICAgICAgICAgICAgICAgICAgICBlbmNyeXB0aW9uOiBkYXRhLmlzQml0U2V0QXQob2Zmc2V0ICsgMSwgMiksXHJcbiAgICAgICAgICAgICAgICAgICAgICB1bnN5bmNocm9uaXNhdGlvbjogZGF0YS5pc0JpdFNldEF0KG9mZnNldCArIDEsIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YV9sZW5ndGhfaW5kaWNhdG9yOiBkYXRhLmlzQml0U2V0QXQob2Zmc2V0ICsgMSwgMCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2dldEZyYW1lRGVzY3JpcHRpb25cIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RnJhbWVEZXNjcmlwdGlvbihmcmFtZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUlkIGluIEZSQU1FX0RFU0NSSVBUSU9OUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGUkFNRV9ERVNDUklQVElPTlNbZnJhbWVJZF07XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVW5rbm93blwiO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiBcImdldFVuc3luY0ZpbGVSZWFkZXJcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVbnN5bmNGaWxlUmVhZGVyKGRhdGEsIG9mZnNldCwgc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgZnJhbWVEYXRhID0gZGF0YS5nZXRCeXRlc0F0KG9mZnNldCwgc2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lRGF0YS5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVEYXRhW2ldID09PSAweGZmICYmIGZyYW1lRGF0YVtpICsgMV0gPT09IDB4MDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGZyYW1lRGF0YS5zcGxpY2UoaSArIDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUZpbGVSZWFkZXIoZnJhbWVEYXRhKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gSUQzdjJGcmFtZVJlYWRlcjtcclxuICAgICAgICAgIH0pKCk7XHJcblxyXG4gICAgICAgICAgdmFyIGZyYW1lUmVhZGVyRnVuY3Rpb25zID0ge307XHJcblxyXG4gICAgICAgICAgZnJhbWVSZWFkZXJGdW5jdGlvbnNbXCJBUElDXCJdID0gZnVuY3Rpb24gcmVhZFBpY3R1cmVGcmFtZShcclxuICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICBsZW5ndGgsXHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIGZsYWdzLFxyXG4gICAgICAgICAgICBpZDNoZWFkZXJcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHZhciBjaGFyc2V0ID0gZ2V0VGV4dEVuY29kaW5nKGRhdGEuZ2V0Qnl0ZUF0KG9mZnNldCkpO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChpZDNoZWFkZXIgJiYgaWQzaGVhZGVyLm1ham9yKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGRhdGEuZ2V0U3RyaW5nQXQob2Zmc2V0ICsgMSwgMyk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGRhdGEuZ2V0U3RyaW5nV2l0aENoYXJzZXRBdChcclxuICAgICAgICAgICAgICAgICAgb2Zmc2V0ICsgMSxcclxuICAgICAgICAgICAgICAgICAgbGVuZ3RoIC0gMVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSAxICsgZm9ybWF0LmJ5dGVzUmVhZENvdW50O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCByZWFkIElEM3YyIG1ham9yIHZlcnNpb24uXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYml0ZSA9IGRhdGEuZ2V0Qnl0ZUF0KG9mZnNldCk7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gUElDVFVSRV9UWVBFW2JpdGVdO1xyXG4gICAgICAgICAgICB2YXIgZGVzYyA9IGRhdGEuZ2V0U3RyaW5nV2l0aENoYXJzZXRBdChcclxuICAgICAgICAgICAgICBvZmZzZXQgKyAxLFxyXG4gICAgICAgICAgICAgIGxlbmd0aCAtIChvZmZzZXQgLSBzdGFydCkgLSAxLFxyXG4gICAgICAgICAgICAgIGNoYXJzZXRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IDEgKyBkZXNjLmJ5dGVzUmVhZENvdW50O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0LnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzYy50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGEuZ2V0Qnl0ZXNBdChvZmZzZXQsIHN0YXJ0ICsgbGVuZ3RoIC0gb2Zmc2V0KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH07IC8vIElEM3YyIGNoYXB0ZXJzIGFjY29yZGluZyB0byBodHRwOi8vaWQzLm9yZy9pZDN2Mi1jaGFwdGVycy0xLjBcclxuXHJcbiAgICAgICAgICBmcmFtZVJlYWRlckZ1bmN0aW9uc1tcIkNIQVBcIl0gPSBmdW5jdGlvbiByZWFkQ2hhcHRlckZyYW1lKFxyXG4gICAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgICAgIGxlbmd0aCxcclxuICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgZmxhZ3MsXHJcbiAgICAgICAgICAgIGlkM2hlYWRlclxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbE9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgaWQgPSBTdHJpbmdVdGlscy5yZWFkTnVsbFRlcm1pbmF0ZWRTdHJpbmcoXHJcbiAgICAgICAgICAgICAgZGF0YS5nZXRCeXRlc0F0KG9mZnNldCwgbGVuZ3RoKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXN1bHQuaWQgPSBpZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gaWQuYnl0ZXNSZWFkQ291bnQ7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydFRpbWUgPSBkYXRhLmdldExvbmdBdChvZmZzZXQsIHRydWUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgcmVzdWx0LmVuZFRpbWUgPSBkYXRhLmdldExvbmdBdChvZmZzZXQsIHRydWUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0T2Zmc2V0ID0gZGF0YS5nZXRMb25nQXQob2Zmc2V0LCB0cnVlKTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgIHJlc3VsdC5lbmRPZmZzZXQgPSBkYXRhLmdldExvbmdBdChvZmZzZXQsIHRydWUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgdmFyIHJlbWFpbmluZ0xlbmd0aCA9IGxlbmd0aCAtIChvZmZzZXQgLSBvcmlnaW5hbE9mZnNldCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zdWJGcmFtZXMgPSB0aGlzLnJlYWRGcmFtZXMoXHJcbiAgICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICAgIG9mZnNldCArIHJlbWFpbmluZ0xlbmd0aCxcclxuICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgIGlkM2hlYWRlclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgfTsgLy8gSUQzdjIgdGFibGUgb2YgY29udGVudHMgYWNjb3JkaW5nIHRvIGh0dHA6Ly9pZDMub3JnL2lkM3YyLWNoYXB0ZXJzLTEuMFxyXG5cclxuICAgICAgICAgIGZyYW1lUmVhZGVyRnVuY3Rpb25zW1wiQ1RPQ1wiXSA9IGZ1bmN0aW9uIHJlYWRUYWJsZU9mQ29udGVudHNGcmFtZShcclxuICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICBsZW5ndGgsXHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIGZsYWdzLFxyXG4gICAgICAgICAgICBpZDNoZWFkZXJcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgY2hpbGRFbGVtZW50SWRzOiBbXSxcclxuICAgICAgICAgICAgICBpZDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIHRvcExldmVsOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgb3JkZXJlZDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIGVudHJ5Q291bnQ6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICBzdWJGcmFtZXM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGlkID0gU3RyaW5nVXRpbHMucmVhZE51bGxUZXJtaW5hdGVkU3RyaW5nKFxyXG4gICAgICAgICAgICAgIGRhdGEuZ2V0Qnl0ZXNBdChvZmZzZXQsIGxlbmd0aClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmVzdWx0LmlkID0gaWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IGlkLmJ5dGVzUmVhZENvdW50O1xyXG4gICAgICAgICAgICByZXN1bHQudG9wTGV2ZWwgPSBkYXRhLmlzQml0U2V0QXQob2Zmc2V0LCAxKTtcclxuICAgICAgICAgICAgcmVzdWx0Lm9yZGVyZWQgPSBkYXRhLmlzQml0U2V0QXQob2Zmc2V0LCAwKTtcclxuICAgICAgICAgICAgb2Zmc2V0Kys7XHJcbiAgICAgICAgICAgIHJlc3VsdC5lbnRyeUNvdW50ID0gZGF0YS5nZXRCeXRlQXQob2Zmc2V0KTtcclxuICAgICAgICAgICAgb2Zmc2V0Kys7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5lbnRyeUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICB2YXIgY2hpbGRJZCA9IFN0cmluZ1V0aWxzLnJlYWROdWxsVGVybWluYXRlZFN0cmluZyhcclxuICAgICAgICAgICAgICAgIGRhdGEuZ2V0Qnl0ZXNBdChvZmZzZXQsIGxlbmd0aCAtIChvZmZzZXQgLSBvcmlnaW5hbE9mZnNldCkpXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICByZXN1bHQuY2hpbGRFbGVtZW50SWRzLnB1c2goY2hpbGRJZC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICBvZmZzZXQgKz0gY2hpbGRJZC5ieXRlc1JlYWRDb3VudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlbWFpbmluZ0xlbmd0aCA9IGxlbmd0aCAtIChvZmZzZXQgLSBvcmlnaW5hbE9mZnNldCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zdWJGcmFtZXMgPSB0aGlzLnJlYWRGcmFtZXMoXHJcbiAgICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICAgIG9mZnNldCArIHJlbWFpbmluZ0xlbmd0aCxcclxuICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgIGlkM2hlYWRlclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBmcmFtZVJlYWRlckZ1bmN0aW9uc1tcIkNPTU1cIl0gPSBmdW5jdGlvbiByZWFkQ29tbWVudHNGcmFtZShcclxuICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICBsZW5ndGgsXHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIGZsYWdzLFxyXG4gICAgICAgICAgICBpZDNoZWFkZXJcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHZhciBjaGFyc2V0ID0gZ2V0VGV4dEVuY29kaW5nKGRhdGEuZ2V0Qnl0ZUF0KG9mZnNldCkpO1xyXG4gICAgICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBkYXRhLmdldFN0cmluZ0F0KG9mZnNldCArIDEsIDMpO1xyXG4gICAgICAgICAgICB2YXIgc2hvcnRkZXNjID0gZGF0YS5nZXRTdHJpbmdXaXRoQ2hhcnNldEF0KFxyXG4gICAgICAgICAgICAgIG9mZnNldCArIDQsXHJcbiAgICAgICAgICAgICAgbGVuZ3RoIC0gNCxcclxuICAgICAgICAgICAgICBjaGFyc2V0XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSA0ICsgc2hvcnRkZXNjLmJ5dGVzUmVhZENvdW50O1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IGRhdGEuZ2V0U3RyaW5nV2l0aENoYXJzZXRBdChcclxuICAgICAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgc3RhcnQgKyBsZW5ndGggLSBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgY2hhcnNldFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcclxuICAgICAgICAgICAgICBzaG9ydF9kZXNjcmlwdGlvbjogc2hvcnRkZXNjLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgdGV4dDogdGV4dC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBmcmFtZVJlYWRlckZ1bmN0aW9uc1tcIkNPTVwiXSA9IGZyYW1lUmVhZGVyRnVuY3Rpb25zW1wiQ09NTVwiXTtcclxuXHJcbiAgICAgICAgICBmcmFtZVJlYWRlckZ1bmN0aW9uc1tcIlBJQ1wiXSA9IGZ1bmN0aW9uIChcclxuICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICBsZW5ndGgsXHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIGZsYWdzLFxyXG4gICAgICAgICAgICBpZDNoZWFkZXJcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnJhbWVSZWFkZXJGdW5jdGlvbnNbXCJBUElDXCJdKFxyXG4gICAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgICBsZW5ndGgsXHJcbiAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICBmbGFncyxcclxuICAgICAgICAgICAgICBpZDNoZWFkZXJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgZnJhbWVSZWFkZXJGdW5jdGlvbnNbXCJQQ05UXCJdID0gZnVuY3Rpb24gcmVhZENvdW50ZXJGcmFtZShcclxuICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICBsZW5ndGgsXHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIGZsYWdzLFxyXG4gICAgICAgICAgICBpZDNoZWFkZXJcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAvLyBGSVhNRTogaW1wbGVtZW50IHRoZSByZXN0IG9mIHRoZSBzcGVjXHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmdldExvbmdBdChvZmZzZXQsIGZhbHNlKTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgZnJhbWVSZWFkZXJGdW5jdGlvbnNbXCJDTlRcIl0gPSBmcmFtZVJlYWRlckZ1bmN0aW9uc1tcIlBDTlRcIl07XHJcblxyXG4gICAgICAgICAgZnJhbWVSZWFkZXJGdW5jdGlvbnNbXCJUKlwiXSA9IGZ1bmN0aW9uIHJlYWRUZXh0RnJhbWUoXHJcbiAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBmbGFncyxcclxuICAgICAgICAgICAgaWQzaGVhZGVyXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdmFyIGNoYXJzZXQgPSBnZXRUZXh0RW5jb2RpbmcoZGF0YS5nZXRCeXRlQXQob2Zmc2V0KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhXHJcbiAgICAgICAgICAgICAgLmdldFN0cmluZ1dpdGhDaGFyc2V0QXQob2Zmc2V0ICsgMSwgbGVuZ3RoIC0gMSwgY2hhcnNldClcclxuICAgICAgICAgICAgICAudG9TdHJpbmcoKTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgZnJhbWVSZWFkZXJGdW5jdGlvbnNbXCJUWFhYXCJdID0gZnVuY3Rpb24gcmVhZFRleHRGcmFtZShcclxuICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICBsZW5ndGgsXHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIGZsYWdzLFxyXG4gICAgICAgICAgICBpZDNoZWFkZXJcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB2YXIgY2hhcnNldCA9IGdldFRleHRFbmNvZGluZyhkYXRhLmdldEJ5dGVBdChvZmZzZXQpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFVzZXJEZWZpbmVkRmllbGRzKG9mZnNldCwgbGVuZ3RoLCBkYXRhLCBjaGFyc2V0KTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgZnJhbWVSZWFkZXJGdW5jdGlvbnNbXCJXWFhYXCJdID0gZnVuY3Rpb24gcmVhZFVybEZyYW1lKFxyXG4gICAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgICAgIGxlbmd0aCxcclxuICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgZmxhZ3MsXHJcbiAgICAgICAgICAgIGlkM2hlYWRlclxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNoYXJzZXQgPSBnZXRUZXh0RW5jb2RpbmcoZGF0YS5nZXRCeXRlQXQob2Zmc2V0KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRVc2VyRGVmaW5lZEZpZWxkcyhvZmZzZXQsIGxlbmd0aCwgZGF0YSwgY2hhcnNldCk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGZyYW1lUmVhZGVyRnVuY3Rpb25zW1wiVypcIl0gPSBmdW5jdGlvbiByZWFkVXJsRnJhbWUoXHJcbiAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBmbGFncyxcclxuICAgICAgICAgICAgaWQzaGVhZGVyXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YVxyXG4gICAgICAgICAgICAgIC5nZXRTdHJpbmdXaXRoQ2hhcnNldEF0KG9mZnNldCwgbGVuZ3RoLCBcImlzby04ODU5LTFcIilcclxuICAgICAgICAgICAgICAudG9TdHJpbmcoKTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgZnJhbWVSZWFkZXJGdW5jdGlvbnNbXCJUQ09OXCJdID0gZnVuY3Rpb24gcmVhZEdlbnJlRnJhbWUoXHJcbiAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBmbGFnc1xyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZnJhbWVSZWFkZXJGdW5jdGlvbnNbXCJUKlwiXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9eXFwoXFxkK1xcKS8sIFwiXCIpO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBmcmFtZVJlYWRlckZ1bmN0aW9uc1tcIlRDT1wiXSA9IGZyYW1lUmVhZGVyRnVuY3Rpb25zW1wiVENPTlwiXTtcclxuXHJcbiAgICAgICAgICBmcmFtZVJlYWRlckZ1bmN0aW9uc1tcIlVTTFRcIl0gPSBmdW5jdGlvbiByZWFkTHlyaWNzRnJhbWUoXHJcbiAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBmbGFncyxcclxuICAgICAgICAgICAgaWQzaGVhZGVyXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICB2YXIgY2hhcnNldCA9IGdldFRleHRFbmNvZGluZyhkYXRhLmdldEJ5dGVBdChvZmZzZXQpKTtcclxuICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gZGF0YS5nZXRTdHJpbmdBdChvZmZzZXQgKyAxLCAzKTtcclxuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBkYXRhLmdldFN0cmluZ1dpdGhDaGFyc2V0QXQoXHJcbiAgICAgICAgICAgICAgb2Zmc2V0ICsgNCxcclxuICAgICAgICAgICAgICBsZW5ndGggLSA0LFxyXG4gICAgICAgICAgICAgIGNoYXJzZXRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IDQgKyBkZXNjcmlwdG9yLmJ5dGVzUmVhZENvdW50O1xyXG4gICAgICAgICAgICB2YXIgbHlyaWNzID0gZGF0YS5nZXRTdHJpbmdXaXRoQ2hhcnNldEF0KFxyXG4gICAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgICBzdGFydCArIGxlbmd0aCAtIG9mZnNldCxcclxuICAgICAgICAgICAgICBjaGFyc2V0XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLFxyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICBseXJpY3M6IGx5cmljcy50b1N0cmluZygpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBmcmFtZVJlYWRlckZ1bmN0aW9uc1tcIlVMVFwiXSA9IGZyYW1lUmVhZGVyRnVuY3Rpb25zW1wiVVNMVFwiXTtcclxuXHJcbiAgICAgICAgICBmcmFtZVJlYWRlckZ1bmN0aW9uc1tcIlVGSURcIl0gPSBmdW5jdGlvbiByZWFkTHlyaWNzRnJhbWUoXHJcbiAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBmbGFncyxcclxuICAgICAgICAgICAgaWQzaGVhZGVyXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdmFyIG93bmVySWRlbnRpZmllciA9IFN0cmluZ1V0aWxzLnJlYWROdWxsVGVybWluYXRlZFN0cmluZyhcclxuICAgICAgICAgICAgICBkYXRhLmdldEJ5dGVzQXQob2Zmc2V0LCBsZW5ndGgpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBvd25lcklkZW50aWZpZXIuYnl0ZXNSZWFkQ291bnQ7XHJcbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gZGF0YS5nZXRCeXRlc0F0KFxyXG4gICAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgICBsZW5ndGggLSBvd25lcklkZW50aWZpZXIuYnl0ZXNSZWFkQ291bnRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBvd25lcklkZW50aWZpZXI6IG93bmVySWRlbnRpZmllci50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIGdldFRleHRFbmNvZGluZyhiaXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFyc2V0O1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChiaXRlKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSAweDAwOlxyXG4gICAgICAgICAgICAgICAgY2hhcnNldCA9IFwiaXNvLTg4NTktMVwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgIGNhc2UgMHgwMTpcclxuICAgICAgICAgICAgICAgIGNoYXJzZXQgPSBcInV0Zi0xNlwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgIGNhc2UgMHgwMjpcclxuICAgICAgICAgICAgICAgIGNoYXJzZXQgPSBcInV0Zi0xNmJlXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgY2FzZSAweDAzOlxyXG4gICAgICAgICAgICAgICAgY2hhcnNldCA9IFwidXRmLThcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY2hhcnNldCA9IFwiaXNvLTg4NTktMVwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2hhcnNldDtcclxuICAgICAgICAgIH0gLy8gSGFuZGxlcyByZWFkaW5nIGRlc2NyaXB0aW9uL2RhdGEgZnJvbSBlaXRoZXIgaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wI1VzZXJfZGVmaW5lZF90ZXh0X2luZm9ybWF0aW9uX2ZyYW1lXHJcbiAgICAgICAgICAvLyBhbmQgaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wI1VzZXJfZGVmaW5lZF9VUkxfbGlua19mcmFtZVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIGdldFVzZXJEZWZpbmVkRmllbGRzKG9mZnNldCwgbGVuZ3RoLCBkYXRhLCBjaGFyc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciB1c2VyRGVzYyA9IGRhdGEuZ2V0U3RyaW5nV2l0aENoYXJzZXRBdChcclxuICAgICAgICAgICAgICBvZmZzZXQgKyAxLFxyXG4gICAgICAgICAgICAgIGxlbmd0aCAtIDEsXHJcbiAgICAgICAgICAgICAgY2hhcnNldFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB2YXIgdXNlckRlZmluZWREYXRhID0gZGF0YS5nZXRTdHJpbmdXaXRoQ2hhcnNldEF0KFxyXG4gICAgICAgICAgICAgIG9mZnNldCArIDEgKyB1c2VyRGVzYy5ieXRlc1JlYWRDb3VudCxcclxuICAgICAgICAgICAgICBsZW5ndGggLSAxIC0gdXNlckRlc2MuYnl0ZXNSZWFkQ291bnQsXHJcbiAgICAgICAgICAgICAgY2hhcnNldFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIHVzZXJfZGVzY3JpcHRpb246IHVzZXJEZXNjLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgZGF0YTogdXNlckRlZmluZWREYXRhLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIFBJQ1RVUkVfVFlQRSA9IFtcclxuICAgICAgICAgICAgXCJPdGhlclwiLFxyXG4gICAgICAgICAgICBcIjMyeDMyIHBpeGVscyAnZmlsZSBpY29uJyAoUE5HIG9ubHkpXCIsXHJcbiAgICAgICAgICAgIFwiT3RoZXIgZmlsZSBpY29uXCIsXHJcbiAgICAgICAgICAgIFwiQ292ZXIgKGZyb250KVwiLFxyXG4gICAgICAgICAgICBcIkNvdmVyIChiYWNrKVwiLFxyXG4gICAgICAgICAgICBcIkxlYWZsZXQgcGFnZVwiLFxyXG4gICAgICAgICAgICBcIk1lZGlhIChlLmcuIGxhYmVsIHNpZGUgb2YgQ0QpXCIsXHJcbiAgICAgICAgICAgIFwiTGVhZCBhcnRpc3QvbGVhZCBwZXJmb3JtZXIvc29sb2lzdFwiLFxyXG4gICAgICAgICAgICBcIkFydGlzdC9wZXJmb3JtZXJcIixcclxuICAgICAgICAgICAgXCJDb25kdWN0b3JcIixcclxuICAgICAgICAgICAgXCJCYW5kL09yY2hlc3RyYVwiLFxyXG4gICAgICAgICAgICBcIkNvbXBvc2VyXCIsXHJcbiAgICAgICAgICAgIFwiTHlyaWNpc3QvdGV4dCB3cml0ZXJcIixcclxuICAgICAgICAgICAgXCJSZWNvcmRpbmcgTG9jYXRpb25cIixcclxuICAgICAgICAgICAgXCJEdXJpbmcgcmVjb3JkaW5nXCIsXHJcbiAgICAgICAgICAgIFwiRHVyaW5nIHBlcmZvcm1hbmNlXCIsXHJcbiAgICAgICAgICAgIFwiTW92aWUvdmlkZW8gc2NyZWVuIGNhcHR1cmVcIixcclxuICAgICAgICAgICAgXCJBIGJyaWdodCBjb2xvdXJlZCBmaXNoXCIsXHJcbiAgICAgICAgICAgIFwiSWxsdXN0cmF0aW9uXCIsXHJcbiAgICAgICAgICAgIFwiQmFuZC9hcnRpc3QgbG9nb3R5cGVcIixcclxuICAgICAgICAgICAgXCJQdWJsaXNoZXIvU3R1ZGlvIGxvZ290eXBlXCIsXHJcbiAgICAgICAgICBdO1xyXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBJRDN2MkZyYW1lUmVhZGVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgXCIuL0FycmF5RmlsZVJlYWRlclwiOiAzLFxyXG4gICAgICAgICAgXCIuL01lZGlhRmlsZVJlYWRlclwiOiAxMSxcclxuICAgICAgICAgIFwiLi9TdHJpbmdVdGlsc1wiOiAxMyxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICA5OiBbXHJcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xyXG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgICAgICAgICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIlxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmXHJcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG4gICAgICAgICAgICAgICAgICBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJlxyXG4gICAgICAgICAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcclxuICAgICAgICAgICAgICAgICAgPyBcInN5bWJvbFwiXHJcbiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIG9iajtcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdHlwZW9mKG9iaik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm90b1Byb3BzKVxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcclxuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgICAgIFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcclxuICAgICAgICAgICAgICBzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xyXG4gICAgICAgICAgICBfc2V0UHJvdG90eXBlT2YgPVxyXG4gICAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XHJcbiAgICAgICAgICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbztcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XHJcbiAgICAgICAgICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0O1xyXG4gICAgICAgICAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgY2FsbCAmJlxyXG4gICAgICAgICAgICAgIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjYWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xyXG4gICAgICAgICAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIlxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdClcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFxyXG4gICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xyXG4gICAgICAgICAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcclxuICAgICAgICAgICAgICA/IE9iamVjdC5nZXRQcm90b3R5cGVPZlxyXG4gICAgICAgICAgICAgIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIE1lZGlhVGFnUmVhZGVyID0gcmVxdWlyZShcIi4vTWVkaWFUYWdSZWFkZXJcIik7XHJcblxyXG4gICAgICAgICAgdmFyIE1lZGlhRmlsZVJlYWRlciA9IHJlcXVpcmUoXCIuL01lZGlhRmlsZVJlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgSUQzdjJGcmFtZVJlYWRlciA9IHJlcXVpcmUoXCIuL0lEM3YyRnJhbWVSZWFkZXJcIik7XHJcblxyXG4gICAgICAgICAgdmFyIElEM19IRUFERVJfU0laRSA9IDEwO1xyXG5cclxuICAgICAgICAgIHZhciBJRDN2MlRhZ1JlYWRlciA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uIChfTWVkaWFUYWdSZWFkZXIpIHtcclxuICAgICAgICAgICAgX2luaGVyaXRzKElEM3YyVGFnUmVhZGVyLCBfTWVkaWFUYWdSZWFkZXIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihJRDN2MlRhZ1JlYWRlcik7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBJRDN2MlRhZ1JlYWRlcigpIHtcclxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSUQzdjJUYWdSZWFkZXIpO1xyXG5cclxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhcclxuICAgICAgICAgICAgICBJRDN2MlRhZ1JlYWRlcixcclxuICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfbG9hZERhdGFcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkRGF0YShtZWRpYUZpbGVSZWFkZXIsIGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhRmlsZVJlYWRlci5sb2FkUmFuZ2UoWzYsIDldLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFGaWxlUmVhZGVyLmxvYWRSYW5nZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdGFnIHNpemUgZG9lcyBub3QgaW5jbHVkZSB0aGUgaGVhZGVyIHNpemUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIElEM19IRUFERVJfU0laRSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRmlsZVJlYWRlci5nZXRTeW5jaHNhZmVJbnRlZ2VyMzJBdCg2KSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBjYWxsYmFja3Mub25FcnJvcixcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfcGFyc2VEYXRhXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VEYXRhKGRhdGEsIHRhZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFqb3IgPSBkYXRhLmdldEJ5dGVBdChvZmZzZXQgKyAzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ham9yID4gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJJRDNcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCI+Mi40XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXZpc2lvbiA9IGRhdGEuZ2V0Qnl0ZUF0KG9mZnNldCArIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bnN5bmNoID0gZGF0YS5pc0JpdFNldEF0KG9mZnNldCArIDUsIDcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4aGVhZGVyID0gZGF0YS5pc0JpdFNldEF0KG9mZnNldCArIDUsIDYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4aW5kaWNhdG9yID0gZGF0YS5pc0JpdFNldEF0KG9mZnNldCArIDUsIDUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gZGF0YS5nZXRTeW5jaHNhZmVJbnRlZ2VyMzJBdChvZmZzZXQgKyA2KTtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMTA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4aGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBza2lwIHRoZSBleHRlbmRlZCBoZWFkZXIgYW5kIGRvbid0IG9mZmVyIHN1cHBvcnQgZm9yIGl0IHJpZ2h0IG5vdy5cclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWpvciA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGhlYWRlcnNpemUgPSBkYXRhLmdldFN5bmNoc2FmZUludGVnZXIzMkF0KG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSB4aGVhZGVyc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4aGVhZGVyc2l6ZSA9IGRhdGEuZ2V0TG9uZ0F0KG9mZnNldCwgdHJ1ZSk7IC8vIFRoZSAnRXh0ZW5kZWQgaGVhZGVyIHNpemUnLCBjdXJyZW50bHkgNiBvciAxMCBieXRlcywgZXhjbHVkZXMgaXRzZWxmLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHhoZWFkZXJzaXplICsgNDtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZDMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIklEM1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCIyLlwiICsgbWFqb3IgKyBcIi5cIiArIHJldmlzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgbWFqb3I6IG1ham9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV2aXNpb246IHJldmlzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zeW5jaHJvbmlzYXRpb246IHVuc3luY2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkX2hlYWRlcjogeGhlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2luZGljYXRvcjogeGluZGljYXRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZm9vdGVyX3ByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyX3ByZXNlbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgICB0YWdzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkVGFncyA9IHRoaXMuX2V4cGFuZFNob3J0Y3V0VGFncyh0YWdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRFbmQgPSBzaXplICsgMTA7IC8vIFdoZW4gdGhpcyBmbGFnIGlzIHNldCB0aGUgZW50aXJlIHRhZyBuZWVkcyB0byBiZSB1bi11bnN5bmNocm9uaXNlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8qaGVhZGVyIHNpemUqL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBwYXJzaW5nIGVhY2ggaW5kaXZpZHVhbCBmcmFtZS4gSW5kaXZpZHVhbCBmcmFtZSBzaXplcyBtaWdodCBub3RcclxuICAgICAgICAgICAgICAgICAgICAvLyB0YWtlIHVuc3luY2hyb25pc2F0aW9uIGludG8gY29uc2lkZXJhdGlvbiB3aGVuIGl0J3Mgc2V0IG9uIHRoZSB0YWdcclxuICAgICAgICAgICAgICAgICAgICAvLyBoZWFkZXIuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZDMuZmxhZ3MudW5zeW5jaHJvbmlzYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBJRDN2MkZyYW1lUmVhZGVyLmdldFVuc3luY0ZpbGVSZWFkZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRFbmQgPSBkYXRhLmdldFNpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZXMgPSBJRDN2MkZyYW1lUmVhZGVyLnJlYWRGcmFtZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRFbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgaWQzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWRUYWdzXHJcbiAgICAgICAgICAgICAgICAgICAgKTsgLy8gY3JlYXRlIHNob3J0Y3V0cyBmb3IgbW9zdCBjb21tb24gZGF0YS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBTSE9SVENVVFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChTSE9SVENVVFMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lRGF0YSA9IHRoaXMuX2dldEZyYW1lRGF0YShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgU0hPUlRDVVRTW25hbWVdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWQzLnRhZ3NbbmFtZV0gPSBmcmFtZURhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZyYW1lIGluIGZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lcy5oYXNPd25Qcm9wZXJ0eShmcmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQzLnRhZ3NbZnJhbWVdID0gZnJhbWVzW2ZyYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDM7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiX2dldEZyYW1lRGF0YVwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZyYW1lRGF0YShmcmFtZXMsIGlkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlkOyAoaWQgPSBpZHNbaV0pOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCBpbiBmcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lc1tpZF0gaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lID0gZnJhbWVzW2lkXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGZyYW1lc1tpZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRTaG9ydGN1dHNcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNob3J0Y3V0cygpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU0hPUlRDVVRTO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImdldFRhZ0lkZW50aWZpZXJCeXRlUmFuZ2VcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRhZ0lkZW50aWZpZXJCeXRlUmFuZ2UoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSUQzIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IElEM19IRUFERVJfU0laRSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImNhblJlYWRUYWdGb3JtYXRcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhblJlYWRUYWdGb3JtYXQodGFnSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXHJcbiAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICB0YWdJZGVudGlmaWVyLnNsaWNlKDAsIDMpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQgPT09IFwiSUQzXCI7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBJRDN2MlRhZ1JlYWRlcjtcclxuICAgICAgICAgIH0pKE1lZGlhVGFnUmVhZGVyKTtcclxuXHJcbiAgICAgICAgICB2YXIgU0hPUlRDVVRTID0ge1xyXG4gICAgICAgICAgICB0aXRsZTogW1wiVElUMlwiLCBcIlRUMlwiXSxcclxuICAgICAgICAgICAgYXJ0aXN0OiBbXCJUUEUxXCIsIFwiVFAxXCJdLFxyXG4gICAgICAgICAgICBhbGJ1bTogW1wiVEFMQlwiLCBcIlRBTFwiXSxcclxuICAgICAgICAgICAgeWVhcjogW1wiVFlFUlwiLCBcIlRZRVwiXSxcclxuICAgICAgICAgICAgY29tbWVudDogW1wiQ09NTVwiLCBcIkNPTVwiXSxcclxuICAgICAgICAgICAgdHJhY2s6IFtcIlRSQ0tcIiwgXCJUUktcIl0sXHJcbiAgICAgICAgICAgIGdlbnJlOiBbXCJUQ09OXCIsIFwiVENPXCJdLFxyXG4gICAgICAgICAgICBwaWN0dXJlOiBbXCJBUElDXCIsIFwiUElDXCJdLFxyXG4gICAgICAgICAgICBseXJpY3M6IFtcIlVTTFRcIiwgXCJVTFRcIl0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBJRDN2MlRhZ1JlYWRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIFwiLi9JRDN2MkZyYW1lUmVhZGVyXCI6IDgsXHJcbiAgICAgICAgICBcIi4vTWVkaWFGaWxlUmVhZGVyXCI6IDExLFxyXG4gICAgICAgICAgXCIuL01lZGlhVGFnUmVhZGVyXCI6IDEyLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIDEwOiBbXHJcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBTdXBwb3J0IGZvciBpVHVuZXMtc3R5bGUgbTRhIHRhZ3NcclxuICAgICAgICAgICAqIFNlZTpcclxuICAgICAgICAgICAqICAgaHR0cDovL2F0b21pY3BhcnNsZXkuc291cmNlZm9yZ2UubmV0L21wZWctNGZpbGVzLmh0bWxcclxuICAgICAgICAgICAqICAgaHR0cDovL2RldmVsb3Blci5hcHBsZS5jb20vbWFjL2xpYnJhcnkvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9NZXRhZGF0YS9NZXRhZGF0YS5odG1sXHJcbiAgICAgICAgICAgKiBBdXRob3JlZCBieSBKb3NodWEgS2lmZXIgPGpvc2h1YS5raWZlciBnbWFpbC5jb20+XHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xyXG4gICAgICAgICAgICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiZcclxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiZcclxuICAgICAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgICAgICAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmXHJcbiAgICAgICAgICAgICAgICAgIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICA/IFwic3ltYm9sXCJcclxuICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygb2JqO1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3RvUHJvcHMpXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcclxuICAgICAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFxyXG4gICAgICAgICAgICAgIHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxyXG4gICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XHJcbiAgICAgICAgICAgIF9zZXRQcm90b3R5cGVPZiA9XHJcbiAgICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcclxuICAgICAgICAgICAgICAgIG8uX19wcm90b19fID0gcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvO1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcclxuICAgICAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcclxuICAgICAgICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICBjYWxsICYmXHJcbiAgICAgICAgICAgICAgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KVxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoXHJcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XHJcbiAgICAgICAgICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZlxyXG4gICAgICAgICAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXHJcbiAgICAgICAgICAgICAgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgTWVkaWFUYWdSZWFkZXIgPSByZXF1aXJlKFwiLi9NZWRpYVRhZ1JlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgTWVkaWFGaWxlUmVhZGVyID0gcmVxdWlyZShcIi4vTWVkaWFGaWxlUmVhZGVyXCIpO1xyXG5cclxuICAgICAgICAgIHZhciBNUDRUYWdSZWFkZXIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX01lZGlhVGFnUmVhZGVyKSB7XHJcbiAgICAgICAgICAgIF9pbmhlcml0cyhNUDRUYWdSZWFkZXIsIF9NZWRpYVRhZ1JlYWRlcik7XHJcblxyXG4gICAgICAgICAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE1QNFRhZ1JlYWRlcik7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBNUDRUYWdSZWFkZXIoKSB7XHJcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1QNFRhZ1JlYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFxyXG4gICAgICAgICAgICAgIE1QNFRhZ1JlYWRlcixcclxuICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfbG9hZERhdGFcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkRGF0YShtZWRpYUZpbGVSZWFkZXIsIGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1QNCBtZXRhZGF0YSBpc24ndCBsb2NhdGVkIGluIGEgc3BlY2lmaWMgbG9jYXRpb24gb2YgdGhlIGZpbGUuIFJvdWdobHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBzcGVha2luZywgaXQncyBjb21wb3NlZCBvZiBibG9ja3MgY2hhaW5lZCB0b2dldGhlciBsaWtlIGEgbGlua2VkIGxpc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgYmxvY2tzIGFyZSBjYWxsZWQgYXRvbXMgKG9yIGJveGVzKS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIGF0b20gb2YgdGhlIGxpc3QgY2FuIGhhdmUgaXRzIG93biBjaGlsZCBsaW5rZWQgbGlzdC4gQXRvbXMgaW4gdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpdHVhdGlvbiBkbyBub3QgcG9zc2VzcyBhbnkgZGF0YSBhbmQgYXJlIGNhbGxlZCBcImNvbnRhaW5lclwiIGFzIHRoZXkgb25seVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRhaW4gb3RoZXIgYXRvbXMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgYXRvbXMgcmVwcmVzZW50IGEgcGFydGljdWxhciBzZXQgb2YgZGF0YSwgbGlrZSBhdWRpbywgdmlkZW8gb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBtZXRhZGF0YS4gSW4gb3JkZXIgdG8gZmluZCBhbmQgbG9hZCBhbGwgdGhlIGludGVyZXN0aW5nIGF0b21zIHdlIG5lZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0byB0cmF2ZXJzZSB0aGUgZW50aXJlIGxpbmtlZCBsaXN0IG9mIGF0b21zIGFuZCBvbmx5IGxvYWQgdGhlIG9uZXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggbWV0YWRhdGEuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1ldGFkYXRhIGF0b21zIGNhbiBiZSBmaW5kIHVuZGVyIHRoZSBcIm1vb3YudWR0YS5tZXRhLmlsc3RcIiBoaWVyYXJjaHkuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBMb2FkIHRoZSBoZWFkZXIgb2YgdGhlIGZpcnN0IGF0b21cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFGaWxlUmVhZGVyLmxvYWRSYW5nZShbMCwgMTZdLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbG9hZEF0b20obWVkaWFGaWxlUmVhZGVyLCAwLCBcIlwiLCBjYWxsYmFja3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGNhbGxiYWNrcy5vbkVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9sb2FkQXRvbVwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRBdG9tKFxyXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhRmlsZVJlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50QXRvbUZ1bGxOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID49IG1lZGlhRmlsZVJlYWRlci5nZXRTaXplKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpczsgLy8gOCBpcyB0aGUgc2l6ZSBvZiB0aGUgYXRvbVNpemUgYW5kIGF0b21OYW1lIGZpZWxkcy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJlYWRpbmcgdGhlIGN1cnJlbnQgYmxvY2sgd2UgYWx3YXlzIHJlYWQgOCBtb3JlIGJ5dGVzIGluIG9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYWxzbyByZWFkIHRoZSBoZWFkZXIgb2YgdGhlIG5leHQgYmxvY2suXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdG9tU2l6ZSA9IG1lZGlhRmlsZVJlYWRlci5nZXRMb25nQXQob2Zmc2V0LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0b21TaXplID09IDAgfHwgaXNOYU4oYXRvbVNpemUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25TdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXRvbU5hbWUgPSBtZWRpYUZpbGVSZWFkZXIuZ2V0U3RyaW5nQXQob2Zmc2V0ICsgNCwgNCk7IC8vIGNvbnNvbGUubG9nKHBhcmVudEF0b21GdWxsTmFtZSwgYXRvbU5hbWUsIGF0b21TaXplKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb250YWluZXIgYXRvbXMgKG5vIGFjdHVhbCBkYXRhKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNDb250YWluZXJBdG9tKGF0b21OYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGF0b21OYW1lID09IFwibWV0YVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBcIm1ldGFcIiBhdG9tIGJyZWFrcyBjb252ZW50aW9uIGFuZCBpcyBhIGNvbnRhaW5lciB3aXRoIGRhdGEuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0OyAvLyBuZXh0X2l0ZW1faWQgKHVpbnQzMilcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYXRvbUZ1bGxOYW1lID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhcmVudEF0b21GdWxsTmFtZSA/IHBhcmVudEF0b21GdWxsTmFtZSArIFwiLlwiIDogXCJcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdG9tTmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYXRvbUZ1bGxOYW1lID09PSBcIm1vb3YudWR0YS5tZXRhLmlsc3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYUZpbGVSZWFkZXIubG9hZFJhbmdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtvZmZzZXQsIG9mZnNldCArIGF0b21TaXplXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRmlsZVJlYWRlci5sb2FkUmFuZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW29mZnNldCArIDgsIG9mZnNldCArIDggKyA4XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbG9hZEF0b20oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFGaWxlUmVhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArIDgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRvbUZ1bGxOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGNhbGxiYWNrcy5vbkVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgbWVkaWFGaWxlUmVhZGVyLmxvYWRSYW5nZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgW29mZnNldCArIGF0b21TaXplLCBvZmZzZXQgKyBhdG9tU2l6ZSArIDhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9sb2FkQXRvbShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFGaWxlUmVhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKyBhdG9tU2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50QXRvbUZ1bGxOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBjYWxsYmFja3Mub25FcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiX2lzQ29udGFpbmVyQXRvbVwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQ29udGFpbmVyQXRvbShhdG9tTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICBbXCJtb292XCIsIFwidWR0YVwiLCBcIm1ldGFcIiwgXCJpbHN0XCJdLmluZGV4T2YoYXRvbU5hbWUpID49IDBcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9jYW5SZWFkQXRvbVwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhblJlYWRBdG9tKGF0b21OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0b21OYW1lICE9PSBcIi0tLS1cIjtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfcGFyc2VEYXRhXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VEYXRhKGRhdGEsIHRhZ3NUb1JlYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFncyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ3NUb1JlYWQgPSB0aGlzLl9leHBhbmRTaG9ydGN1dFRhZ3ModGFnc1RvUmVhZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRBdG9tKHRhZ3MsIGRhdGEsIDAsIGRhdGEuZ2V0U2l6ZSgpLCB0YWdzVG9SZWFkKTsgLy8gY3JlYXRlIHNob3J0Y3V0cyBmb3IgbW9zdCBjb21tb24gZGF0YS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBTSE9SVENVVFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChTSE9SVENVVFMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHRhZ3NbU0hPUlRDVVRTW25hbWVdXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJ0cmFja1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzW25hbWVdID0gdGFnLmRhdGEudHJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3NbbmFtZV0gPSB0YWcuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIk1QNFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZnR5cDogZGF0YS5nZXRTdHJpbmdBdCg4LCA0KSxcclxuICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IGRhdGEuZ2V0TG9uZ0F0KDEyLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IHRhZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfcmVhZEF0b21cIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkQXRvbShcclxuICAgICAgICAgICAgICAgICAgICB0YWdzLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICB0YWdzVG9SZWFkLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEF0b21GdWxsTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRcclxuICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gaW5kZW50ID09PSB1bmRlZmluZWQgPyBcIlwiIDogaW5kZW50ICsgXCIgIFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWVrID0gb2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2VlayA8IG9mZnNldCArIGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGF0b21TaXplID0gZGF0YS5nZXRMb25nQXQoc2VlaywgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGF0b21TaXplID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBhdG9tTmFtZSA9IGRhdGEuZ2V0U3RyaW5nQXQoc2VlayArIDQsIDQpOyAvLyBjb25zb2xlLmxvZyhzZWVrLCBwYXJlbnRBdG9tRnVsbE5hbWUsIGF0b21OYW1lLCBhdG9tU2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ29udGFpbmVyQXRvbShhdG9tTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0b21OYW1lID09IFwibWV0YVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlayArPSA0OyAvLyBuZXh0X2l0ZW1faWQgKHVpbnQzMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0b21GdWxsTmFtZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhcmVudEF0b21GdWxsTmFtZSA/IHBhcmVudEF0b21GdWxsTmFtZSArIFwiLlwiIDogXCJcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0b21OYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZEF0b20oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWsgKyA4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0b21TaXplIC0gOCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzVG9SZWFkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0b21GdWxsTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgIH0gLy8gVmFsdWUgYXRvbXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghdGFnc1RvUmVhZCB8fCB0YWdzVG9SZWFkLmluZGV4T2YoYXRvbU5hbWUpID49IDApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEF0b21GdWxsTmFtZSA9PT0gXCJtb292LnVkdGEubWV0YS5pbHN0XCIgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuUmVhZEF0b20oYXRvbU5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnc1thdG9tTmFtZV0gPSB0aGlzLl9yZWFkTWV0YWRhdGFBdG9tKGRhdGEsIHNlZWspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIHNlZWsgKz0gYXRvbVNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9yZWFkTWV0YWRhdGFBdG9tXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVhZE1ldGFkYXRhQXRvbShkYXRhLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAxNjogc2l6ZSArIG5hbWUgKyBzaXplICsgXCJkYXRhXCIgKDQgYnl0ZXMgZWFjaClcclxuICAgICAgICAgICAgICAgICAgICAvLyA4OiAxIGJ5dGUgYXRvbSB2ZXJzaW9uICYgMyBieXRlcyBhdG9tIGZsYWdzICsgNCBieXRlcyBOVUxMIHNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gODogNCBieXRlcyB0cmFjayArIDQgYnl0ZXMgdG90YWxcclxuICAgICAgICAgICAgICAgICAgICB2YXIgTUVUQURBVEFfSEVBREVSID0gMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0b21TaXplID0gZGF0YS5nZXRMb25nQXQob2Zmc2V0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXRvbU5hbWUgPSBkYXRhLmdldFN0cmluZ0F0KG9mZnNldCArIDQsIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrbGFzcyA9IGRhdGEuZ2V0SW50ZWdlcjI0QXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKyBNRVRBREFUQV9IRUFERVIgKyAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBUWVBFU1trbGFzc107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0b21EYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaWdFbmRpYW4gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXRvbU5hbWUgPT0gXCJ0cmtuXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGF0b21EYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjazogZGF0YS5nZXRTaG9ydEF0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArIE1FVEFEQVRBX0hFQURFUiArIDEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ0VuZGlhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogZGF0YS5nZXRTaG9ydEF0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArIE1FVEFEQVRBX0hFQURFUiArIDE0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ0VuZGlhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0b21OYW1lID09IFwiZGlza1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBhdG9tRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzazogZGF0YS5nZXRTaG9ydEF0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArIE1FVEFEQVRBX0hFQURFUiArIDEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ0VuZGlhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogZGF0YS5nZXRTaG9ydEF0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArIE1FVEFEQVRBX0hFQURFUiArIDE0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ0VuZGlhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gNDogYXRvbSB2ZXJzaW9uICgxIGJ5dGUpICsgYXRvbSBmbGFncyAoMyBieXRlcylcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIDQ6IE5VTEwgKHVzdWFsbHkgbG9jYWxlIGluZGljYXRvcilcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBhdG9tSGVhZGVyID0gTUVUQURBVEFfSEVBREVSICsgNCArIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVN0YXJ0ID0gb2Zmc2V0ICsgYXRvbUhlYWRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhTGVuZ3RoID0gYXRvbVNpemUgLSBhdG9tSGVhZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGF0b21EYXRhOyAvLyBXb3JrYXJvdW5kIGZvciBjb3ZlcnMgYmVpbmcgcGFyc2VkIGFzICd1aW50OCcgdHlwZSBkZXNwaXRlIGJlaW5nIGFuICdjb3ZyJyBhdG9tXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGF0b21OYW1lID09PSBcImNvdnJcIiAmJiB0eXBlID09PSBcInVpbnQ4XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwianBlZ1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0b21EYXRhID0gZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldFN0cmluZ1dpdGhDaGFyc2V0QXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1dGYtOFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1aW50OFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0b21EYXRhID0gZGF0YS5nZXRTaG9ydEF0KGRhdGFTdGFydCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImludFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidWludFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRob3VnaCB0aGUgUXVpY2tUaW1lIHNwZWMgZG9lc24ndCBzdGF0ZSBpdCwgdGhlcmUgYXJlIDY0LWJpdCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWNoIGFzIHBsSUQgKFBsYXlsaXN0L0NvbGxlY3Rpb24gSUQpLiBXaXRoIGl0cyBzaW5nbGUgNjQtYml0IGZsb2F0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQgbnVtYmVyIHR5cGUsIHRoZXNlIGFyZSBoYXJkIHRvIHBhcnNlIGFuZCBwYXNzIGluIEphdmFTY3JpcHQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGhpZ2ggd29yZCBvZiBwbElEIHNlZW1zIHRvIGFsd2F5cyBiZSB6ZXJvLCBzbywgYXMgdGhpcyBpcyB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGN1cnJlbnQgNjQtYml0IGF0b20gaGFuZGxlZCwgaXQgaXMgcGFyc2VkIGZyb20gaXRzIDMyLWJpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvdyB3b3JkIGFzIGFuIHVuc2lnbmVkIGxvbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50UmVhZGVyID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT0gXCJpbnRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGFMZW5ndGggPT0gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YS5nZXRTQnl0ZUF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkYXRhTGVuZ3RoID09IDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGEuZ2V0U1Nob3J0QXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRhdGFMZW5ndGggPT0gNFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YS5nZXRTTG9uZ0F0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkYXRhLmdldExvbmdBdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRhdGFMZW5ndGggPT0gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGEuZ2V0Qnl0ZUF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGF0YUxlbmd0aCA9PSAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YS5nZXRTaG9ydEF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGF0YS5nZXRMb25nQXQ7IC8vICRGbG93Rml4TWUgLSBnZXRCeXRlQXQgZG9lc24ndCByZWNlaXZlIGEgc2Vjb25kIGFyZ3VtZW50XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0b21EYXRhID0gaW50UmVhZGVyLmNhbGwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVN0YXJ0ICsgKGRhdGFMZW5ndGggPT0gOCA/IDQgOiAwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImpwZWdcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBuZ1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0b21EYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcImltYWdlL1wiICsgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEuZ2V0Qnl0ZXNBdChkYXRhU3RhcnQsIGRhdGFMZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGF0b21OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgc2l6ZTogYXRvbVNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogQVRPTV9ERVNDUklQVElPTlNbYXRvbU5hbWVdIHx8IFwiVW5rbm93blwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogYXRvbURhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRTaG9ydGN1dHNcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNob3J0Y3V0cygpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU0hPUlRDVVRTO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImdldFRhZ0lkZW50aWZpZXJCeXRlUmFuZ2VcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRhZ0lkZW50aWZpZXJCeXRlUmFuZ2UoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRhZyBpZGVudGlmaWVyIGlzIGxvY2F0ZWQgaW4gWzQsIDhdIGJ1dCBzaW5jZSB3ZSdsbCBuZWVkIHRvIHJlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBoZWFkZXIgb2YgdGhlIGZpcnN0IGJsb2NrIGFueXdheSwgd2UgbG9hZCBpdCBpbnN0ZWFkIHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFraW5nIHR3byByZXF1ZXN0cy5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiAxNixcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImNhblJlYWRUYWdGb3JtYXRcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhblJlYWRUYWdGb3JtYXQodGFnSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXHJcbiAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICB0YWdJZGVudGlmaWVyLnNsaWNlKDQsIDgpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQgPT09IFwiZnR5cFwiO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gTVA0VGFnUmVhZGVyO1xyXG4gICAgICAgICAgfSkoTWVkaWFUYWdSZWFkZXIpO1xyXG4gICAgICAgICAgLypcclxuICAgICAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2NvbnRlbnQvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9NZXRhZGF0YS9NZXRhZGF0YS5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDEtU1czNVxyXG4gICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgdmFyIFRZUEVTID0ge1xyXG4gICAgICAgICAgICAwOiBcInVpbnQ4XCIsXHJcbiAgICAgICAgICAgIDE6IFwidGV4dFwiLFxyXG4gICAgICAgICAgICAxMzogXCJqcGVnXCIsXHJcbiAgICAgICAgICAgIDE0OiBcInBuZ1wiLFxyXG4gICAgICAgICAgICAyMTogXCJpbnRcIixcclxuICAgICAgICAgICAgMjI6IFwidWludFwiLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIHZhciBBVE9NX0RFU0NSSVBUSU9OUyA9IHtcclxuICAgICAgICAgICAgXCLCqWFsYlwiOiBcIkFsYnVtXCIsXHJcbiAgICAgICAgICAgIFwiwqlBUlRcIjogXCJBcnRpc3RcIixcclxuICAgICAgICAgICAgYUFSVDogXCJBbGJ1bSBBcnRpc3RcIixcclxuICAgICAgICAgICAgXCLCqWRheVwiOiBcIlJlbGVhc2UgRGF0ZVwiLFxyXG4gICAgICAgICAgICBcIsKpbmFtXCI6IFwiVGl0bGVcIixcclxuICAgICAgICAgICAgXCLCqWdlblwiOiBcIkdlbnJlXCIsXHJcbiAgICAgICAgICAgIGducmU6IFwiR2VucmVcIixcclxuICAgICAgICAgICAgdHJrbjogXCJUcmFjayBOdW1iZXJcIixcclxuICAgICAgICAgICAgXCLCqXdydFwiOiBcIkNvbXBvc2VyXCIsXHJcbiAgICAgICAgICAgIFwiwql0b29cIjogXCJFbmNvZGluZyBUb29sXCIsXHJcbiAgICAgICAgICAgIFwiwqllbmNcIjogXCJFbmNvZGVkIEJ5XCIsXHJcbiAgICAgICAgICAgIGNwcnQ6IFwiQ29weXJpZ2h0XCIsXHJcbiAgICAgICAgICAgIGNvdnI6IFwiQ292ZXIgQXJ0XCIsXHJcbiAgICAgICAgICAgIFwiwqlncnBcIjogXCJHcm91cGluZ1wiLFxyXG4gICAgICAgICAgICBrZXl3OiBcIktleXdvcmRzXCIsXHJcbiAgICAgICAgICAgIFwiwqlseXJcIjogXCJMeXJpY3NcIixcclxuICAgICAgICAgICAgXCLCqWNtdFwiOiBcIkNvbW1lbnRcIixcclxuICAgICAgICAgICAgdG1wbzogXCJUZW1wb1wiLFxyXG4gICAgICAgICAgICBjcGlsOiBcIkNvbXBpbGF0aW9uXCIsXHJcbiAgICAgICAgICAgIGRpc2s6IFwiRGlzYyBOdW1iZXJcIixcclxuICAgICAgICAgICAgdHZzaDogXCJUViBTaG93IE5hbWVcIixcclxuICAgICAgICAgICAgdHZlbjogXCJUViBFcGlzb2RlIElEXCIsXHJcbiAgICAgICAgICAgIHR2c246IFwiVFYgU2Vhc29uXCIsXHJcbiAgICAgICAgICAgIHR2ZXM6IFwiVFYgRXBpc29kZVwiLFxyXG4gICAgICAgICAgICB0dm5uOiBcIlRWIE5ldHdvcmtcIixcclxuICAgICAgICAgICAgZGVzYzogXCJEZXNjcmlwdGlvblwiLFxyXG4gICAgICAgICAgICBsZGVzOiBcIkxvbmcgRGVzY3JpcHRpb25cIixcclxuICAgICAgICAgICAgc29ubTogXCJTb3J0IE5hbWVcIixcclxuICAgICAgICAgICAgc29hcjogXCJTb3J0IEFydGlzdFwiLFxyXG4gICAgICAgICAgICBzb2FhOiBcIlNvcnQgQWxidW1cIixcclxuICAgICAgICAgICAgc29jbzogXCJTb3J0IENvbXBvc2VyXCIsXHJcbiAgICAgICAgICAgIHNvc246IFwiU29ydCBTaG93XCIsXHJcbiAgICAgICAgICAgIHB1cmQ6IFwiUHVyY2hhc2UgRGF0ZVwiLFxyXG4gICAgICAgICAgICBwY3N0OiBcIlBvZGNhc3RcIixcclxuICAgICAgICAgICAgcHVybDogXCJQb2RjYXN0IFVSTFwiLFxyXG4gICAgICAgICAgICBjYXRnOiBcIkNhdGVnb3J5XCIsXHJcbiAgICAgICAgICAgIGhkdmQ6IFwiSEQgVmlkZW9cIixcclxuICAgICAgICAgICAgc3RpazogXCJNZWRpYSBUeXBlXCIsXHJcbiAgICAgICAgICAgIHJ0bmc6IFwiQ29udGVudCBSYXRpbmdcIixcclxuICAgICAgICAgICAgcGdhcDogXCJHYXBsZXNzIFBsYXliYWNrXCIsXHJcbiAgICAgICAgICAgIGFwSUQ6IFwiUHVyY2hhc2UgQWNjb3VudFwiLFxyXG4gICAgICAgICAgICBzZklEOiBcIkNvdW50cnkgQ29kZVwiLFxyXG4gICAgICAgICAgICBhdElEOiBcIkFydGlzdCBJRFwiLFxyXG4gICAgICAgICAgICBjbklEOiBcIkNhdGFsb2cgSURcIixcclxuICAgICAgICAgICAgcGxJRDogXCJDb2xsZWN0aW9uIElEXCIsXHJcbiAgICAgICAgICAgIGdlSUQ6IFwiR2VucmUgSURcIixcclxuICAgICAgICAgICAgXCJ4aWQgXCI6IFwiVmVuZG9yIEluZm9ybWF0aW9uXCIsXHJcbiAgICAgICAgICAgIGZsdnI6IFwiQ29kZWMgRmxhdm9yXCIsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgdmFyIFVOU1VQUE9SVEVEX0FUT01TID0ge1xyXG4gICAgICAgICAgICBcIi0tLS1cIjogMSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICB2YXIgU0hPUlRDVVRTID0ge1xyXG4gICAgICAgICAgICB0aXRsZTogXCLCqW5hbVwiLFxyXG4gICAgICAgICAgICBhcnRpc3Q6IFwiwqlBUlRcIixcclxuICAgICAgICAgICAgYWxidW06IFwiwqlhbGJcIixcclxuICAgICAgICAgICAgeWVhcjogXCLCqWRheVwiLFxyXG4gICAgICAgICAgICBjb21tZW50OiBcIsKpY210XCIsXHJcbiAgICAgICAgICAgIHRyYWNrOiBcInRya25cIixcclxuICAgICAgICAgICAgZ2VucmU6IFwiwqlnZW5cIixcclxuICAgICAgICAgICAgcGljdHVyZTogXCJjb3ZyXCIsXHJcbiAgICAgICAgICAgIGx5cmljczogXCLCqWx5clwiLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gTVA0VGFnUmVhZGVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeyBcIi4vTWVkaWFGaWxlUmVhZGVyXCI6IDExLCBcIi4vTWVkaWFUYWdSZWFkZXJcIjogMTIgfSxcclxuICAgICAgXSxcclxuICAgICAgMTE6IFtcclxuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XHJcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3RvUHJvcHMpXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcclxuICAgICAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgU3RyaW5nVXRpbHMgPSByZXF1aXJlKFwiLi9TdHJpbmdVdGlsc1wiKTtcclxuXHJcbiAgICAgICAgICB2YXIgTWVkaWFGaWxlUmVhZGVyID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBNZWRpYUZpbGVSZWFkZXIocGF0aCkge1xyXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZWRpYUZpbGVSZWFkZXIpO1xyXG5cclxuICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaXNJbml0aWFsaXplZFwiLCB2b2lkIDApO1xyXG5cclxuICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2l6ZVwiLCB2b2lkIDApO1xyXG5cclxuICAgICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlY2lkZXMgaWYgdGhpcyBtZWRpYSBmaWxlIHJlYWRlciBpcyBhYmxlIHRvIHJlYWQgdGhlIGdpdmVuIGZpbGUuXHJcbiAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFxyXG4gICAgICAgICAgICAgIE1lZGlhRmlsZVJlYWRlcixcclxuICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJpbml0XCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOlxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgY2FsbGVkIGJlZm9yZSBhbnkgb3RoZXIgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICogTG9hZHMgdGhlIG5lY2Vzc2FyeSBpbml0aWFsIGluZm9ybWF0aW9uIGZyb20gdGhlIGZpbGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaW5pdChjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrcy5vblN1Y2Nlc3MsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luaXQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25TdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBjYWxsYmFja3Mub25FcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfaW5pdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBpbXBsZW1lbnQgaW5pdCBmdW5jdGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSByYW5nZSBUaGUgc3RhcnQgYW5kIGVuZCBpbmRleGVzIG9mIHRoZSByYW5nZSB0byBsb2FkLlxyXG4gICAgICAgICAgICAgICAgICAgKiAgICAgICAgRXg6IFswLCA3XSBsb2FkIGJ5dGVzIDAgdG8gNyBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImxvYWRSYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFJhbmdlKHJhbmdlLCBjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IGltcGxlbWVudCBsb2FkUmFuZ2UgZnVuY3Rpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIFRoZSBzaXplIG9mIHRoZSBmaWxlIGluIGJ5dGVzLlxyXG4gICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRTaXplXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaXplKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5pdCgpIG11c3QgYmUgY2FsbGVkIGZpcnN0LlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImdldEJ5dGVBdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qnl0ZUF0KG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgaW1wbGVtZW50IGdldEJ5dGVBdCBmdW5jdGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRCeXRlc0F0XCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCeXRlc0F0KG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gdGhpcy5nZXRCeXRlQXQob2Zmc2V0ICsgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXM7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiaXNCaXRTZXRBdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNCaXRTZXRBdChvZmZzZXQsIGJpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpQnl0ZSA9IHRoaXMuZ2V0Qnl0ZUF0KG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpQnl0ZSAmICgxIDw8IGJpdCkpICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiZ2V0U0J5dGVBdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U0J5dGVBdChvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaUJ5dGUgPSB0aGlzLmdldEJ5dGVBdChvZmZzZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaUJ5dGUgPiAxMjcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpQnl0ZSAtIDI1NjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlCeXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRTaG9ydEF0XCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaG9ydEF0KG9mZnNldCwgaXNCaWdFbmRpYW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaVNob3J0ID0gaXNCaWdFbmRpYW5cclxuICAgICAgICAgICAgICAgICAgICAgID8gKHRoaXMuZ2V0Qnl0ZUF0KG9mZnNldCkgPDwgOCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEJ5dGVBdChvZmZzZXQgKyAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiAodGhpcy5nZXRCeXRlQXQob2Zmc2V0ICsgMSkgPDwgOCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEJ5dGVBdChvZmZzZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaVNob3J0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaVNob3J0ICs9IDY1NTM2O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlTaG9ydDtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRTU2hvcnRBdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U1Nob3J0QXQob2Zmc2V0LCBpc0JpZ0VuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpVVNob3J0ID0gdGhpcy5nZXRTaG9ydEF0KG9mZnNldCwgaXNCaWdFbmRpYW4pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaVVTaG9ydCA+IDMyNzY3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVVTaG9ydCAtIDY1NTM2O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVVTaG9ydDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiZ2V0TG9uZ0F0XCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb25nQXQob2Zmc2V0LCBpc0JpZ0VuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpQnl0ZTEgPSB0aGlzLmdldEJ5dGVBdChvZmZzZXQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgaUJ5dGUyID0gdGhpcy5nZXRCeXRlQXQob2Zmc2V0ICsgMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICBpQnl0ZTMgPSB0aGlzLmdldEJ5dGVBdChvZmZzZXQgKyAyKSxcclxuICAgICAgICAgICAgICAgICAgICAgIGlCeXRlNCA9IHRoaXMuZ2V0Qnl0ZUF0KG9mZnNldCArIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpTG9uZyA9IGlzQmlnRW5kaWFuXHJcbiAgICAgICAgICAgICAgICAgICAgICA/ICgoKCgoaUJ5dGUxIDw8IDgpICsgaUJ5dGUyKSA8PCA4KSArIGlCeXRlMykgPDwgOCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpQnl0ZTRcclxuICAgICAgICAgICAgICAgICAgICAgIDogKCgoKChpQnl0ZTQgPDwgOCkgKyBpQnl0ZTMpIDw8IDgpICsgaUJ5dGUyKSA8PCA4KSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlCeXRlMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlMb25nIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaUxvbmcgKz0gNDI5NDk2NzI5NjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpTG9uZztcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRTTG9uZ0F0XCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTTG9uZ0F0KG9mZnNldCwgaXNCaWdFbmRpYW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaVVMb25nID0gdGhpcy5nZXRMb25nQXQob2Zmc2V0LCBpc0JpZ0VuZGlhbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpVUxvbmcgPiAyMTQ3NDgzNjQ3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVVMb25nIC0gNDI5NDk2NzI5NjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlVTG9uZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiZ2V0SW50ZWdlcjI0QXRcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEludGVnZXIyNEF0KG9mZnNldCwgaXNCaWdFbmRpYW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaUJ5dGUxID0gdGhpcy5nZXRCeXRlQXQob2Zmc2V0KSxcclxuICAgICAgICAgICAgICAgICAgICAgIGlCeXRlMiA9IHRoaXMuZ2V0Qnl0ZUF0KG9mZnNldCArIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgaUJ5dGUzID0gdGhpcy5nZXRCeXRlQXQob2Zmc2V0ICsgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlJbnRlZ2VyID0gaXNCaWdFbmRpYW5cclxuICAgICAgICAgICAgICAgICAgICAgID8gKCgoaUJ5dGUxIDw8IDgpICsgaUJ5dGUyKSA8PCA4KSArIGlCeXRlM1xyXG4gICAgICAgICAgICAgICAgICAgICAgOiAoKChpQnl0ZTMgPDwgOCkgKyBpQnl0ZTIpIDw8IDgpICsgaUJ5dGUxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaUludGVnZXIgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpSW50ZWdlciArPSAxNjc3NzIxNjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpSW50ZWdlcjtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRTdHJpbmdBdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RyaW5nQXQob2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvZmZzZXQsIGogPSAwOyBpIDwgb2Zmc2V0ICsgbGVuZ3RoOyBpKyssIGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgc3RyaW5nW2pdID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmdldEJ5dGVBdChpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiZ2V0U3RyaW5nV2l0aENoYXJzZXRBdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RyaW5nV2l0aENoYXJzZXRBdChcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXRcclxuICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVzID0gdGhpcy5nZXRCeXRlc0F0KG9mZnNldCwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyaW5nO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKChjaGFyc2V0IHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1dGYtMTZcIjpcclxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInV0Zi0xNmJlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IFN0cmluZ1V0aWxzLnJlYWRVVEYxNlN0cmluZyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID09PSBcInV0Zi0xNmJlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInV0Zi04XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IFN0cmluZ1V0aWxzLnJlYWRVVEY4U3RyaW5nKGJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gU3RyaW5nVXRpbHMucmVhZE51bGxUZXJtaW5hdGVkU3RyaW5nKGJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImdldENoYXJBdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhckF0KG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuZ2V0Qnl0ZUF0KG9mZnNldCkpO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICogVGhlIElEM3YyIHRhZy9mcmFtZSBzaXplIGlzIGVuY29kZWQgd2l0aCBmb3VyIGJ5dGVzIHdoZXJlIHRoZSBtb3N0XHJcbiAgICAgICAgICAgICAgICAgICAqIHNpZ25pZmljYW50IGJpdCAoYml0IDcpIGlzIHNldCB0byB6ZXJvIGluIGV2ZXJ5IGJ5dGUsIG1ha2luZyBhIHRvdGFsIG9mIDI4XHJcbiAgICAgICAgICAgICAgICAgICAqIGJpdHMuIFRoZSB6ZXJvZWQgYml0cyBhcmUgaWdub3JlZCwgc28gYSAyNTcgYnl0ZXMgbG9uZyB0YWcgaXMgcmVwcmVzZW50ZWRcclxuICAgICAgICAgICAgICAgICAgICogYXMgJDAwIDAwIDAyIDAxLlxyXG4gICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRTeW5jaHNhZmVJbnRlZ2VyMzJBdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3luY2hzYWZlSW50ZWdlcjMyQXQob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUxID0gdGhpcy5nZXRCeXRlQXQob2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZTIgPSB0aGlzLmdldEJ5dGVBdChvZmZzZXQgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZTMgPSB0aGlzLmdldEJ5dGVBdChvZmZzZXQgKyAyKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZTQgPSB0aGlzLmdldEJ5dGVBdChvZmZzZXQgKyAzKTsgLy8gMHg3ZiA9IDBiMDExMTExMTFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgKHNpemU0ICYgMHg3ZikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgKChzaXplMyAmIDB4N2YpIDw8IDcpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICgoc2l6ZTIgJiAweDdmKSA8PCAxNCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgKChzaXplMSAmIDB4N2YpIDw8IDIxKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJjYW5SZWFkRmlsZVwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FuUmVhZEZpbGUoZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgaW1wbGVtZW50IGNhblJlYWRGaWxlIGZ1bmN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gTWVkaWFGaWxlUmVhZGVyO1xyXG4gICAgICAgICAgfSkoKTtcclxuXHJcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IE1lZGlhRmlsZVJlYWRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHsgXCIuL1N0cmluZ1V0aWxzXCI6IDEzIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIDEyOiBbXHJcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xyXG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm90b1Byb3BzKVxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcclxuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIE1lZGlhRmlsZVJlYWRlciA9IHJlcXVpcmUoXCIuL01lZGlhRmlsZVJlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgTWVkaWFUYWdSZWFkZXIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE1lZGlhVGFnUmVhZGVyKG1lZGlhRmlsZVJlYWRlcikge1xyXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZWRpYVRhZ1JlYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tZWRpYUZpbGVSZWFkZXJcIiwgdm9pZCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhZ3NcIiwgdm9pZCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgdGhpcy5fbWVkaWFGaWxlUmVhZGVyID0gbWVkaWFGaWxlUmVhZGVyO1xyXG4gICAgICAgICAgICAgIHRoaXMuX3RhZ3MgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBieXRlIHJhbmdlIHRoYXQgbmVlZHMgdG8gYmUgbG9hZGVkIGFuZCBmZWQgdG9cclxuICAgICAgICAgICAgICogX2NhblJlYWRUYWdGb3JtYXQgaW4gb3JkZXIgdG8gaWRlbnRpZnkgaWYgdGhlIGZpbGUgY29udGFpbnMgdGFnXHJcbiAgICAgICAgICAgICAqIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIHJlYWQuXHJcbiAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFxyXG4gICAgICAgICAgICAgIE1lZGlhVGFnUmVhZGVyLFxyXG4gICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcInNldFRhZ3NUb1JlYWRcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRhZ3NUb1JlYWQodGFncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhZ3MgPSB0YWdzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcInJlYWRcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWQoY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYUZpbGVSZWFkZXIuaW5pdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbG9hZERhdGEoc2VsZi5fbWVkaWFGaWxlUmVhZGVyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFncyA9IHNlbGYuX3BhcnNlRGF0YShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9tZWRpYUZpbGVSZWFkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fdGFnc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uRXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwYXJzZURhdGFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm86IGV4Lm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8vIFRPRE86IGRlc3Ryb3kgbWVkaWFGaWxlUmVhZGVyXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uU3VjY2Vzcyh0YWdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGNhbGxiYWNrcy5vbkVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBjYWxsYmFja3Mub25FcnJvcixcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJnZXRTaG9ydGN1dHNcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNob3J0Y3V0cygpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgKiBMb2FkIHRoZSBuZWNlc3NhcnkgYnl0ZXMgZnJvbSB0aGUgbWVkaWEgZmlsZS5cclxuICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiX2xvYWREYXRhXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZERhdGEobWVkaWFGaWxlUmVhZGVyLCBjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IGltcGxlbWVudCBfbG9hZERhdGEgZnVuY3Rpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgKiBQYXJzZSB0aGUgbG9hZGVkIGRhdGEgdG8gcmVhZCB0aGUgbWVkaWEgdGFncy5cclxuICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiX3BhcnNlRGF0YVwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlRGF0YShtZWRpYUZpbGVSZWFkZXIsIHRhZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IGltcGxlbWVudCBfcGFyc2VEYXRhIGZ1bmN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9leHBhbmRTaG9ydGN1dFRhZ3NcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9leHBhbmRTaG9ydGN1dFRhZ3ModGFnc1dpdGhTaG9ydGN1dHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhZ3NXaXRoU2hvcnRjdXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3J0Y3V0cyA9IHRoaXMuZ2V0U2hvcnRjdXRzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDAsIHRhZ09yU2hvcnRjdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAodGFnT3JTaG9ydGN1dCA9IHRhZ3NXaXRoU2hvcnRjdXRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGkrK1xyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGFncyA9IHRhZ3MuY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dHNbdGFnT3JTaG9ydGN1dF0gfHwgW3RhZ09yU2hvcnRjdXRdXHJcbiAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhZ3M7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiZ2V0VGFnSWRlbnRpZmllckJ5dGVSYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFnSWRlbnRpZmllckJ5dGVSYW5nZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IGltcGxlbWVudFwiKTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAqIEdpdmVuIGEgdGFnIGlkZW50aWZpZXIgKHJlYWQgZnJvbSB0aGUgZmlsZSBieXRlIHBvc2l0aW9ucyBzcGVmaWNpZWQgYnlcclxuICAgICAgICAgICAgICAgICAgICogZ2V0VGFnSWRlbnRpZmllckJ5dGVSYW5nZSkgdGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgaXQgY2FuIHJlYWQgdGhlIHRhZ1xyXG4gICAgICAgICAgICAgICAgICAgKiBmb3JtYXQgb3Igbm90LlxyXG4gICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJjYW5SZWFkVGFnRm9ybWF0XCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5SZWFkVGFnRm9ybWF0KHRhZ0lkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IGltcGxlbWVudFwiKTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIE1lZGlhVGFnUmVhZGVyO1xyXG4gICAgICAgICAgfSkoKTtcclxuXHJcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IE1lZGlhVGFnUmVhZGVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeyBcIi4vTWVkaWFGaWxlUmVhZGVyXCI6IDExIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIDEzOiBbXHJcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xyXG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm90b1Byb3BzKVxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcclxuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIEludGVybmFsRGVjb2RlZFN0cmluZyA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSW50ZXJuYWxEZWNvZGVkU3RyaW5nKHZhbHVlLCBieXRlc1JlYWRDb3VudCkge1xyXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcm5hbERlY29kZWRTdHJpbmcpO1xyXG5cclxuICAgICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdmFsdWVcIiwgdm9pZCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYnl0ZXNSZWFkQ291bnRcIiwgdm9pZCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGVuZ3RoXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgdGhpcy5ieXRlc1JlYWRDb3VudCA9IGJ5dGVzUmVhZENvdW50O1xyXG4gICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW50ZXJuYWxEZWNvZGVkU3RyaW5nLCBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiBcInRvU3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJuYWxEZWNvZGVkU3RyaW5nO1xyXG4gICAgICAgICAgfSkoKTtcclxuXHJcbiAgICAgICAgICB2YXIgU3RyaW5nVXRpbHMgPSB7XHJcbiAgICAgICAgICAgIHJlYWRVVEYxNlN0cmluZzogZnVuY3Rpb24gcmVhZFVURjE2U3RyaW5nKFxyXG4gICAgICAgICAgICAgIGJ5dGVzLFxyXG4gICAgICAgICAgICAgIGJpZ0VuZGlhbixcclxuICAgICAgICAgICAgICBtYXhCeXRlc1xyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICB2YXIgaXggPSAwO1xyXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQxID0gMSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDIgPSAwO1xyXG4gICAgICAgICAgICAgIG1heEJ5dGVzID0gTWF0aC5taW4obWF4Qnl0ZXMgfHwgYnl0ZXMubGVuZ3RoLCBieXRlcy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoYnl0ZXNbMF0gPT0gMHhmZSAmJiBieXRlc1sxXSA9PSAweGZmKSB7XHJcbiAgICAgICAgICAgICAgICBiaWdFbmRpYW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaXggPSAyO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYnl0ZXNbMF0gPT0gMHhmZiAmJiBieXRlc1sxXSA9PSAweGZlKSB7XHJcbiAgICAgICAgICAgICAgICBiaWdFbmRpYW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGl4ID0gMjtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChiaWdFbmRpYW4pIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldDEgPSAwO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0MiA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB2YXIgYXJyID0gW107XHJcblxyXG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBpeCA8IG1heEJ5dGVzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBieXRlMSA9IGJ5dGVzW2l4ICsgb2Zmc2V0MV07XHJcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSBieXRlc1tpeCArIG9mZnNldDJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHdvcmQxID0gKGJ5dGUxIDw8IDgpICsgYnl0ZTI7XHJcbiAgICAgICAgICAgICAgICBpeCArPSAyO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh3b3JkMSA9PSAweDAwMDApIHtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJ5dGUxIDwgMHhkOCB8fCBieXRlMSA+PSAweGUwKSB7XHJcbiAgICAgICAgICAgICAgICAgIGFycltqXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUod29yZDEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIGJ5dGUzID0gYnl0ZXNbaXggKyBvZmZzZXQxXTtcclxuICAgICAgICAgICAgICAgICAgdmFyIGJ5dGU0ID0gYnl0ZXNbaXggKyBvZmZzZXQyXTtcclxuICAgICAgICAgICAgICAgICAgdmFyIHdvcmQyID0gKGJ5dGUzIDw8IDgpICsgYnl0ZTQ7XHJcbiAgICAgICAgICAgICAgICAgIGl4ICs9IDI7XHJcbiAgICAgICAgICAgICAgICAgIGFycltqXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUod29yZDEsIHdvcmQyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJuYWxEZWNvZGVkU3RyaW5nKGFyci5qb2luKFwiXCIpLCBpeCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlYWRVVEY4U3RyaW5nOiBmdW5jdGlvbiByZWFkVVRGOFN0cmluZyhieXRlcywgbWF4Qnl0ZXMpIHtcclxuICAgICAgICAgICAgICB2YXIgaXggPSAwO1xyXG4gICAgICAgICAgICAgIG1heEJ5dGVzID0gTWF0aC5taW4obWF4Qnl0ZXMgfHwgYnl0ZXMubGVuZ3RoLCBieXRlcy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoYnl0ZXNbMF0gPT0gMHhlZiAmJiBieXRlc1sxXSA9PSAweGJiICYmIGJ5dGVzWzJdID09IDB4YmYpIHtcclxuICAgICAgICAgICAgICAgIGl4ID0gMztcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGl4IDwgbWF4Qnl0ZXM7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gYnl0ZXNbaXgrK107XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJ5dGUxID09IDB4MDApIHtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJ5dGUxIDwgMHg4MCkge1xyXG4gICAgICAgICAgICAgICAgICBhcnJbal0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYnl0ZTEgPj0gMHhjMiAmJiBieXRlMSA8IDB4ZTApIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gYnl0ZXNbaXgrK107XHJcbiAgICAgICAgICAgICAgICAgIGFycltqXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgKChieXRlMSAmIDB4MWYpIDw8IDYpICsgKGJ5dGUyICYgMHgzZilcclxuICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYnl0ZTEgPj0gMHhlMCAmJiBieXRlMSA8IDB4ZjApIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gYnl0ZXNbaXgrK107XHJcbiAgICAgICAgICAgICAgICAgIHZhciBieXRlMyA9IGJ5dGVzW2l4KytdO1xyXG4gICAgICAgICAgICAgICAgICBhcnJbal0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxyXG4gICAgICAgICAgICAgICAgICAgICgoYnl0ZTEgJiAweGZmKSA8PCAxMikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgKChieXRlMiAmIDB4M2YpIDw8IDYpICtcclxuICAgICAgICAgICAgICAgICAgICAgIChieXRlMyAmIDB4M2YpXHJcbiAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJ5dGUxID49IDB4ZjAgJiYgYnl0ZTEgPCAweGY1KSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBieXRlMiA9IGJ5dGVzW2l4KytdO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSBieXRlc1tpeCsrXTtcclxuICAgICAgICAgICAgICAgICAgdmFyIGJ5dGU0ID0gYnl0ZXNbaXgrK107XHJcbiAgICAgICAgICAgICAgICAgIHZhciBjb2RlcG9pbnQgPVxyXG4gICAgICAgICAgICAgICAgICAgICgoYnl0ZTEgJiAweDA3KSA8PCAxOCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICgoYnl0ZTIgJiAweDNmKSA8PCAxMikgK1xyXG4gICAgICAgICAgICAgICAgICAgICgoYnl0ZTMgJiAweDNmKSA8PCA2KSArXHJcbiAgICAgICAgICAgICAgICAgICAgKGJ5dGU0ICYgMHgzZikgLVxyXG4gICAgICAgICAgICAgICAgICAgIDB4MTAwMDA7XHJcbiAgICAgICAgICAgICAgICAgIGFycltqXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgKGNvZGVwb2ludCA+PiAxMCkgKyAweGQ4MDAsXHJcbiAgICAgICAgICAgICAgICAgICAgKGNvZGVwb2ludCAmIDB4M2ZmKSArIDB4ZGMwMFxyXG4gICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbERlY29kZWRTdHJpbmcoYXJyLmpvaW4oXCJcIiksIGl4KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVhZE51bGxUZXJtaW5hdGVkU3RyaW5nOiBmdW5jdGlvbiByZWFkTnVsbFRlcm1pbmF0ZWRTdHJpbmcoXHJcbiAgICAgICAgICAgICAgYnl0ZXMsXHJcbiAgICAgICAgICAgICAgbWF4Qnl0ZXNcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgICAgICAgIG1heEJ5dGVzID0gbWF4Qnl0ZXMgfHwgYnl0ZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heEJ5dGVzOyApIHtcclxuICAgICAgICAgICAgICAgIHZhciBieXRlMSA9IGJ5dGVzW2krK107XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJ5dGUxID09IDB4MDApIHtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYXJyW2kgLSAxXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZTEpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbERlY29kZWRTdHJpbmcoYXJyLmpvaW4oXCJcIiksIGkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gU3RyaW5nVXRpbHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7fSxcclxuICAgICAgXSxcclxuICAgICAgMTQ6IFtcclxuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XHJcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xyXG4gICAgICAgICAgICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiZcclxuICAgICAgICAgICAgICB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiZcclxuICAgICAgICAgICAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgICAgICAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmXHJcbiAgICAgICAgICAgICAgICAgIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICA/IFwic3ltYm9sXCJcclxuICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygb2JqO1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3RvUHJvcHMpXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcclxuICAgICAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFxyXG4gICAgICAgICAgICAgIHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxyXG4gICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XHJcbiAgICAgICAgICAgIF9zZXRQcm90b3R5cGVPZiA9XHJcbiAgICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcclxuICAgICAgICAgICAgICAgIG8uX19wcm90b19fID0gcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvO1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcclxuICAgICAgICAgICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcclxuICAgICAgICAgICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICBjYWxsICYmXHJcbiAgICAgICAgICAgICAgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KVxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoXHJcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XHJcbiAgICAgICAgICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZlxyXG4gICAgICAgICAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXHJcbiAgICAgICAgICAgICAgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBDaHVua2VkRmlsZURhdGEgPSByZXF1aXJlKFwiLi9DaHVua2VkRmlsZURhdGFcIik7XHJcblxyXG4gICAgICAgICAgdmFyIE1lZGlhRmlsZVJlYWRlciA9IHJlcXVpcmUoXCIuL01lZGlhRmlsZVJlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgQ0hVTktfU0laRSA9IDEwMjQ7XHJcblxyXG4gICAgICAgICAgdmFyIFhockZpbGVSZWFkZXIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX01lZGlhRmlsZVJlYWRlcikge1xyXG4gICAgICAgICAgICBfaW5oZXJpdHMoWGhyRmlsZVJlYWRlciwgX01lZGlhRmlsZVJlYWRlcik7XHJcblxyXG4gICAgICAgICAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFhockZpbGVSZWFkZXIpO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gWGhyRmlsZVJlYWRlcih1cmwpIHtcclxuICAgICAgICAgICAgICB2YXIgX3RoaXM7XHJcblxyXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYaHJGaWxlUmVhZGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl91cmxcIiwgdm9pZCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5KFxyXG4gICAgICAgICAgICAgICAgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXHJcbiAgICAgICAgICAgICAgICBcIl9maWxlRGF0YVwiLFxyXG4gICAgICAgICAgICAgICAgdm9pZCAwXHJcbiAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgX3RoaXMuX3VybCA9IHVybDtcclxuICAgICAgICAgICAgICBfdGhpcy5fZmlsZURhdGEgPSBuZXcgQ2h1bmtlZEZpbGVEYXRhKCk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoXHJcbiAgICAgICAgICAgICAgWGhyRmlsZVJlYWRlcixcclxuICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfaW5pdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFhockZpbGVSZWFkZXIuX2NvbmZpZy5hdm9pZEhlYWRSZXF1ZXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmV0Y2hTaXplV2l0aEdldFJlcXVlc3QoY2FsbGJhY2tzKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmV0Y2hTaXplV2l0aEhlYWRSZXF1ZXN0KGNhbGxiYWNrcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9mZXRjaFNpemVXaXRoSGVhZFJlcXVlc3RcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mZXRjaFNpemVXaXRoSGVhZFJlcXVlc3QoY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlWEhSUmVxdWVzdChcIkhFQURcIiwgbnVsbCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MoeGhyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50TGVuZ3RoID0gc2VsZi5fcGFyc2VDb250ZW50TGVuZ3RoKHhocik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3NpemUgPSBjb250ZW50TGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250ZW50LUxlbmd0aCBub3QgcHJvdmlkZWQgYnkgdGhlIHNlcnZlciwgZmFsbGJhY2sgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHRVQgcmVxdWVzdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZmV0Y2hTaXplV2l0aEdldFJlcXVlc3QoY2FsbGJhY2tzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGNhbGxiYWNrcy5vbkVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9mZXRjaFNpemVXaXRoR2V0UmVxdWVzdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZldGNoU2l6ZVdpdGhHZXRSZXF1ZXN0KGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5fcm91bmRSYW5nZVRvQ2h1bmtNdWx0aXBsZShbMCwgMF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlWEhSUmVxdWVzdChcIkdFVFwiLCByYW5nZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MoeGhyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50UmFuZ2UgPSBzZWxmLl9wYXJzZUNvbnRlbnRSYW5nZSh4aHIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZWxmLl9nZXRYaHJSZXNwb25zZUNvbnRlbnQoeGhyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50UmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFJhbmdlLmluc3RhbmNlTGVuZ3RoID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhc3QgcmVzb3J0LCBzZXJ2ZXIgaXMgbm90IGFibGUgdG8gdGVsbCB1cyB0aGUgY29udGVudCBsZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGZldGNoIGVudGlyZSBmaWxlIHRoZW4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9mZXRjaEVudGlyZUZpbGUoY2FsbGJhY2tzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zaXplID0gY29udGVudFJhbmdlLmluc3RhbmNlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJhbmdlIHJlcXVlc3Qgbm90IHN1cHBvcnRlZCwgd2UgZ290IHRoZSBlbnRpcmUgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3NpemUgPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZmlsZURhdGEuYWRkRGF0YSgwLCBkYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBjYWxsYmFja3Mub25FcnJvcixcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfZmV0Y2hFbnRpcmVGaWxlXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmV0Y2hFbnRpcmVGaWxlKGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZVhIUlJlcXVlc3QoXCJHRVRcIiwgbnVsbCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MoeGhyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VsZi5fZ2V0WGhyUmVzcG9uc2VDb250ZW50KHhocik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zaXplID0gZGF0YS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9maWxlRGF0YS5hZGREYXRhKDAsIGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uU3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGNhbGxiYWNrcy5vbkVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9nZXRYaHJSZXNwb25zZUNvbnRlbnRcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRYaHJSZXNwb25zZUNvbnRlbnQoeGhyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZUJvZHkgfHwgeGhyLnJlc3BvbnNlVGV4dCB8fCBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9wYXJzZUNvbnRlbnRMZW5ndGhcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZUNvbnRlbnRMZW5ndGgoeGhyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRMZW5ndGggPSB0aGlzLl9nZXRSZXNwb25zZUhlYWRlcihcclxuICAgICAgICAgICAgICAgICAgICAgIHhocixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1MZW5ndGhcIlxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50TGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoY29udGVudExlbmd0aCwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJfcGFyc2VDb250ZW50UmFuZ2VcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZUNvbnRlbnRSYW5nZSh4aHIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFJhbmdlID0gdGhpcy5fZ2V0UmVzcG9uc2VIZWFkZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICB4aHIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtUmFuZ2VcIlxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50UmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRDb250ZW50UmFuZ2UgPSBjb250ZW50UmFuZ2UubWF0Y2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC9ieXRlcyAoXFxkKyktKFxcZCspXFwvKD86KFxcZCspfFxcKikvaVxyXG4gICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZENvbnRlbnRSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJGSVhNRTogVW5rbm93biBDb250ZW50LVJhbmdlIHN5bnRheDogXCIgKyBjb250ZW50UmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEJ5dGVQb3NpdGlvbjogcGFyc2VJbnQocGFyc2VkQ29udGVudFJhbmdlWzFdLCAxMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCeXRlUG9zaXRpb246IHBhcnNlSW50KHBhcnNlZENvbnRlbnRSYW5nZVsyXSwgMTApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUxlbmd0aDogcGFyc2VkQ29udGVudFJhbmdlWzNdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJzZUludChwYXJzZWRDb250ZW50UmFuZ2VbM10sIDEwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGtleTogXCJsb2FkUmFuZ2VcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRSYW5nZShyYW5nZSwgY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9maWxlRGF0YS5oYXNEYXRhUmFuZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihzZWxmLl9zaXplLCByYW5nZVsxXSlcclxuICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2tzLm9uU3VjY2VzcywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBBbHdheXMgZG93bmxvYWQgaW4gbXVsdGlwbGVzIG9mIENIVU5LX1NJWkUuIElmIHdlJ3JlIGdvaW5nIHRvIG1ha2UgYVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgbWlnaHQgYXMgd2VsbCBnZXQgYSBjaHVuayB0aGF0IG1ha2VzIHNlbnNlLiBUaGUgYmlnIGNvc3QgaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc3RhYmxpc2hpbmcgdGhlIGNvbm5lY3Rpb24gc28gZ2V0dGluZyAxMGJ5dGVzIG9yIDFLIGRvZXNuJ3QgcmVhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBhIGRpZmZlcmVuY2UuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5fcm91bmRSYW5nZVRvQ2h1bmtNdWx0aXBsZShyYW5nZSk7IC8vIFVwcGVyIHJhbmdlIHNob3VsZCBub3QgYmUgZ3JlYXRlciB0aGFuIG1heCBmaWxlIHNpemVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0gPSBNYXRoLm1pbihzZWxmLl9zaXplLCByYW5nZVsxXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VYSFJSZXF1ZXN0KFwiR0VUXCIsIHJhbmdlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2Vzcyh4aHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZWxmLl9nZXRYaHJSZXNwb25zZUNvbnRlbnQoeGhyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpbGVEYXRhLmFkZERhdGEocmFuZ2VbMF0sIGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uU3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGNhbGxiYWNrcy5vbkVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9yb3VuZFJhbmdlVG9DaHVua011bHRpcGxlXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcm91bmRSYW5nZVRvQ2h1bmtNdWx0aXBsZShyYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSByYW5nZVsxXSAtIHJhbmdlWzBdICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGVuZ3RoID0gTWF0aC5jZWlsKGxlbmd0aCAvIENIVU5LX1NJWkUpICogQ0hVTktfU0laRTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3JhbmdlWzBdLCByYW5nZVswXSArIG5ld0xlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9tYWtlWEhSUmVxdWVzdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VYSFJSZXF1ZXN0KG1ldGhvZCwgcmFuZ2UsIGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4aHIgPSB0aGlzLl9jcmVhdGVYSFJPYmplY3QoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB0aGlzLl91cmwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgb25YSFJMb2FkID0gZnVuY3Rpb24gb25YSFJMb2FkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gMjAwIC0gT0tcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIDIwNiAtIFBhcnRpYWwgQ29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gJEZsb3dJc3N1ZSAtIHhociB3aWxsIG5vdCBiZSBudWxsIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDAgfHwgeGhyLnN0YXR1cyA9PT0gMjA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MoeGhyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2tzLm9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uRXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwieGhyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbzogXCJVbmV4cGVjdGVkIEhUVFAgc3RhdHVzIFwiICsgeGhyLnN0YXR1cyArIFwiLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHhocjogeGhyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICB4aHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgeGhyLm9ubG9hZCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgeGhyLm9ubG9hZCA9IG9uWEhSTG9hZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uRXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ4aHJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm86IFwiR2VuZXJpYyBYSFIgZXJyb3IsIGNoZWNrIHhociBvYmplY3QuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHI6IHhocixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJEZsb3dJc3N1ZSAtIHhociB3aWxsIG5vdCBiZSBudWxsIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25YSFJMb2FkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoWGhyRmlsZVJlYWRlci5fY29uZmlnLnRpbWVvdXRJblNlYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSBYaHJGaWxlUmVhZGVyLl9jb25maWcudGltZW91dEluU2VjICogMTAwMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzLm9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25FcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInhoclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJEZsb3dJc3N1ZSAtIHhoci50aW1lb3V0IHdpbGwgbm90IGJlIG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGltZW91dCBhZnRlciBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci50aW1lb3V0IC8gMTAwMCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicy4gVXNlIGpzbWVkaWF0YWdzLkNvbmZpZy5zZXRYaHJUaW1lb3V0IHRvIG92ZXJyaWRlLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyOiB4aHIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShcInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVxdWVzdEhlYWRlcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlJhbmdlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYnl0ZXM9XCIgKyByYW5nZVswXSArIFwiLVwiICsgcmFuZ2VbMV1cclxuICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZXF1ZXN0SGVhZGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgeGhyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJJZi1Nb2RpZmllZC1TaW5jZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJTYXQsIDAxIEphbiAxOTcwIDAwOjAwOjAwIEdNVFwiXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiX3NldFJlcXVlc3RIZWFkZXJcIixcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRSZXF1ZXN0SGVhZGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIHhocixcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlclZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgIFhockZpbGVSZWFkZXIuX2NvbmZpZy5kaXNhbGxvd2VkWGhySGVhZGVycy5pbmRleE9mKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJOYW1lLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICAgICAgICAgICAgICkgPCAwXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9oYXNSZXNwb25zZUhlYWRlclwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhc1Jlc3BvbnNlSGVhZGVyKHhociwgaGVhZGVyTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxSZXNwb25zZUhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsUmVzcG9uc2VIZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IGFsbFJlc3BvbnNlSGVhZGVycy5zcGxpdChcIlxcclxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyTmFtZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJOYW1lc1tpXSA9IGhlYWRlcnNbaV0uc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyTmFtZXMuaW5kZXhPZihoZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCkpID49IDA7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiX2dldFJlc3BvbnNlSGVhZGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UmVzcG9uc2VIZWFkZXIoeGhyLCBoZWFkZXJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9oYXNSZXNwb25zZUhlYWRlcih4aHIsIGhlYWRlck5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoaGVhZGVyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiZ2V0Qnl0ZUF0XCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCeXRlQXQob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHRoaXMuX2ZpbGVEYXRhLmdldEJ5dGVBdChvZmZzZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgJiAweGZmO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcIl9pc1dlYldvcmtlclwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzV2ViV29ya2VyKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09IFwidW5kZWZpbmVkXCIgJiZcclxuICAgICAgICAgICAgICAgICAgICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBrZXk6IFwiX2NyZWF0ZVhIUk9iamVjdFwiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVhIUk9iamVjdCgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJiAhdGhpcy5faXNXZWJXb3JrZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gJEZsb3dJc3N1ZSAtIGZsb3cgaXMgbm90IGFibGUgdG8gcmVjb2duaXplIHRoaXMgbW9kdWxlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAocmVxdWlyZShcInhocjJcIikuWE1MSHR0cFJlcXVlc3QpKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcImNhblJlYWRGaWxlXCIsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5SZWFkRmlsZShmaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBmaWxlID09PSBcInN0cmluZ1wiICYmIC9eW2Etel0rOlxcL1xcLy9pLnRlc3QoZmlsZSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAga2V5OiBcInNldENvbmZpZ1wiLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29uZmlnKGNvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjb25maWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25maWdba2V5XSA9IGNvbmZpZ1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc2FsbG93ZWRYaHJIZWFkZXJzID1cclxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5kaXNhbGxvd2VkWGhySGVhZGVycztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNhbGxvd2VkWGhySGVhZGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGlzYWxsb3dlZFhockhlYWRlcnNbaV0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhbGxvd2VkWGhySGVhZGVyc1tpXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFhockZpbGVSZWFkZXI7XHJcbiAgICAgICAgICB9KShNZWRpYUZpbGVSZWFkZXIpO1xyXG5cclxuICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eShYaHJGaWxlUmVhZGVyLCBcIl9jb25maWdcIiwgdm9pZCAwKTtcclxuXHJcbiAgICAgICAgICBYaHJGaWxlUmVhZGVyLl9jb25maWcgPSB7XHJcbiAgICAgICAgICAgIGF2b2lkSGVhZFJlcXVlc3RzOiBmYWxzZSxcclxuICAgICAgICAgICAgZGlzYWxsb3dlZFhockhlYWRlcnM6IFtdLFxyXG4gICAgICAgICAgICB0aW1lb3V0SW5TZWM6IDMwLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gWGhyRmlsZVJlYWRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHsgXCIuL0NodW5rZWRGaWxlRGF0YVwiOiA1LCBcIi4vTWVkaWFGaWxlUmVhZGVyXCI6IDExLCB4aHIyOiAyIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIDE1OiBbXHJcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xyXG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcclxuICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm90b1Byb3BzKVxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcclxuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIE1lZGlhRmlsZVJlYWRlciA9IHJlcXVpcmUoXCIuL01lZGlhRmlsZVJlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgWGhyRmlsZVJlYWRlciA9IHJlcXVpcmUoXCIuL1hockZpbGVSZWFkZXJcIik7XHJcblxyXG4gICAgICAgICAgdmFyIEJsb2JGaWxlUmVhZGVyID0gcmVxdWlyZShcIi4vQmxvYkZpbGVSZWFkZXJcIik7XHJcblxyXG4gICAgICAgICAgdmFyIEFycmF5RmlsZVJlYWRlciA9IHJlcXVpcmUoXCIuL0FycmF5RmlsZVJlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgTWVkaWFUYWdSZWFkZXIgPSByZXF1aXJlKFwiLi9NZWRpYVRhZ1JlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgSUQzdjFUYWdSZWFkZXIgPSByZXF1aXJlKFwiLi9JRDN2MVRhZ1JlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgSUQzdjJUYWdSZWFkZXIgPSByZXF1aXJlKFwiLi9JRDN2MlRhZ1JlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgTVA0VGFnUmVhZGVyID0gcmVxdWlyZShcIi4vTVA0VGFnUmVhZGVyXCIpO1xyXG5cclxuICAgICAgICAgIHZhciBGTEFDVGFnUmVhZGVyID0gcmVxdWlyZShcIi4vRkxBQ1RhZ1JlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgbWVkaWFGaWxlUmVhZGVycyA9IFtdO1xyXG4gICAgICAgICAgdmFyIG1lZGlhVGFnUmVhZGVycyA9IFtdO1xyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIHJlYWQobG9jYXRpb24sIGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICBuZXcgUmVhZGVyKGxvY2F0aW9uKS5yZWFkKGNhbGxiYWNrcyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gaXNSYW5nZVZhbGlkKHJhbmdlLCBmaWxlU2l6ZSkge1xyXG4gICAgICAgICAgICB2YXIgaW52YWxpZFBvc2l0aXZlUmFuZ2UgPVxyXG4gICAgICAgICAgICAgIHJhbmdlLm9mZnNldCA+PSAwICYmIHJhbmdlLm9mZnNldCArIHJhbmdlLmxlbmd0aCA+PSBmaWxlU2l6ZTtcclxuICAgICAgICAgICAgdmFyIGludmFsaWROZWdhdGl2ZVJhbmdlID1cclxuICAgICAgICAgICAgICByYW5nZS5vZmZzZXQgPCAwICYmXHJcbiAgICAgICAgICAgICAgKC1yYW5nZS5vZmZzZXQgPiBmaWxlU2l6ZSB8fCByYW5nZS5vZmZzZXQgKyByYW5nZS5sZW5ndGggPiAwKTtcclxuICAgICAgICAgICAgcmV0dXJuICEoaW52YWxpZFBvc2l0aXZlUmFuZ2UgfHwgaW52YWxpZE5lZ2F0aXZlUmFuZ2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBSZWFkZXIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJlYWRlcihmaWxlKSB7XHJcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9maWxlXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YWdzVG9SZWFkXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9maWxlUmVhZGVyXCIsIHZvaWQgMCk7XHJcblxyXG4gICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YWdSZWFkZXJcIiwgdm9pZCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgdGhpcy5fZmlsZSA9IGZpbGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhSZWFkZXIsIFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXk6IFwic2V0VGFnc1RvUmVhZFwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRhZ3NUb1JlYWQodGFnc1RvUmVhZCkge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLl90YWdzVG9SZWFkID0gdGFnc1RvUmVhZDtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiBcInNldEZpbGVSZWFkZXJcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGaWxlUmVhZGVyKGZpbGVSZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsZVJlYWRlciA9IGZpbGVSZWFkZXI7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogXCJzZXRUYWdSZWFkZXJcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUYWdSZWFkZXIodGFnUmVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3RhZ1JlYWRlciA9IHRhZ1JlYWRlcjtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiBcInJlYWRcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkKGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgRmlsZVJlYWRlciA9IHRoaXMuX2dldEZpbGVSZWFkZXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIodGhpcy5fZmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgZmlsZVJlYWRlci5pbml0KHtcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2dldFRhZ1JlYWRlcihmaWxlUmVhZGVyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKFRhZ1JlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUYWdSZWFkZXIoZmlsZVJlYWRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRUYWdzVG9SZWFkKHNlbGYuX3RhZ3NUb1JlYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVhZChjYWxsYmFja3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBjYWxsYmFja3Mub25FcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogY2FsbGJhY2tzLm9uRXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogXCJfZ2V0RmlsZVJlYWRlclwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRGaWxlUmVhZGVyKCkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmlsZVJlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWxlUmVhZGVyO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kRmlsZVJlYWRlcigpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiBcIl9maW5kRmlsZVJlYWRlclwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kRmlsZVJlYWRlcigpIHtcclxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYUZpbGVSZWFkZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lZGlhRmlsZVJlYWRlcnNbaV0uY2FuUmVhZEZpbGUodGhpcy5fZmlsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYUZpbGVSZWFkZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiTm8gc3VpdGFibGUgZmlsZSByZWFkZXIgZm91bmQgZm9yIFwiICsgdGhpcy5fZmlsZVxyXG4gICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogXCJfZ2V0VGFnUmVhZGVyXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRhZ1JlYWRlcihmaWxlUmVhZGVyLCBjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RhZ1JlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWdSZWFkZXIgPSB0aGlzLl90YWdSZWFkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25TdWNjZXNzKHRhZ1JlYWRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmluZFRhZ1JlYWRlcihmaWxlUmVhZGVyLCBjYWxsYmFja3MpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiBcIl9maW5kVGFnUmVhZGVyXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRUYWdSZWFkZXIoZmlsZVJlYWRlciwgY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gbWFrZSBtdWx0aXBsZSBmZXRjaGVzIHBlciB0YWcgcmVhZGVyIHRvIGdldCB0aGUgdGFnXHJcbiAgICAgICAgICAgICAgICAgIC8vIGlkZW50aWZpZXIuIFRoZSBzdHJhdGVneSBoZXJlIGlzIHRvIGNvbWJpbmUgYWxsIHRoZSB0YWcgaWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgICAvLyByYW5nZXMgaW50byBvbmUgYW5kIG1ha2UgYSBzaW5nbGUgZmV0Y2guIFRoaXMgaXMgcGFydGljdWxhcmx5IGltcG9ydGFudFxyXG4gICAgICAgICAgICAgICAgICAvLyBpbiBmaWxlIHJlYWRlcnMgdGhhdCBoYXZlIGV4cGVuc2l2ZSBsb2FkcyBsaWtlIHRoZSBYSFIgb25lLlxyXG4gICAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCB3aXRoIHRoaXMgc3RyYXRlZ3kgd2UgcnVuIGludG8gdGhlIHByb2JsZW0gb2YgbG9hZGluZyB0aGVcclxuICAgICAgICAgICAgICAgICAgLy8gZW50aXJlIGZpbGUgYmVjYXVzZSB0YWcgaWRlbnRpZmllcnMgbWlnaHQgYmUgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZlxyXG4gICAgICAgICAgICAgICAgICAvLyB0aGUgZmlsZS5cclxuICAgICAgICAgICAgICAgICAgLy8gVG8gZ2V0IGFyb3VuZCB0aGlzIHdlIGRpdmlkZSB0aGUgdGFnIHJlYWRlcnMgaW50byB0d28gY2F0ZWdvcmllcywgdGhlXHJcbiAgICAgICAgICAgICAgICAgIC8vIG9uZXMgdGhhdCByZWFkIHRoZWlyIHRhZyBpZGVudGlmaWVycyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgZmlsZSBhbmQgdGhlXHJcbiAgICAgICAgICAgICAgICAgIC8vIG9uZXMgdGhhdCByZWFkIGZyb20gdGhlIGVuZCBvZiB0aGUgZmlsZS5cclxuICAgICAgICAgICAgICAgICAgdmFyIHRhZ1JlYWRlcnNBdEZpbGVTdGFydCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgdGFnUmVhZGVyc0F0RmlsZUVuZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgZmlsZVNpemUgPSBmaWxlUmVhZGVyLmdldFNpemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFUYWdSZWFkZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gbWVkaWFUYWdSZWFkZXJzW2ldLmdldFRhZ0lkZW50aWZpZXJCeXRlUmFuZ2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JhbmdlVmFsaWQocmFuZ2UsIGZpbGVTaXplKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAocmFuZ2Uub2Zmc2V0ID49IDAgJiYgcmFuZ2Uub2Zmc2V0IDwgZmlsZVNpemUgLyAyKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgKHJhbmdlLm9mZnNldCA8IDAgJiYgcmFuZ2Uub2Zmc2V0IDwgLWZpbGVTaXplIC8gMilcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHRhZ1JlYWRlcnNBdEZpbGVTdGFydC5wdXNoKG1lZGlhVGFnUmVhZGVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHRhZ1JlYWRlcnNBdEZpbGVFbmQucHVzaChtZWRpYVRhZ1JlYWRlcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgdmFyIHRhZ3NMb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgdmFyIGxvYWRUYWdJZGVudGlmaWVyc0NhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcygpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICghdGFnc0xvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBleHBlY3RpbmcgdG8gbG9hZCB0d28gc2V0cyBvZiB0YWcgaWRlbnRpZmllcnMuIFRoaXMgZmxhZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRpY2F0ZXMgd2hlbiB0aGUgZmlyc3Qgb25lIGhhcyBiZWVuIGxvYWRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhVGFnUmVhZGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhVGFnUmVhZGVyc1tpXS5nZXRUYWdJZGVudGlmaWVyQnl0ZVJhbmdlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmFuZ2VWYWxpZChyYW5nZSwgZmlsZVNpemUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ0luZGVudGlmaWVyID0gZmlsZVJlYWRlci5nZXRCeXRlc0F0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uub2Zmc2V0ID49IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByYW5nZS5vZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByYW5nZS5vZmZzZXQgKyBmaWxlU2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25FcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVJlYWRlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvOiBleC5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZWRpYVRhZ1JlYWRlcnNbaV0uY2FuUmVhZFRhZ0Zvcm1hdCh0YWdJbmRlbnRpZmllcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uU3VjY2VzcyhtZWRpYVRhZ1JlYWRlcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja3Mub25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25FcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0YWdGb3JtYXRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvOiBcIk5vIHN1aXRhYmxlIHRhZyByZWFkZXIgZm91bmRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBjYWxsYmFja3Mub25FcnJvcixcclxuICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRUYWdJZGVudGlmaWVyUmFuZ2VzKFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFnUmVhZGVyc0F0RmlsZVN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRUYWdJZGVudGlmaWVyc0NhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZFRhZ0lkZW50aWZpZXJSYW5nZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVJlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICB0YWdSZWFkZXJzQXRGaWxlRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRUYWdJZGVudGlmaWVyc0NhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogXCJfbG9hZFRhZ0lkZW50aWZpZXJSYW5nZXNcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZFRhZ0lkZW50aWZpZXJSYW5nZXMoXHJcbiAgICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIsXHJcbiAgICAgICAgICAgICAgICAgIHRhZ1JlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh0YWdSZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGFzeW5jXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFja3Mub25TdWNjZXNzLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIHZhciB0YWdJZGVudGlmaWVyUmFuZ2UgPSBbTnVtYmVyLk1BWF9WQUxVRSwgMF07XHJcbiAgICAgICAgICAgICAgICAgIHZhciBmaWxlU2l6ZSA9IGZpbGVSZWFkZXIuZ2V0U2l6ZSgpOyAvLyBDcmVhdGUgYSBzdXBlciBzZXQgb2YgYWxsIHJhbmdlcyBzbyB3ZSBjYW4gbG9hZCB0aGVtIGFsbCBhdCBvbmNlLlxyXG4gICAgICAgICAgICAgICAgICAvLyBNaWdodCBuZWVkIHRvIHJldGhpbmsgdGhpcyBhcHByb2FjaCBpZiB0aGVyZSBhcmUgdGFnIHJhbmdlcyB0b28gZmFyXHJcbiAgICAgICAgICAgICAgICAgIC8vIGEgcGFydCBmcm9tIGVhY2ggb3RoZXIuIFdlJ3JlIGdvb2QgZm9yIG5vdyB0aG91Z2guXHJcblxyXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhZ1JlYWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0YWdSZWFkZXJzW2ldLmdldFRhZ0lkZW50aWZpZXJCeXRlUmFuZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uub2Zmc2V0ID49IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyByYW5nZS5vZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByYW5nZS5vZmZzZXQgKyBmaWxlU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ0lkZW50aWZpZXJSYW5nZVswXSA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICB0YWdJZGVudGlmaWVyUmFuZ2VbMF1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ0lkZW50aWZpZXJSYW5nZVsxXSA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgICAgICAgZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdGFnSWRlbnRpZmllclJhbmdlWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgZmlsZVJlYWRlci5sb2FkUmFuZ2UodGFnSWRlbnRpZmllclJhbmdlLCBjYWxsYmFja3MpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBSZWFkZXI7XHJcbiAgICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICAgIHZhciBDb25maWcgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbmZpZygpIHtcclxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKENvbmZpZywgbnVsbCwgW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogXCJhZGRGaWxlUmVhZGVyXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRmlsZVJlYWRlcihmaWxlUmVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgIG1lZGlhRmlsZVJlYWRlcnMucHVzaChmaWxlUmVhZGVyKTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbmZpZztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXk6IFwiYWRkVGFnUmVhZGVyXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVGFnUmVhZGVyKHRhZ1JlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICBtZWRpYVRhZ1JlYWRlcnMucHVzaCh0YWdSZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogXCJyZW1vdmVUYWdSZWFkZXJcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVUYWdSZWFkZXIodGFnUmVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB0YWdSZWFkZXJJeCA9IG1lZGlhVGFnUmVhZGVycy5pbmRleE9mKHRhZ1JlYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAodGFnUmVhZGVySXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhVGFnUmVhZGVycy5zcGxpY2UodGFnUmVhZGVySXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogXCJFWFBFUklNRU5UQUxfYXZvaWRIZWFkUmVxdWVzdHNcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBFWFBFUklNRU5UQUxfYXZvaWRIZWFkUmVxdWVzdHMoKSB7XHJcbiAgICAgICAgICAgICAgICAgIFhockZpbGVSZWFkZXIuc2V0Q29uZmlnKHtcclxuICAgICAgICAgICAgICAgICAgICBhdm9pZEhlYWRSZXF1ZXN0czogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiBcInNldERpc2FsbG93ZWRYaHJIZWFkZXJzXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlzYWxsb3dlZFhockhlYWRlcnMoZGlzYWxsb3dlZFhockhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgWGhyRmlsZVJlYWRlci5zZXRDb25maWcoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FsbG93ZWRYaHJIZWFkZXJzOiBkaXNhbGxvd2VkWGhySGVhZGVycyxcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiBcInNldFhoclRpbWVvdXRJblNlY1wiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFhoclRpbWVvdXRJblNlYyh0aW1lb3V0SW5TZWMpIHtcclxuICAgICAgICAgICAgICAgICAgWGhyRmlsZVJlYWRlci5zZXRDb25maWcoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRJblNlYzogdGltZW91dEluU2VjLFxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQ29uZmlnO1xyXG4gICAgICAgICAgfSkoKTtcclxuXHJcbiAgICAgICAgICBDb25maWcuYWRkRmlsZVJlYWRlcihYaHJGaWxlUmVhZGVyKVxyXG4gICAgICAgICAgICAuYWRkRmlsZVJlYWRlcihCbG9iRmlsZVJlYWRlcilcclxuICAgICAgICAgICAgLmFkZEZpbGVSZWFkZXIoQXJyYXlGaWxlUmVhZGVyKVxyXG4gICAgICAgICAgICAuYWRkVGFnUmVhZGVyKElEM3YyVGFnUmVhZGVyKVxyXG4gICAgICAgICAgICAuYWRkVGFnUmVhZGVyKElEM3YxVGFnUmVhZGVyKVxyXG4gICAgICAgICAgICAuYWRkVGFnUmVhZGVyKE1QNFRhZ1JlYWRlcilcclxuICAgICAgICAgICAgLmFkZFRhZ1JlYWRlcihGTEFDVGFnUmVhZGVyKTtcclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgIXByb2Nlc3MuYnJvd3Nlcikge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCJcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgdmFyIFJlYWN0TmF0aXZlRmlsZVJlYWRlciA9IHJlcXVpcmUoXCIuL1JlYWN0TmF0aXZlRmlsZVJlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICAgICAgQ29uZmlnLmFkZEZpbGVSZWFkZXIoUmVhY3ROYXRpdmVGaWxlUmVhZGVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB2YXIgTm9kZUZpbGVSZWFkZXIgPSByZXF1aXJlKFwiLi9Ob2RlRmlsZVJlYWRlclwiKTtcclxuXHJcbiAgICAgICAgICAgICAgQ29uZmlnLmFkZEZpbGVSZWFkZXIoTm9kZUZpbGVSZWFkZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgICAgIHJlYWQ6IHJlYWQsXHJcbiAgICAgICAgICAgIFJlYWRlcjogUmVhZGVyLFxyXG4gICAgICAgICAgICBDb25maWc6IENvbmZpZyxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcIi4vQXJyYXlGaWxlUmVhZGVyXCI6IDMsXHJcbiAgICAgICAgICBcIi4vQmxvYkZpbGVSZWFkZXJcIjogNCxcclxuICAgICAgICAgIFwiLi9GTEFDVGFnUmVhZGVyXCI6IDYsXHJcbiAgICAgICAgICBcIi4vSUQzdjFUYWdSZWFkZXJcIjogNyxcclxuICAgICAgICAgIFwiLi9JRDN2MlRhZ1JlYWRlclwiOiA5LFxyXG4gICAgICAgICAgXCIuL01QNFRhZ1JlYWRlclwiOiAxMCxcclxuICAgICAgICAgIFwiLi9NZWRpYUZpbGVSZWFkZXJcIjogMTEsXHJcbiAgICAgICAgICBcIi4vTWVkaWFUYWdSZWFkZXJcIjogMTIsXHJcbiAgICAgICAgICBcIi4vTm9kZUZpbGVSZWFkZXJcIjogMSxcclxuICAgICAgICAgIFwiLi9SZWFjdE5hdGl2ZUZpbGVSZWFkZXJcIjogMSxcclxuICAgICAgICAgIFwiLi9YaHJGaWxlUmVhZGVyXCI6IDE0LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAge30sXHJcbiAgICBbMTVdXHJcbiAgKSgxNSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///907\n')}},I=>{I(I.s=819)}]);