"use strict";(self.webpackChunkwebpack_babel_template=self.webpackChunkwebpack_babel_template||[]).push([[401],{73:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMuanMiLCJtYXBwaW5ncyI6IjtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFjay1iYWJlbC10ZW1wbGF0ZS8uL3NyYy9wYWdlcy9jb25uZWN0ZWQtYnJvd3NlcnMvc3R5bGVzL2luZGV4LnNjc3M/ZjMyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///73\n")},764:(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.CanvasDraw = void 0;\nconst Transformation_1 = __webpack_require__(695);\nclass CanvasDraw {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.limits = [canvas.width, canvas.height, 0];\n    }\n    drawLine(start, end, ...args) {\n        let x0 = start.x;\n        let y0 = start.y;\n        let x1 = end.x;\n        let y1 = end.y;\n        // Draw the line while clipping it\n        const [xMax, yMax, zMax] = this.limits;\n        // Cohen-Sutherland Algorithm\n        const INSIDE = 0; // 0000\n        const LEFT = 1; // 0001\n        const RIGHT = 2; // 0010\n        const BOTTOM = 4; // 0100\n        const TOP = 8; // 1000\n        const xMin = 0;\n        const yMin = 0;\n        const computeCode = (x, y) => {\n            let code = INSIDE;\n            if (x < xMin)\n                code |= LEFT;\n            if (x > xMax)\n                code |= RIGHT;\n            if (y < yMin)\n                code |= BOTTOM;\n            if (y > yMax)\n                code |= TOP;\n            return code;\n        };\n        let code0 = computeCode(x0, y0);\n        let code1 = computeCode(x1, y1);\n        let accept = false;\n        while (true) {\n            if (!(code0 | code1)) {\n                accept = true;\n                break;\n            }\n            else if (code0 & code1) {\n                break;\n            }\n            else {\n                let x = 0;\n                let y = 0;\n                let codeOut = code0 ? code0 : code1;\n                if (codeOut & TOP) {\n                    x = x0 + ((x1 - x0) * (yMax - y0)) / (y1 - y0);\n                    y = yMax;\n                }\n                else if (codeOut & BOTTOM) {\n                    x = x0 + ((x1 - x0) * (yMin - y0)) / (y1 - y0);\n                    y = yMin;\n                }\n                else if (codeOut & RIGHT) {\n                    y = y0 + ((y1 - y0) * (xMax - x0)) / (x1 - x0);\n                    x = xMax;\n                }\n                else if (codeOut & LEFT) {\n                    y = y0 + ((y1 - y0) * (xMin - x0)) / (x1 - x0);\n                    x = xMin;\n                }\n                if (codeOut === code0) {\n                    x0 = x;\n                    y0 = y;\n                    code0 = computeCode(x0, y0);\n                }\n                else {\n                    x1 = x;\n                    y1 = y;\n                    code1 = computeCode(x1, y1);\n                }\n            }\n        }\n        return [new Transformation_1.Vector(x0, y0, 0), new Transformation_1.Vector(x1, y1, 0)];\n    }\n}\nexports.CanvasDraw = CanvasDraw;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQix5QkFBeUIsbUJBQU8sQ0FBQyxHQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFjay1iYWJlbC10ZW1wbGF0ZS8uL3NyYy9wYWdlcy9jb25uZWN0ZWQtYnJvd3NlcnMvc2NyaXB0cy9DYW52YXNEcmF3LnRzPzA5OGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbnZhc0RyYXcgPSB2b2lkIDA7XG5jb25zdCBUcmFuc2Zvcm1hdGlvbl8xID0gcmVxdWlyZShcIi4vVHJhbnNmb3JtYXRpb25cIik7XG5jbGFzcyBDYW52YXNEcmF3IHtcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIHRoaXMubGltaXRzID0gW2NhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgMF07XG4gICAgfVxuICAgIGRyYXdMaW5lKHN0YXJ0LCBlbmQsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHgwID0gc3RhcnQueDtcbiAgICAgICAgbGV0IHkwID0gc3RhcnQueTtcbiAgICAgICAgbGV0IHgxID0gZW5kLng7XG4gICAgICAgIGxldCB5MSA9IGVuZC55O1xuICAgICAgICAvLyBEcmF3IHRoZSBsaW5lIHdoaWxlIGNsaXBwaW5nIGl0XG4gICAgICAgIGNvbnN0IFt4TWF4LCB5TWF4LCB6TWF4XSA9IHRoaXMubGltaXRzO1xuICAgICAgICAvLyBDb2hlbi1TdXRoZXJsYW5kIEFsZ29yaXRobVxuICAgICAgICBjb25zdCBJTlNJREUgPSAwOyAvLyAwMDAwXG4gICAgICAgIGNvbnN0IExFRlQgPSAxOyAvLyAwMDAxXG4gICAgICAgIGNvbnN0IFJJR0hUID0gMjsgLy8gMDAxMFxuICAgICAgICBjb25zdCBCT1RUT00gPSA0OyAvLyAwMTAwXG4gICAgICAgIGNvbnN0IFRPUCA9IDg7IC8vIDEwMDBcbiAgICAgICAgY29uc3QgeE1pbiA9IDA7XG4gICAgICAgIGNvbnN0IHlNaW4gPSAwO1xuICAgICAgICBjb25zdCBjb21wdXRlQ29kZSA9ICh4LCB5KSA9PiB7XG4gICAgICAgICAgICBsZXQgY29kZSA9IElOU0lERTtcbiAgICAgICAgICAgIGlmICh4IDwgeE1pbilcbiAgICAgICAgICAgICAgICBjb2RlIHw9IExFRlQ7XG4gICAgICAgICAgICBpZiAoeCA+IHhNYXgpXG4gICAgICAgICAgICAgICAgY29kZSB8PSBSSUdIVDtcbiAgICAgICAgICAgIGlmICh5IDwgeU1pbilcbiAgICAgICAgICAgICAgICBjb2RlIHw9IEJPVFRPTTtcbiAgICAgICAgICAgIGlmICh5ID4geU1heClcbiAgICAgICAgICAgICAgICBjb2RlIHw9IFRPUDtcbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgY29kZTAgPSBjb21wdXRlQ29kZSh4MCwgeTApO1xuICAgICAgICBsZXQgY29kZTEgPSBjb21wdXRlQ29kZSh4MSwgeTEpO1xuICAgICAgICBsZXQgYWNjZXB0ID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoIShjb2RlMCB8IGNvZGUxKSkge1xuICAgICAgICAgICAgICAgIGFjY2VwdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlMCAmIGNvZGUxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlT3V0ID0gY29kZTAgPyBjb2RlMCA6IGNvZGUxO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlT3V0ICYgVE9QKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4MCArICgoeDEgLSB4MCkgKiAoeU1heCAtIHkwKSkgLyAoeTEgLSB5MCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5TWF4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlT3V0ICYgQk9UVE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4MCArICgoeDEgLSB4MCkgKiAoeU1pbiAtIHkwKSkgLyAoeTEgLSB5MCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5TWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlT3V0ICYgUklHSFQpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkwICsgKCh5MSAtIHkwKSAqICh4TWF4IC0geDApKSAvICh4MSAtIHgwKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHhNYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGVPdXQgJiBMRUZUKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5MCArICgoeTEgLSB5MCkgKiAoeE1pbiAtIHgwKSkgLyAoeDEgLSB4MCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4TWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29kZU91dCA9PT0gY29kZTApIHtcbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4O1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUwID0gY29tcHV0ZUNvZGUoeDAsIHkwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHgxID0geDtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSB5O1xuICAgICAgICAgICAgICAgICAgICBjb2RlMSA9IGNvbXB1dGVDb2RlKHgxLCB5MSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbmV3IFRyYW5zZm9ybWF0aW9uXzEuVmVjdG9yKHgwLCB5MCwgMCksIG5ldyBUcmFuc2Zvcm1hdGlvbl8xLlZlY3Rvcih4MSwgeTEsIDApXTtcbiAgICB9XG59XG5leHBvcnRzLkNhbnZhc0RyYXcgPSBDYW52YXNEcmF3O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///764\n')},722:(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Observable = void 0;\nclass Observable {\n    constructor(val) {\n        this.subscribers = [];\n        this.data = val;\n    }\n    get value() {\n        return this.data;\n    }\n    subscribe(cb) {\n        this.subscribers.push(cb);\n    }\n    set value(val) {\n        const old = this.data;\n        this.data = val;\n        this.subscribers.forEach((cb) => cb(this.data, old));\n    }\n}\nexports.Observable = Observable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFjay1iYWJlbC10ZW1wbGF0ZS8uL3NyYy9wYWdlcy9jb25uZWN0ZWQtYnJvd3NlcnMvc2NyaXB0cy9PYnNlcnZhYmxlLnRzPzYzYjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9ic2VydmFibGUgPSB2b2lkIDA7XG5jbGFzcyBPYnNlcnZhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICB0aGlzLmRhdGEgPSB2YWw7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKGNiKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWwpIHtcbiAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLmRhdGEgPSB2YWw7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaCgoY2IpID0+IGNiKHRoaXMuZGF0YSwgb2xkKSk7XG4gICAgfVxufVxuZXhwb3J0cy5PYnNlcnZhYmxlID0gT2JzZXJ2YWJsZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///722\n')},695:(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Transformation = exports.Coordinates = exports.Matrix = exports.Vector = void 0;\nclass Vector {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    mat() {\n        return new Matrix([[this.x], [this.y], [this.z]]);\n    }\n    add(vec) {\n        const { x: x1, y: y1, z: z1 } = this;\n        const { x: x2, y: y2, z: z2 } = vec;\n        return new Vector(x1 + x2, y1 + y2, z1 + z2);\n    }\n    static fromMat(mat) {\n        if (!(mat.dim[0] === 3 && mat.dim[1] === 1))\n            throw new Error(`Matrix of dimensions (${mat.dim.join(", ")}) can\'t be converted to a Vector`);\n        return new Vector(mat.get(0, 0), mat.get(1, 0), mat.get(2, 0));\n    }\n}\nexports.Vector = Vector;\nclass Matrix {\n    constructor(val) {\n        this.val = val;\n        // Check if the dimensions match\n        const i = val.length;\n        const j = val[0].length;\n        if (!val.reduce((acc, row) => acc && row.length === j, true)) {\n            throw new Error("Invalid dimensions");\n        }\n        this.dim = [i, j];\n    }\n    sub(mat) {\n        return new Matrix(this.val.map((r, j) => r.map((v, i) => v - mat.get(i, j))));\n    }\n    add(mat) {\n        return new Matrix(this.val.map((r, j) => r.map((v, i) => v + mat.get(i, j))));\n    }\n    mul(mat) {\n        // Check if the dimensions match\n        const [m1, n1] = this.dim;\n        const [m2, n2] = mat.dim;\n        if (n1 !== m2)\n            throw new Error(`Dimensions mis-match (${m1}, ${n1}) and (${m2}, ${n2})`);\n        const newMat = new Matrix(Array.from({ length: m1 }, () => Array.from({ length: n2 }, () => 0)));\n        let idx = [0, 0];\n        while (true) {\n            const [i, j] = idx;\n            const r1 = this.val[i];\n            const res = r1.reduce((acc, e1, idx) => acc + mat.get(idx, j) * e1, 0);\n            newMat.set(i, j, res);\n            const nextIdx = this.nextIdx(...idx);\n            if (nextIdx === null) {\n                break;\n            }\n            idx = nextIdx;\n        }\n        return newMat;\n    }\n    get(i, j) {\n        return this.val[i][j];\n    }\n    set(i, j, val) {\n        this.val[i][j] = val !== null && val !== void 0 ? val : 0;\n    }\n    [Symbol.iterator]() {\n        const iteratorPosition = [0, 0];\n        return {\n            next: () => {\n                const [i, j] = iteratorPosition;\n                const result = { value: this.get(i, j), done: false };\n                const nextIdx = this.nextIdx(i, j);\n                if (nextIdx === null) {\n                    result.done = true;\n                }\n                return result;\n            },\n        };\n    }\n    checkIdx(i, j) {\n        const [m, n] = this.dim;\n        return i < m && j < n;\n    }\n    nextIdx(i, j) {\n        const [m, n] = this.dim;\n        let resI = i, resJ = j;\n        if (j + 1 >= n) {\n            resJ = 0;\n            resI = i + 1;\n        }\n        else {\n            resJ = j + 1;\n        }\n        if (resI >= m) {\n            return null;\n        }\n        return [resI, resJ];\n    }\n}\nexports.Matrix = Matrix;\nclass Coordinates {\n    constructor(coords) {\n        this.coords = coords;\n    }\n}\nexports.Coordinates = Coordinates;\nclass Transformation {\n    constructor({ translation = new Vector(0, 0, 0), rotation = new Vector(0, 0, 0), scale = new Vector(1, 1, 1), }) {\n        this.translation = translation;\n        this.rotation = rotation;\n        this.scale = scale;\n    }\n    applyTransformation(pos) {\n        // Scale, Rotate and then Translate\n        // 1. Scale\n        let endPos = Transformation.applyScaling(pos, this.scale);\n        // 2. Rotation\n        endPos = Transformation.applyRotation(endPos, this.rotation);\n        // 3. Translation\n        endPos = Transformation.applyTranslation(endPos, this.translation);\n        return endPos;\n    }\n    static applyTranslation(pos, translation) {\n        return pos.add(translation);\n    }\n    static applyRotation(pos, rotation) {\n        const y = rotation.x;\n        const p = rotation.y;\n        const r = rotation.z;\n        const zMat = new Matrix([\n            [Math.cos(y), -Math.sin(y), 0],\n            [Math.sin(y), Math.cos(y), 0],\n            [0, 0, 1],\n        ]);\n        const yMat = new Matrix([\n            [Math.cos(p), 0, Math.sin(y)],\n            [0, 1, 0],\n            [-Math.sin(y), 0, Math.cos(y)],\n        ]);\n        const xMat = new Matrix([\n            [1, 0, 0],\n            [0, Math.cos(r), -Math.sin(r)],\n            [0, Math.sin(r), Math.cos(r)],\n        ]);\n        return Vector.fromMat(zMat.mul(yMat.mul(xMat)).mul(pos.mat()));\n    }\n    static applyScaling(pos, scale) {\n        const scaleMat = this.generateMatrix(scale);\n        return Vector.fromMat(scaleMat.mul(pos.mat()));\n    }\n    static generateMatrix(pos) {\n        return new Matrix([\n            [pos.x, 0, 0],\n            [0, pos.y, 0],\n            [0, 0, pos.z],\n        ]);\n    }\n}\nexports.Transformation = Transformation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk1LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1CQUFtQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsR0FBRyxJQUFJLEdBQUcsU0FBUyxHQUFHLElBQUksR0FBRztBQUNsRiwrQ0FBK0MsWUFBWSxxQkFBcUIsWUFBWTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxrQkFBa0IsaUdBQWlHO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrLWJhYmVsLXRlbXBsYXRlLy4vc3JjL3BhZ2VzL2Nvbm5lY3RlZC1icm93c2Vycy9zY3JpcHRzL1RyYW5zZm9ybWF0aW9uLnRzP2Y5YzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zZm9ybWF0aW9uID0gZXhwb3J0cy5Db29yZGluYXRlcyA9IGV4cG9ydHMuTWF0cml4ID0gZXhwb3J0cy5WZWN0b3IgPSB2b2lkIDA7XG5jbGFzcyBWZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHopIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICB9XG4gICAgbWF0KCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChbW3RoaXMueF0sIFt0aGlzLnldLCBbdGhpcy56XV0pO1xuICAgIH1cbiAgICBhZGQodmVjKSB7XG4gICAgICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxLCB6OiB6MSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB4OiB4MiwgeTogeTIsIHo6IHoyIH0gPSB2ZWM7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHgxICsgeDIsIHkxICsgeTIsIHoxICsgejIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU1hdChtYXQpIHtcbiAgICAgICAgaWYgKCEobWF0LmRpbVswXSA9PT0gMyAmJiBtYXQuZGltWzFdID09PSAxKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWF0cml4IG9mIGRpbWVuc2lvbnMgKCR7bWF0LmRpbS5qb2luKFwiLCBcIil9KSBjYW4ndCBiZSBjb252ZXJ0ZWQgdG8gYSBWZWN0b3JgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IobWF0LmdldCgwLCAwKSwgbWF0LmdldCgxLCAwKSwgbWF0LmdldCgyLCAwKSk7XG4gICAgfVxufVxuZXhwb3J0cy5WZWN0b3IgPSBWZWN0b3I7XG5jbGFzcyBNYXRyaXgge1xuICAgIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRpbWVuc2lvbnMgbWF0Y2hcbiAgICAgICAgY29uc3QgaSA9IHZhbC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGogPSB2YWxbMF0ubGVuZ3RoO1xuICAgICAgICBpZiAoIXZhbC5yZWR1Y2UoKGFjYywgcm93KSA9PiBhY2MgJiYgcm93Lmxlbmd0aCA9PT0gaiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGltZW5zaW9uc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpbSA9IFtpLCBqXTtcbiAgICB9XG4gICAgc3ViKG1hdCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLnZhbC5tYXAoKHIsIGopID0+IHIubWFwKCh2LCBpKSA9PiB2IC0gbWF0LmdldChpLCBqKSkpKTtcbiAgICB9XG4gICAgYWRkKG1hdCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLnZhbC5tYXAoKHIsIGopID0+IHIubWFwKCh2LCBpKSA9PiB2ICsgbWF0LmdldChpLCBqKSkpKTtcbiAgICB9XG4gICAgbXVsKG1hdCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZGltZW5zaW9ucyBtYXRjaFxuICAgICAgICBjb25zdCBbbTEsIG4xXSA9IHRoaXMuZGltO1xuICAgICAgICBjb25zdCBbbTIsIG4yXSA9IG1hdC5kaW07XG4gICAgICAgIGlmIChuMSAhPT0gbTIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpbWVuc2lvbnMgbWlzLW1hdGNoICgke20xfSwgJHtuMX0pIGFuZCAoJHttMn0sICR7bjJ9KWApO1xuICAgICAgICBjb25zdCBuZXdNYXQgPSBuZXcgTWF0cml4KEFycmF5LmZyb20oeyBsZW5ndGg6IG0xIH0sICgpID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IG4yIH0sICgpID0+IDApKSk7XG4gICAgICAgIGxldCBpZHggPSBbMCwgMF07XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBbaSwgal0gPSBpZHg7XG4gICAgICAgICAgICBjb25zdCByMSA9IHRoaXMudmFsW2ldO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gcjEucmVkdWNlKChhY2MsIGUxLCBpZHgpID0+IGFjYyArIG1hdC5nZXQoaWR4LCBqKSAqIGUxLCAwKTtcbiAgICAgICAgICAgIG5ld01hdC5zZXQoaSwgaiwgcmVzKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRJZHggPSB0aGlzLm5leHRJZHgoLi4uaWR4KTtcbiAgICAgICAgICAgIGlmIChuZXh0SWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggPSBuZXh0SWR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdNYXQ7XG4gICAgfVxuICAgIGdldChpLCBqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbFtpXVtqXTtcbiAgICB9XG4gICAgc2V0KGksIGosIHZhbCkge1xuICAgICAgICB0aGlzLnZhbFtpXVtqXSA9IHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHZvaWQgMCA/IHZhbCA6IDA7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclBvc2l0aW9uID0gWzAsIDBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtpLCBqXSA9IGl0ZXJhdG9yUG9zaXRpb247XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogdGhpcy5nZXQoaSwgaiksIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dElkeCA9IHRoaXMubmV4dElkeChpLCBqKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dElkeCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVja0lkeChpLCBqKSB7XG4gICAgICAgIGNvbnN0IFttLCBuXSA9IHRoaXMuZGltO1xuICAgICAgICByZXR1cm4gaSA8IG0gJiYgaiA8IG47XG4gICAgfVxuICAgIG5leHRJZHgoaSwgaikge1xuICAgICAgICBjb25zdCBbbSwgbl0gPSB0aGlzLmRpbTtcbiAgICAgICAgbGV0IHJlc0kgPSBpLCByZXNKID0gajtcbiAgICAgICAgaWYgKGogKyAxID49IG4pIHtcbiAgICAgICAgICAgIHJlc0ogPSAwO1xuICAgICAgICAgICAgcmVzSSA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzSiA9IGogKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNJID49IG0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcmVzSSwgcmVzSl07XG4gICAgfVxufVxuZXhwb3J0cy5NYXRyaXggPSBNYXRyaXg7XG5jbGFzcyBDb29yZGluYXRlcyB7XG4gICAgY29uc3RydWN0b3IoY29vcmRzKSB7XG4gICAgICAgIHRoaXMuY29vcmRzID0gY29vcmRzO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29vcmRpbmF0ZXMgPSBDb29yZGluYXRlcztcbmNsYXNzIFRyYW5zZm9ybWF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHRyYW5zbGF0aW9uID0gbmV3IFZlY3RvcigwLCAwLCAwKSwgcm90YXRpb24gPSBuZXcgVmVjdG9yKDAsIDAsIDApLCBzY2FsZSA9IG5ldyBWZWN0b3IoMSwgMSwgMSksIH0pIHtcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uO1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB9XG4gICAgYXBwbHlUcmFuc2Zvcm1hdGlvbihwb3MpIHtcbiAgICAgICAgLy8gU2NhbGUsIFJvdGF0ZSBhbmQgdGhlbiBUcmFuc2xhdGVcbiAgICAgICAgLy8gMS4gU2NhbGVcbiAgICAgICAgbGV0IGVuZFBvcyA9IFRyYW5zZm9ybWF0aW9uLmFwcGx5U2NhbGluZyhwb3MsIHRoaXMuc2NhbGUpO1xuICAgICAgICAvLyAyLiBSb3RhdGlvblxuICAgICAgICBlbmRQb3MgPSBUcmFuc2Zvcm1hdGlvbi5hcHBseVJvdGF0aW9uKGVuZFBvcywgdGhpcy5yb3RhdGlvbik7XG4gICAgICAgIC8vIDMuIFRyYW5zbGF0aW9uXG4gICAgICAgIGVuZFBvcyA9IFRyYW5zZm9ybWF0aW9uLmFwcGx5VHJhbnNsYXRpb24oZW5kUG9zLCB0aGlzLnRyYW5zbGF0aW9uKTtcbiAgICAgICAgcmV0dXJuIGVuZFBvcztcbiAgICB9XG4gICAgc3RhdGljIGFwcGx5VHJhbnNsYXRpb24ocG9zLCB0cmFuc2xhdGlvbikge1xuICAgICAgICByZXR1cm4gcG9zLmFkZCh0cmFuc2xhdGlvbik7XG4gICAgfVxuICAgIHN0YXRpYyBhcHBseVJvdGF0aW9uKHBvcywgcm90YXRpb24pIHtcbiAgICAgICAgY29uc3QgeSA9IHJvdGF0aW9uLng7XG4gICAgICAgIGNvbnN0IHAgPSByb3RhdGlvbi55O1xuICAgICAgICBjb25zdCByID0gcm90YXRpb24uejtcbiAgICAgICAgY29uc3Qgek1hdCA9IG5ldyBNYXRyaXgoW1xuICAgICAgICAgICAgW01hdGguY29zKHkpLCAtTWF0aC5zaW4oeSksIDBdLFxuICAgICAgICAgICAgW01hdGguc2luKHkpLCBNYXRoLmNvcyh5KSwgMF0sXG4gICAgICAgICAgICBbMCwgMCwgMV0sXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCB5TWF0ID0gbmV3IE1hdHJpeChbXG4gICAgICAgICAgICBbTWF0aC5jb3MocCksIDAsIE1hdGguc2luKHkpXSxcbiAgICAgICAgICAgIFswLCAxLCAwXSxcbiAgICAgICAgICAgIFstTWF0aC5zaW4oeSksIDAsIE1hdGguY29zKHkpXSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHhNYXQgPSBuZXcgTWF0cml4KFtcbiAgICAgICAgICAgIFsxLCAwLCAwXSxcbiAgICAgICAgICAgIFswLCBNYXRoLmNvcyhyKSwgLU1hdGguc2luKHIpXSxcbiAgICAgICAgICAgIFswLCBNYXRoLnNpbihyKSwgTWF0aC5jb3MocildLFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIFZlY3Rvci5mcm9tTWF0KHpNYXQubXVsKHlNYXQubXVsKHhNYXQpKS5tdWwocG9zLm1hdCgpKSk7XG4gICAgfVxuICAgIHN0YXRpYyBhcHBseVNjYWxpbmcocG9zLCBzY2FsZSkge1xuICAgICAgICBjb25zdCBzY2FsZU1hdCA9IHRoaXMuZ2VuZXJhdGVNYXRyaXgoc2NhbGUpO1xuICAgICAgICByZXR1cm4gVmVjdG9yLmZyb21NYXQoc2NhbGVNYXQubXVsKHBvcy5tYXQoKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGVNYXRyaXgocG9zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KFtcbiAgICAgICAgICAgIFtwb3MueCwgMCwgMF0sXG4gICAgICAgICAgICBbMCwgcG9zLnksIDBdLFxuICAgICAgICAgICAgWzAsIDAsIHBvcy56XSxcbiAgICAgICAgXSk7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2Zvcm1hdGlvbiA9IFRyYW5zZm9ybWF0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///695\n')},131:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\n\n__webpack_unused_export__ = ({ value: true });\n__webpack_require__(73);\nconst CanvasDraw_1 = __webpack_require__(764);\nconst Observable_1 = __webpack_require__(722);\nconsole.log("CONNECTED!");\nconst canvasEl = document.createElement("canvas");\ncanvasEl.width = window.innerWidth;\ncanvasEl.height = window.innerHeight;\ncanvasEl.id = "main-canvas";\ndocument.body.appendChild(canvasEl);\nconst cd = new CanvasDraw_1.CanvasDraw(canvasEl);\nconst screenDetails = {\n    width: window.screen.width,\n    height: window.screen.height,\n};\nconst vpo = new Observable_1.Observable({\n    width: window.innerWidth,\n    height: window.innerHeight,\n    x: window.screenX,\n    y: window.screenY,\n});\nfunction drawLocalAxes(details) {\n    const ctx = canvasEl.getContext("2d");\n    if (!ctx)\n        throw new Error("Context not found... Pls search your bag for it");\n    // Global axes are at the center of the screen (actual). We need to draw local axes by checking if the axes are in thw viewport of the screen\n    const { width, height, x, y } = details;\n    const globalXCenter = screenDetails.width / 2;\n    const globalYCenter = screenDetails.height / 2;\n    const localXCenter = globalXCenter - x;\n    const localYCenter = globalYCenter - y;\n    // x Axis\n    if (localXCenter >= 0 && localXCenter <= width) {\n        const xAxis = new Path2D();\n        xAxis.moveTo(localXCenter, 0);\n        xAxis.lineTo(localXCenter, height);\n        ctx.stroke(xAxis);\n    }\n    // y Axis\n    if (localYCenter >= 0 && localYCenter <= height) {\n        const yAxis = new Path2D();\n        yAxis.moveTo(0, localYCenter);\n        yAxis.lineTo(width, localYCenter);\n        ctx.stroke(yAxis);\n    }\n}\nvpo.subscribe((newDetails, oldDetails) => {\n    // Clear the canvas\n    const ctx = canvasEl.getContext("2d");\n    if (!ctx)\n        throw new Error("Context not found... Pls search your bag for it");\n    canvasEl.width = newDetails.width;\n    canvasEl.height = newDetails.height;\n    ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);\n    drawLocalAxes(newDetails);\n});\ndrawLocalAxes(vpo.value);\nsetInterval(() => {\n    vpo.value = {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        x: window.screenX,\n        y: window.screenY,\n    };\n}, 1000 / 60);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDZCQUE2QyxFQUFFLGFBQWEsQ0FBQztBQUM3RCxtQkFBTyxDQUFDLEVBQXNCO0FBQzlCLHFCQUFxQixtQkFBTyxDQUFDLEdBQWM7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsR0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrLWJhYmVsLXRlbXBsYXRlLy4vc3JjL3BhZ2VzL2Nvbm5lY3RlZC1icm93c2Vycy9zY3JpcHRzL2luZGV4LnRzPzVkYzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5yZXF1aXJlKFwiLi4vc3R5bGVzL2luZGV4LnNjc3NcIik7XG5jb25zdCBDYW52YXNEcmF3XzEgPSByZXF1aXJlKFwiLi9DYW52YXNEcmF3XCIpO1xuY29uc3QgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVwiKTtcbmNvbnNvbGUubG9nKFwiQ09OTkVDVEVEIVwiKTtcbmNvbnN0IGNhbnZhc0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbmNhbnZhc0VsLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5jYW52YXNFbC5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5jYW52YXNFbC5pZCA9IFwibWFpbi1jYW52YXNcIjtcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzRWwpO1xuY29uc3QgY2QgPSBuZXcgQ2FudmFzRHJhd18xLkNhbnZhc0RyYXcoY2FudmFzRWwpO1xuY29uc3Qgc2NyZWVuRGV0YWlscyA9IHtcbiAgICB3aWR0aDogd2luZG93LnNjcmVlbi53aWR0aCxcbiAgICBoZWlnaHQ6IHdpbmRvdy5zY3JlZW4uaGVpZ2h0LFxufTtcbmNvbnN0IHZwbyA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSh7XG4gICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgIHg6IHdpbmRvdy5zY3JlZW5YLFxuICAgIHk6IHdpbmRvdy5zY3JlZW5ZLFxufSk7XG5mdW5jdGlvbiBkcmF3TG9jYWxBeGVzKGRldGFpbHMpIHtcbiAgICBjb25zdCBjdHggPSBjYW52YXNFbC5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFjdHgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgbm90IGZvdW5kLi4uIFBscyBzZWFyY2ggeW91ciBiYWcgZm9yIGl0XCIpO1xuICAgIC8vIEdsb2JhbCBheGVzIGFyZSBhdCB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW4gKGFjdHVhbCkuIFdlIG5lZWQgdG8gZHJhdyBsb2NhbCBheGVzIGJ5IGNoZWNraW5nIGlmIHRoZSBheGVzIGFyZSBpbiB0aHcgdmlld3BvcnQgb2YgdGhlIHNjcmVlblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9ID0gZGV0YWlscztcbiAgICBjb25zdCBnbG9iYWxYQ2VudGVyID0gc2NyZWVuRGV0YWlscy53aWR0aCAvIDI7XG4gICAgY29uc3QgZ2xvYmFsWUNlbnRlciA9IHNjcmVlbkRldGFpbHMuaGVpZ2h0IC8gMjtcbiAgICBjb25zdCBsb2NhbFhDZW50ZXIgPSBnbG9iYWxYQ2VudGVyIC0geDtcbiAgICBjb25zdCBsb2NhbFlDZW50ZXIgPSBnbG9iYWxZQ2VudGVyIC0geTtcbiAgICAvLyB4IEF4aXNcbiAgICBpZiAobG9jYWxYQ2VudGVyID49IDAgJiYgbG9jYWxYQ2VudGVyIDw9IHdpZHRoKSB7XG4gICAgICAgIGNvbnN0IHhBeGlzID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICB4QXhpcy5tb3ZlVG8obG9jYWxYQ2VudGVyLCAwKTtcbiAgICAgICAgeEF4aXMubGluZVRvKGxvY2FsWENlbnRlciwgaGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZSh4QXhpcyk7XG4gICAgfVxuICAgIC8vIHkgQXhpc1xuICAgIGlmIChsb2NhbFlDZW50ZXIgPj0gMCAmJiBsb2NhbFlDZW50ZXIgPD0gaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHlBeGlzID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICB5QXhpcy5tb3ZlVG8oMCwgbG9jYWxZQ2VudGVyKTtcbiAgICAgICAgeUF4aXMubGluZVRvKHdpZHRoLCBsb2NhbFlDZW50ZXIpO1xuICAgICAgICBjdHguc3Ryb2tlKHlBeGlzKTtcbiAgICB9XG59XG52cG8uc3Vic2NyaWJlKChuZXdEZXRhaWxzLCBvbGREZXRhaWxzKSA9PiB7XG4gICAgLy8gQ2xlYXIgdGhlIGNhbnZhc1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhc0VsLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGV4dCBub3QgZm91bmQuLi4gUGxzIHNlYXJjaCB5b3VyIGJhZyBmb3IgaXRcIik7XG4gICAgY2FudmFzRWwud2lkdGggPSBuZXdEZXRhaWxzLndpZHRoO1xuICAgIGNhbnZhc0VsLmhlaWdodCA9IG5ld0RldGFpbHMuaGVpZ2h0O1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzRWwud2lkdGgsIGNhbnZhc0VsLmhlaWdodCk7XG4gICAgZHJhd0xvY2FsQXhlcyhuZXdEZXRhaWxzKTtcbn0pO1xuZHJhd0xvY2FsQXhlcyh2cG8udmFsdWUpO1xuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIHZwby52YWx1ZSA9IHtcbiAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgeDogd2luZG93LnNjcmVlblgsXG4gICAgICAgIHk6IHdpbmRvdy5zY3JlZW5ZLFxuICAgIH07XG59LCAxMDAwIC8gNjApO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///131\n')}},I=>{I(I.s=131)}]);